--- START FILE: Camera\CameraController.cs ---

using System.Collections.Generic;
using System.Linq;
using UnityEngine;

public class CameraController : MonoBehaviour
{
    [Header("References")]
    [SerializeField] private Transform playerTransform;
    [SerializeField] private Transform cameraActualTransform; // For vertical rotation (child of this rig)
    [SerializeField] private Transform cameraPivotTransform; // The Unity Camera's transform

    [Header("General Settings")]
    [SerializeField] private float generalSmoothTime = 0.15f;
    [SerializeField] private LayerMask obstructionLayers;
    [SerializeField] private LayerMask lockOnTargetLayers; // Layers enemies are on
    [SerializeField] private float sphereCastRadius = 0.25f;
    [SerializeField] private float minCollisionPull = 0.3f; // How much to pull camera from wall

    [Header("Normal Mode Settings")]
    [SerializeField] private float normalRotationSensitivityX = 3f;
    [SerializeField] private float normalRotationSensitivityY = 2f;
    [SerializeField] private float normalModeRotationSmoothing = 15f;
    [SerializeField] private float normalDefaultDistance = 3.5f;
    [SerializeField] private float normalMinPitch = -35f;
    [SerializeField] private float normalMaxPitch = 70f;
    [SerializeField] private Vector3 normalPivotOffset = new Vector3(0, 1.65f, 0);
    [SerializeField] private float normalModeZoomSpeed = 20f;

    [Header("Lock-On Mode Settings")]
    [SerializeField] private float lockOnRotationSpeed = 10f;
    [SerializeField] private float lockOnDesiredDistance = 4.0f;
    [SerializeField] private Vector3 lockOnPivotOffset = new Vector3(0, 1.8f, 0);
    [SerializeField] private float maxLockOnSearchDistance = 25f;
    [SerializeField] private float maxLockOnSearchAngle = 60f; // Degrees from camera forward
    [SerializeField] private float lockOnLOSCheckRate = 4f; // Checks per second for Line of Sight
    [SerializeField] private float obstacleGracePeriod = 0.75f; // Seconds to maintain lock through obstacles
    [SerializeField] private float closeProximityThreshold = 2.5f; // When target is this close
    [SerializeField] private float closeProximityPullback = 1.5f; // How much to pull back/up camera
    [SerializeField] private float lockOnModeZoomSpeed = 15f;

    // Public Properties
    public bool IsLockedOn => _currentLockOnTarget != null;
    public CharacterManager CurrentLockOnTarget => _currentLockOnTarget;

    // Private State
    private Vector3 _cameraRigFollowVelocity = Vector3.zero;
    private Vector3 _pivotPositionVelocity = Vector3.zero;
    private float _targetYaw;    // Desired horizontal rotation (around player Y axis)
    private float _targetPitch;  // Desired vertical rotation (of pivot X axis)
    private float _currentYaw;
    private float _currentPitch;

    private float _rawMouseX;
    private float _rawMouseY;

    private CharacterManager _currentLockOnTarget;
    private float _timeTargetObstructed = 0f;
    private float _losCheckInterval;
    private float _losCheckTimer;
    private bool _isTargetCurrentlyConsideredObstructed; // Stores the result of the last LOS check
    private float _currentDesiredDistance; // Target distance before collision for current mode
    private Vector3 _finalCameraLocalPosition; // Target local pos for cameraActualTransform

    private List<CharacterManager> _availableTargets = new List<CharacterManager>();
    private int _currentTargetIndex = -1;

    private void Awake()
    {
        if (playerTransform == null || cameraActualTransform == null || cameraPivotTransform == null)
        {
            Debug.LogError("Camera references not set!");
            enabled = false;
            return;
        }

        // Initialize based on player's forward or current camera setup
        _targetYaw = playerTransform.eulerAngles.y;
        _currentYaw = _targetYaw;
        _targetPitch = cameraPivotTransform.localEulerAngles.x; // Use initial pitch
        if (_targetPitch > 180) _targetPitch -= 360;
        _currentPitch = _targetPitch;

        _currentDesiredDistance = normalDefaultDistance;
        _finalCameraLocalPosition = new Vector3(0, 0, -_currentDesiredDistance);
        cameraActualTransform.localPosition = _finalCameraLocalPosition;

        //Cursor.lockState = CursorLockMode.Locked;
        //Cursor.visible = false;

        // Initialize LOS check variables
        if (lockOnLOSCheckRate > 0f)
        {
            _losCheckInterval = 1.0f / lockOnLOSCheckRate;
        }
        else
        {
            _losCheckInterval = 0.25f; // Fallback to check 4 times every sec if rate is invalid
        }
        _losCheckTimer = 0f; // Start with an immediate check or check on first lock-on
        _isTargetCurrentlyConsideredObstructed = false;
    }

    private void OnEnable()
    {
        InputHandler.CameraMovementPerformed += OnCameraInput;
        InputHandler.LockOnButtonPressed += ToggleLockOn;
        InputHandler.LeftLockOnTargetButtonPressed += SwitchLockOnTargetLeft;
        InputHandler.RightLockOnTargetButtonPressed += SwitchLockOnTargetRight;
    }

    private void OnDisable()
    {
        InputHandler.CameraMovementPerformed -= OnCameraInput;
        InputHandler.LockOnButtonPressed -= ToggleLockOn;
        InputHandler.LeftLockOnTargetButtonPressed -= SwitchLockOnTargetLeft;
        InputHandler.RightLockOnTargetButtonPressed -= SwitchLockOnTargetRight;
    }

    private void LateUpdate()
    {
        float dt = Time.deltaTime;
        if (dt <= 0 || playerTransform == null) return;

        HandleModeLogic(dt);    // Determine target Yaw/Pitch/Distance/Pivot based on mode
        FollowPlayerRig(dt);    // Move the main camera rig (this.transform)
        RotateCameraRig(dt);    // Apply Yaw (horizontal) to rig, Pitch (vertical) to pivot
        HandleCollisions(dt);   // Adjust _finalCameraLocalPosition based on collisions
        ApplyCameraTransforms(dt); // Smoothly move actual camera to _finalCameraLocalPosition
    }

    private void OnCameraInput(Vector2 input)
    {
        _rawMouseX = input.x;
        _rawMouseY = input.y;
    }

    private void FollowPlayerRig(float dt)
    {
        Vector3 targetRigPosition = playerTransform.position;
        transform.position = Vector3.SmoothDamp(transform.position, targetRigPosition, ref _cameraRigFollowVelocity, generalSmoothTime, Mathf.Infinity, dt);
    }

    private void HandleModeLogic(float dt)
    {
        if (IsLockedOn)
        {
            // --- LOCK-ON MODE LOGIC ---
            if (_currentLockOnTarget == null || !_currentLockOnTarget.isActiveAndEnabled) // Target might have been destroyed
            {
                ClearLockOn(true); // Preserve orientation
                return; // Exit early as mode might have changed
            }

            _losCheckTimer -= dt;
            bool performFullLOSCheckThisFrame = _losCheckInterval <= 0f || _losCheckTimer <= 0f; // Check if interval is zero for per-frame

            if (performFullLOSCheckThisFrame)
            {
                if (_losCheckInterval > 0f) // Reset timer only if we are using timed intervals
                {
                    _losCheckTimer = _losCheckInterval;
                }

                // Check Line of Sight and grace period
                if (!IsTargetEffectivelyVisible(_currentLockOnTarget))
                {
                    // If target was previously considered visible (or this is the first check after lock-on)
                    // and now it's not, this is the *start* of an obstruction period.
                    if (!_isTargetCurrentlyConsideredObstructed)
                    {
                        _timeTargetObstructed = 0f; // Reset/Start the grace timer from this point
                    }
                    _isTargetCurrentlyConsideredObstructed = true;
                }
                else
                {
                    _isTargetCurrentlyConsideredObstructed = false;
                    _timeTargetObstructed = 0f; // Target is visible, so clear any accumulated obstruction time
                }
            }

            // Grace period handling: This runs every frame, but _timeTargetObstructed
            // only accumulates meaningfully if _isTargetCurrentlyConsideredObstructed is true.
            if (_isTargetCurrentlyConsideredObstructed)
            {
                _timeTargetObstructed += dt; // Accumulate time while considered obstructed
                if (_timeTargetObstructed >= obstacleGracePeriod)
                {
                    ClearLockOn(true); // Preserve orientation
                    return; // Exit early
                }
            }

            // Update target Yaw/Pitch to look at target
            // Calculate direction from pivot's world position to target's lock-on point
            Vector3 directionToTarget = (_currentLockOnTarget.lockOnTransform.position - cameraPivotTransform.position).normalized;
            if (directionToTarget != Vector3.zero)
            {
                Quaternion targetLookRotation = Quaternion.LookRotation(directionToTarget);
                _targetYaw = targetLookRotation.eulerAngles.y;
                _targetPitch = targetLookRotation.eulerAngles.x;
                if (_targetPitch > 180) _targetPitch -= 360f; // Normalize pitch
            }

            // Adjust camera pivot position and desired distance for lock-on
            cameraPivotTransform.localPosition = Vector3.SmoothDamp(cameraPivotTransform.localPosition, lockOnPivotOffset, ref _pivotPositionVelocity, generalSmoothTime, Mathf.Infinity, dt);

            float desiredDist = lockOnDesiredDistance;
            float distToTargetEntity = Vector3.Distance(playerTransform.position, _currentLockOnTarget.transform.position);
            if (distToTargetEntity < closeProximityThreshold)
            {
                float proximityFactor = Mathf.Clamp01(1f - (distToTargetEntity / closeProximityThreshold));
                desiredDist += closeProximityPullback * proximityFactor;
            }
            _currentDesiredDistance = Mathf.Lerp(_currentDesiredDistance, desiredDist, lockOnModeZoomSpeed * dt);
        }
        else
        {
            // --- NORMAL MODE LOGIC ---
            _targetYaw += _rawMouseX * normalRotationSensitivityX * dt * 100f;
            _targetPitch -= _rawMouseY * normalRotationSensitivityY * dt * 100f;

            _targetPitch = Mathf.Clamp(_targetPitch, normalMinPitch, normalMaxPitch);

            cameraPivotTransform.localPosition = Vector3.SmoothDamp(cameraPivotTransform.localPosition, normalPivotOffset, ref _pivotPositionVelocity, generalSmoothTime, Mathf.Infinity, dt);
            _currentDesiredDistance = Mathf.Lerp(_currentDesiredDistance, normalDefaultDistance, normalModeZoomSpeed * dt);
        }
    }

    private void RotateCameraRig(float dt)
    {
        float effectiveRotationSpeed = IsLockedOn ? lockOnRotationSpeed : normalModeRotationSmoothing; // Normal mode is input driven, lock-on is auto

        _currentYaw = Mathf.LerpAngle(_currentYaw, _targetYaw, effectiveRotationSpeed * dt);
        _currentPitch = Mathf.LerpAngle(_currentPitch, _targetPitch, effectiveRotationSpeed * dt);

        transform.rotation = Quaternion.Euler(0f, _currentYaw, 0f);
        cameraPivotTransform.localRotation = Quaternion.Euler(_currentPitch, 0f, 0f);
    }

    private void HandleCollisions(float dt)
    {
        float targetDist = _currentDesiredDistance;

        // Desired position if no collision
        Vector3 idealLocalPos = new Vector3(0, 0, -targetDist);
        Vector3 desiredWorldPos = cameraPivotTransform.TransformPoint(idealLocalPos);

        Vector3 castOrigin = cameraPivotTransform.position;
        Vector3 castDirection = (desiredWorldPos - castOrigin).normalized;
        float castDistance = Vector3.Distance(castOrigin, desiredWorldPos);

        if (castDistance < 0.01f) // Avoid issues with zero distance
        {
            _finalCameraLocalPosition = idealLocalPos;
            return;
        }

        RaycastHit hit;
        if (Physics.SphereCast(castOrigin, sphereCastRadius, castDirection, out hit, castDistance, obstructionLayers, QueryTriggerInteraction.Ignore))
        {
            // Collision detected, pull camera in
            float pullInDistance = hit.distance - minCollisionPull;
            _finalCameraLocalPosition.z = -Mathf.Max(pullInDistance, 0.1f); // Ensure it's not too close or negative due to pull
        }
        else
        {
            _finalCameraLocalPosition.z = -targetDist;
        }
    }

    private void ApplyCameraTransforms(float dt)
    {
        // Smoothly move the actual camera to its final local Z position
        // X and Y local position should remain 0 relative to the pivot.
        Vector3 targetLocalPos = new Vector3(0, _finalCameraLocalPosition.y, _finalCameraLocalPosition.z); // Keep Y if you ever want to offset it
        cameraActualTransform.localPosition = Vector3.Lerp(cameraActualTransform.localPosition, targetLocalPos, generalSmoothTime * 15f * dt); // Faster lerp for responsiveness
    }

    private void ToggleLockOn()
    {
        if (IsLockedOn)
        {
            ClearLockOn(true); // True to preserve orientation seamlessly
        }
        else
        {
            FindAndSetBestLockOnTarget();
        }
    }

    private void FindAndSetBestLockOnTarget()
    {
        CharacterManager bestTarget = FindBestTargetInView();
        if (bestTarget != null)
        {
            SetLockOn(bestTarget);
        }
    }

    private void SetLockOn(CharacterManager target)
    {
        if (_currentLockOnTarget != null)
        {
            _currentLockOnTarget.OnDeath -= HandleTargetDied;
        }

        _currentLockOnTarget = target;
        if (_currentLockOnTarget != null)
        {
            _currentLockOnTarget.OnDeath += HandleTargetDied;

            // Reset LOS and grace period state for new target
            _timeTargetObstructed = 0f;
            _losCheckTimer = 0f; // Force an LOS check in the next HandleModeLogic update
            _isTargetCurrentlyConsideredObstructed = false; // Assume visible until first check

            RefreshAvailableTargets();
            _currentTargetIndex = _availableTargets.IndexOf(_currentLockOnTarget);
        }
    }

    private void ClearLockOn(bool preserveOrientation)
    {
        if (_currentLockOnTarget != null)
        {
            _currentLockOnTarget.OnDeath -= HandleTargetDied;
        }
        _currentLockOnTarget = null;
        _timeTargetObstructed = 0f;
        _currentTargetIndex = -1;
        _availableTargets.Clear();

        if (preserveOrientation)
        {
            // This is CRITICAL for seamless transition:
            // Set normal mode's target yaw/pitch to current camera's actual orientation.
            _targetYaw = transform.eulerAngles.y; // Rig's current world Y rotation
            _targetPitch = cameraPivotTransform.localEulerAngles.x; // Pivot's current local X rotation
            if (_targetPitch > 180) _targetPitch -= 360f; // Normalize

            // _currentYaw and _currentPitch will smoothly lerp towards these
            // but since they are already AT these values (or very close), it's seamless.
        }
        // PlayerLocomotion will pick up IsLockedOn being false and revert to normal movement.
    }

    private void HandleTargetDied()
    {
        // Target died, try to find a new one automatically or clear lock-on
        // For now, just clear it. Could implement auto-switch later.
        ClearLockOn(true); // Preserve orientation
    }

    private bool IsTargetEffectivelyVisible(CharacterManager target)
    {
        if (target == null || target.lockOnTransform == null) return false;

        Vector3 viewOrigin = cameraActualTransform.position; // Or cameraPivotTransform.position
        Vector3 targetPoint = target.lockOnTransform.position;
        Vector3 directionToTarget = targetPoint - viewOrigin;

        // Distance check (more generous than search distance as target is already locked)
        if (directionToTarget.magnitude > maxLockOnSearchDistance * 1.5f)
        {
            return false;
        }

        RaycastHit hit;
        // Linecast from camera to target. If it hits something that isn't the target, it's obstructed.
        if (Physics.Linecast(viewOrigin, targetPoint, out hit, obstructionLayers, QueryTriggerInteraction.Ignore))
        {
            if (hit.transform.root != target.transform.root) // Check root in case target has complex hierarchy
            {
                return false; // Obstructed by something else
            }
        }
        return true;
    }

    private void RefreshAvailableTargets()
    {
        _availableTargets.Clear();
        Collider[] colliders = Physics.OverlapSphere(playerTransform.position, maxLockOnSearchDistance, lockOnTargetLayers);

        Vector3 cameraViewForward = cameraActualTransform.forward; // Use actual camera's forward

        foreach (var col in colliders)
        {
            CharacterManager potentialTarget = col.GetComponent<CharacterManager>();
            if (potentialTarget == null || !potentialTarget.lockOnTransform || potentialTarget == playerTransform.GetComponent<CharacterManager>() || !potentialTarget.isActiveAndEnabled)
                continue;

            Vector3 directionToTarget = potentialTarget.lockOnTransform.position - cameraActualTransform.position;
            float angle = Vector3.Angle(cameraViewForward, directionToTarget.normalized);

            if (angle <= maxLockOnSearchAngle && IsTargetEffectivelyVisible(potentialTarget))
            {
                _availableTargets.Add(potentialTarget);
            }
        }

        // Sort by angle primarily, then distance
        _availableTargets = _availableTargets.OrderBy(t => Vector3.Angle(cameraViewForward, (t.lockOnTransform.position - cameraActualTransform.position).normalized))
                                           .ThenBy(t => Vector3.Distance(playerTransform.position, t.transform.position))
                                           .ToList();
    }


    private CharacterManager FindBestTargetInView()
    {
        RefreshAvailableTargets();
        return _availableTargets.FirstOrDefault(); // The first one after sorting is the "best"
    }

    private void SwitchLockOnTarget(int direction) // -1 for left, 1 for right
    {
        if (!IsLockedOn || _availableTargets.Count <= 1) return;

        RefreshAvailableTargets(); // Ensure list is up-to-date
        if (_availableTargets.Count <= 1) return; // Still not enough

        _currentTargetIndex = _availableTargets.IndexOf(_currentLockOnTarget);
        if (_currentTargetIndex == -1) // Current target not in list (e.g. died, out of range)
        {
            FindAndSetBestLockOnTarget();
            return;
        }

        // Screen-space based switching is more intuitive for "left/right"
        // Convert target positions to screen space relative to current target
        Vector3 currentTargetScreenPos = Camera.main.WorldToScreenPoint(_currentLockOnTarget.lockOnTransform.position);

        CharacterManager bestCandidate = null;
        float bestScore = (direction == 1) ? float.MaxValue : float.MinValue; // Right: Min X greater than current. Left: Max X less than current.

        foreach (var target in _availableTargets)
        {
            if (target == _currentLockOnTarget) continue;

            Vector3 candidateScreenPos = Camera.main.WorldToScreenPoint(target.lockOnTransform.position);
            float xDelta = candidateScreenPos.x - currentTargetScreenPos.x;

            if (direction == 1) // Right
            {
                if (xDelta > 0 && xDelta < bestScore) // Find smallest positive X delta
                {
                    bestScore = xDelta;
                    bestCandidate = target;
                }
            }
            else // Left (direction == -1)
            {
                if (xDelta < 0 && xDelta > bestScore) // Find largest (closest to zero) negative X delta
                {
                    bestScore = xDelta;
                    bestCandidate = target;
                }
            }
        }

        if (bestCandidate != null)
        {
            SetLockOn(bestCandidate);
        }
        else // If no target strictly to the left/right, wrap around (optional)
        {
            // Simplistic wrap: go to next/prev in sorted list
            _currentTargetIndex = (_currentTargetIndex + direction + _availableTargets.Count) % _availableTargets.Count;
            SetLockOn(_availableTargets[_currentTargetIndex]);
        }
    }


    private void SwitchLockOnTargetLeft()
    {
        if (IsLockedOn) SwitchLockOnTarget(-1);
    }

    private void SwitchLockOnTargetRight()
    {
        if (IsLockedOn) SwitchLockOnTarget(1);
    }


    // Gizmos for debugging
    private void OnDrawGizmosSelected()
    {
        if (cameraPivotTransform == null || cameraActualTransform == null) return;

        // Draw collision sphere
        Gizmos.color = Color.yellow;
        Vector3 desiredWorldPos = cameraPivotTransform.TransformPoint(new Vector3(0, 0, -_currentDesiredDistance));
        Vector3 castOrigin = cameraPivotTransform.position;
        Vector3 castDirection = (desiredWorldPos - castOrigin).normalized;
        float castDistance = Vector3.Distance(castOrigin, desiredWorldPos);
        Gizmos.DrawWireSphere(castOrigin + castDirection * castDistance, sphereCastRadius);

        // Draw line to current lock on target
        if (IsLockedOn && _currentLockOnTarget != null && _currentLockOnTarget.lockOnTransform != null)
        {
            Gizmos.color = Color.red;
            Gizmos.DrawLine(cameraActualTransform.position, _currentLockOnTarget.lockOnTransform.position);
        }

        // Draw Lock-on search cone (approximate)
        Gizmos.color = new Color(0, 1, 1, 0.25f);
        Gizmos.matrix = Matrix4x4.TRS(cameraActualTransform.position, cameraActualTransform.rotation, Vector3.one);
        Gizmos.DrawFrustum(Vector3.zero, maxLockOnSearchAngle * 2f, maxLockOnSearchDistance, 0.1f, 1f);
    }
}


--- END FILE: Camera\CameraController.cs ---

--- START FILE: Characters\AnimatorManager.cs ---

using System.Runtime.CompilerServices;
using UnityEngine;

public class AnimatorManager : MonoBehaviour
{
    public Animator anim;

    public bool IsInMidAction
    {
        get => GetAnimatorBool();
        set => SetAnimatorBool(value);
    }

    public bool IsInvulnerable
    {
        get => GetAnimatorBool();
        set => SetAnimatorBool(value);
    }

    protected bool GetAnimatorBool([CallerMemberName] string name = "") => anim.GetBool(name);
    protected void SetAnimatorBool(bool value, [CallerMemberName] string name = "") => anim.SetBool(name, value);

    protected int GetAnimatorInt([CallerMemberName] string name = "") => anim.GetInteger(name);
    protected void SetAnimatorInt(int value, [CallerMemberName] string name = "") => anim.SetInteger(name, value);

    public void PlayTargetAnimation(string targetAnim, bool isInMidAction)
    {
        anim.applyRootMotion = isInMidAction;
        IsInMidAction = isInMidAction;
        anim.CrossFade(targetAnim, 0.1f);
    }

    public void ApplyRootMotion(bool rootMotion)
    {
        anim.applyRootMotion = rootMotion;
    }
}


--- END FILE: Characters\AnimatorManager.cs ---

--- START FILE: Characters\CharacterManager.cs ---

using System;
using System.Runtime.CompilerServices;
using UnityEngine;

public class CharacterManager : MonoBehaviour
{
    public event Action OnDeath;

    [Header("Lock On Transform")]
    public Transform lockOnTransform;

    [Header("Interaction Flags")]
    public bool isBeingCriticallyHit;
    
    [Header("Backstab Settings")]
    public Transform backstabReceiverPoint; // A child empty GameObject on the character model where the attacker snaps TO
    public string beingBackstabbedAnimation = "Enemy_Backstab_Main_Victim_01";
    public bool canBeBackstabbed = true;

    protected Animator charAnimator;
    public AnimatorManager charAnimManager;

    protected virtual void Awake()
    {
        charAnimator = GetComponentInChildren<Animator>();
        charAnimManager = GetComponentInChildren<AnimatorManager>();

        if (backstabReceiverPoint == null)
        {
            // Try to find a child named "BackstabReceiverPoint"
            var foundPoint = transform.Find("BackstabReceiverPoint");
            if (foundPoint != null)
            {
                backstabReceiverPoint = foundPoint;
            }
            else
            {
                // Or log a warning if it's critical and should be manually set
                Debug.LogWarning($"BackstabReceiverPoint not set for {gameObject.name}, backstabs might not align perfectly.");
            }
        }
    }

    public virtual void GetBackstabbed(Transform attacker)
    {
        if (!canBeBackstabbed || charAnimManager.IsInvulnerable || charAnimManager.IsInMidAction) return;

        Debug.Log($"{gameObject.name} is being backstabbed by {attacker.name}");
        charAnimManager.IsInMidAction = true;
        charAnimManager.IsInvulnerable = true;
        isBeingCriticallyHit = true;
        canBeBackstabbed = false; // Cannot be backstabbed again while being backstabbed

        // Orient this character to face away from the attacker
        Vector3 directionFromAttacker = transform.position - attacker.position;
        directionFromAttacker.y = 0; // Keep upright
        directionFromAttacker.Normalize();

        if (directionFromAttacker != Vector3.zero)
        {
            transform.rotation = Quaternion.LookRotation(directionFromAttacker);
        }

        if (charAnimManager != null)
        {
            charAnimManager.PlayTargetAnimation(beingBackstabbedAnimation, true);
        }
        else if (charAnimator != null) // Fallback if no specific manager
        {
            charAnimator.CrossFade(beingBackstabbedAnimation, 0.1f);
            charAnimManager.IsInMidAction = true;
        }
        else
        {
            Debug.LogError($"CharacterManager: Animator or AnimatorManager not found for {gameObject.name} to play {beingBackstabbedAnimation}!", this);
        }
    }

    // This method would be called by an Animation Event at the end of the "Being_Backstabbed" animation
    public virtual void FinishBeingBackstabbed()
    {
        charAnimManager.IsInMidAction = false;
        charAnimManager.IsInvulnerable = false;
        canBeBackstabbed = true;
        isBeingCriticallyHit = false;
        Debug.Log($"{gameObject.name} finished being backstabbed.");
    }

    // Death event used to clear the lock on
    protected void RaiseDeath()
    {
        OnDeath?.Invoke();
    }
}


--- END FILE: Characters\CharacterManager.cs ---

--- START FILE: Characters\CharacterStats.cs ---

using UnityEngine;

public class CharacterStats : MonoBehaviour
{
    public int characterLevel = 1;

    [Header("Health Stats")]
    public int maxHealth;
    public int currentHealth;

    [Header("Stamina Stats")]
    public float maxStamina;
    public float currentStamina;

    [Header("Combat Stats")]
    public int baseAttackPower = 10;
    public int baseDefense = 2;

    public bool isDead = false;
}


--- END FILE: Characters\CharacterStats.cs ---

--- START FILE: Characters\Enemy\EnemyAnimator.cs ---

using UnityEngine;
using UnityEngine.AI;
using UnityEngine.XR;

public class EnemyAnimator : AnimatorManager // Assuming AnimatorManager exists
{
    private EnemyManager enemyManager;
    private EnemyLocomotion enemyLocomotion;
    private EnemyCombat enemyCombat;

    // Animator Hashes
    public readonly int hashVertical = Animator.StringToHash("Vertical");
    public readonly int hashHorizontal = Animator.StringToHash("Horizontal");
    // Add other common hashes like "IsInteracting", "IsDead"

    public void Initialize(EnemyManager manager)
    {
        enemyManager = manager;
        enemyLocomotion = manager.Locomotion;
        enemyCombat = manager.Combat;
        anim = GetComponent<Animator>(); // Make sure this is set
        if (anim == null) Debug.LogError("Animator not found on EnemyAnimator's GameObject or children.", this);
    }

    public void PlayTargetAnimation(string animationName, bool isInMidAction, float transitionDuration = 0.1f)
    {
        if (anim == null) return;

        IsInMidAction = isInMidAction;
        anim.applyRootMotion = isInMidAction; // Typically true for actions, false for locomotion blends
        anim.CrossFade(animationName, transitionDuration);
    }

    public void SetBool(string paramName, bool value)
    {
        if (anim == null) return;
        anim.SetBool(paramName, value);
    }

    public void SetFloat(string paramName, float value, float dampTime = 0.1f, float deltaTime = -1f)
    {
        if (anim == null) return;
        if (deltaTime < 0) deltaTime = Time.deltaTime;
        anim.SetFloat(paramName, value, dampTime, deltaTime);
    }

    public void SetFloat(int paramID, float value, float dampTime = 0.1f, float deltaTime = -1f) // Overload for hash IDs
    {
        if (anim == null) return;
        if (deltaTime < 0) deltaTime = Time.deltaTime;
        anim.SetFloat(paramID, value, dampTime, deltaTime);
    }

    public void SetMovementValues(float verticalSpeed, float horizontalSpeed)
    {
        if (anim == null) return;
        anim.SetFloat(hashVertical, verticalSpeed, 0.1f, Time.deltaTime);
        anim.SetFloat(hashHorizontal, horizontalSpeed, 0.1f, Time.deltaTime);
    }

    public void SetTrigger(string paramName)
    {
        if (anim == null) return;
        anim.SetTrigger(paramName);
    }

    // OnAnimatorMove is called on the GameObject with the Animator component
    // This script should be on that same GameObject or a child that can get it.
    private void OnAnimatorMove()
    {
        if (enemyLocomotion == null || !anim.applyRootMotion || Time.deltaTime <= 0) return;

        // Only apply root motion if the locomotion system is prepared for it
        // (e.g., RB is non-kinematic, NavAgent is off or overridden by current state)
        // Or if in a critical action where animation fully dictates movement
        if ((AgentIsNull() || !enemyLocomotion.GetComponent<NavMeshAgent>().enabled && !enemyLocomotion.GetComponent<Rigidbody>().isKinematic) ||
            enemyManager.IsPerformingCriticalAction || enemyManager.IsReceivingCriticalHit)
        {
            enemyLocomotion.ApplyRootMotion(anim.deltaPosition, anim.deltaRotation);
        }
    }

    private bool AgentIsNull() => enemyLocomotion.GetComponent<NavMeshAgent>() == null;

    // --- Animation Event Handlers ---
    // These are called by name from Animation Events in animation clips

    public void AnimEvent_EnableDamageCollider()
    {
        enemyManager.EnemyWeaponSlotManager?.OpenDamageCollider(WeaponHand.Right);
    }

    public void AnimEvent_DisableDamageCollider()
    {
        enemyManager.EnemyWeaponSlotManager?.CloseDamageCollider(WeaponHand.Right);
    }

    public void AnimEvent_AttackLanded()
    {
        // TODO: Play SFX, VFX for attack impact
    }

    public void AnimEvent_ApplyBackstabDamageToVictim() // When enemy is ATTACKER
    {
        enemyCombat?.ApplyBackstabDamageOnVictim();
    }

    public void AnimEvent_FinishPerformingCriticalAction() // When enemy is ATTACKER
    {
        // This signals the end of the enemy's attacking critical animation (e.g., backstab)
        enemyManager?.Notify_FinishedPerformingCriticalAction();
    }

    public void AnimEvent_FinishBeingCriticallyHit() // When enemy is VICTIM
    {
        // This signals the end of the enemy's victim critical animation (e.g., being backstabbed)
        enemyManager?.Notify_FinishedBeingCriticallyHit();
    }

    public void AnimEvent_EnableInvulnerability()
    {
        if (enemyManager != null) IsInvulnerable = true;
    }

    public void AnimEvent_DisableInvulnerability()
    {
        if (enemyManager != null) IsInvulnerable = false;
    }

    public void AnimEvent_CanCombo() // If enemies have combos
    {
        // enemyCombat?.SetCanCombo(true);
    }

    public void AnimEvent_CannotCombo()
    {
        // enemyCombat?.SetCanCombo(false);
    }

    public void AnimEvent_Footstep()
    {
        // TODO: Play footstep sound
    }

    public void AnimEvent_AttackActionConcluded() // NEW Animation Event Handler
    {
        enemyManager?.Notify_AttackActionConcluded();
    }

    public void AnimEvent_FinishAction()
    {
        IsInMidAction = false;
    }
}


--- END FILE: Characters\Enemy\EnemyAnimator.cs ---

--- START FILE: Characters\Enemy\EnemyCombat.cs ---

using System.Collections.Generic;
using System.Linq;
using UnityEngine;

public class EnemyCombat : MonoBehaviour
{
    private EnemyManager enemyManager;

    [Header("Actions")]
    public List<EnemyAttackActionSO> attackActions = new List<EnemyAttackActionSO>();
    public EnemyBackstabActionSO backstabAction;

    private Dictionary<EnemyAttackActionSO, float> specificAttackCooldowns = new();

    [Header("Combat Settings")]
    public float minAttackCooldown = 1.0f;
    public float maxAttackCooldown = 3.0f;
    private float currentAttackCooldownTimer;
    public bool IsAttackOnCooldown => currentAttackCooldownTimer > 0;

    [Header("Backstab Settings")]
    public float backstabCheckMaxDistance = 1.5f; // How close enemy needs to be to player's back
    public float backstabCheckMaxAngle = 45f;   // Angle behind player
    public float chanceToAttemptBackstab = 0.3f; // If opportunity arises

    public CharacterManager CurrentBackstabVictim { get; private set; }

    public void Initialize(EnemyManager manager)
    {
        enemyManager = manager;
    }

    public void TickCombat()
    {
        if (currentAttackCooldownTimer > 0)
        {
            currentAttackCooldownTimer -= Time.deltaTime;
        }
    }

    public EnemyAttackActionSO GetAvailableAttack(CharacterManager target)
    {
        if (target == null || attackActions.Count == 0 || IsAttackOnCooldown) // General combat cooldown check
        {
            return null;
        }

        Vector3 directionToTarget = target.transform.position - transform.position;
        float distanceToTarget = directionToTarget.magnitude;
        float angleToTarget = Vector3.Angle(transform.forward, directionToTarget.normalized);

        List<(EnemyAttackActionSO action, int score)> scoredValidAttacks = new List<(EnemyAttackActionSO, int)>();
        int totalScore = 0;

        foreach (var attack in attackActions)
        {
            // Check specific attack cooldown
            if (specificAttackCooldowns.TryGetValue(attack, out float cooldownEndTime) && Time.time < cooldownEndTime)
            {
                continue; // This specific attack is on cooldown
            }

            if (attack.IsBasicConditionsMet(distanceToTarget, angleToTarget))
            {
                int score = attack.CalculateScore(enemyManager, target, distanceToTarget, angleToTarget);
                if (score > 0)
                {
                    scoredValidAttacks.Add((attack, score));
                    totalScore += score;
                }
            }
        }

        if (scoredValidAttacks.Count == 0 || totalScore == 0)
        {
            return null; // No valid or scorable attacks
        }

        // Weighted random selection
        int randomPoint = Random.Range(0, totalScore);
        int currentSum = 0;
        foreach (var (action, score) in scoredValidAttacks)
        {
            currentSum += score;
            if (randomPoint < currentSum)
            {
                return action; // This is the chosen attack
            }
        }

        // Fallback (should ideally not be reached if totalScore > 0 and list is not empty)
        return scoredValidAttacks.Count > 0 ? scoredValidAttacks[Random.Range(0, scoredValidAttacks.Count)].action : null;
    }

    public void NotifyAttackActionStarted(EnemyAttackActionSO action)
    {
        // Set the general shared cooldown
        enemyManager.Combat.SetGeneralAttackCooldown(action.recoveryTime);

        // Set specific attack cooldown if it has one
        if (action.specificAttackCooldown > 0)
        {
            specificAttackCooldowns[action] = Time.time + action.specificAttackCooldown;
        }
    }

    public bool CanAttemptBackstab(CharacterManager target)
    {
        if (backstabAction == null || target == null || !(target is PlayerManager)) return false;

        PlayerManager playerTarget = target as PlayerManager;
        if (playerTarget.charAnimManager.IsInMidAction || playerTarget.playerAnimator.IsInvulnerable) return false;

        // Check position: Enemy behind player?
        Vector3 directionFromPlayerToEnemy = (transform.position - playerTarget.transform.position).normalized;
        directionFromPlayerToEnemy.y = 0; // Horizontal plane

        // Angle relative to player's back
        float angle = Vector3.Angle(-playerTarget.transform.forward, directionFromPlayerToEnemy);

        if (angle <= backstabCheckMaxAngle)
        {
            // Check distance to player's backstab receiver point
            if (playerTarget.backstabReceiverPoint == null)
            {
                Debug.LogWarning($"Player {playerTarget.name} missing backstabReceiverPoint for {enemyManager.name} to target.");
                return false;
            }
            float distance = Vector3.Distance(transform.position, playerTarget.backstabReceiverPoint.position);
            if (distance <= backstabCheckMaxDistance)
            {
                return true;
            }
        }
        return false;
    }

    public bool CanInitiateBackstabSequence(PlayerManager playerTarget)
    {
        if (backstabAction == null || playerTarget == null) return false;
        if (playerTarget.backstabReceiverPoint == null)
        {
            Debug.LogWarning($"Player {playerTarget.name} has no backstabReceiverPoint. Cannot initiate backstab.");
            return false;
        }
        return true;
    }

    public void InitiateBackstabSequence(PlayerManager playerTarget)
    {
        if (!CanInitiateBackstabSequence(playerTarget))
        {
            CurrentBackstabVictim = null; // Ensure it's cleared if pre-check fails
            return;
        }

        CurrentBackstabVictim = playerTarget;
        Debug.Log($"{enemyManager.name} is initiating backstab sequence on {playerTarget.name}. PerformingBackstabState will execute.");
    }

    public void ApplyBackstabDamageOnVictim() // Called by EnemyAnimator AnimEvent
    {
        if (CurrentBackstabVictim != null && backstabAction != null)
        {
            Debug.Log($"{enemyManager.name} applying {backstabAction.backstabDamage} backstab damage to {CurrentBackstabVictim.name}");
            PlayerStats victimStats = CurrentBackstabVictim.GetComponent<PlayerStats>();
            victimStats?.TakeDamange(backstabAction.backstabDamage);
            // For new EnemyStats: victimStats?.TakeDamage(backstabAction.backstabDamage, DamageType.BackstabCritical, enemyManager.transform);
        }
    }

    public void ProcessHit(Collider victimCollider, WeaponItem attackingWeapon)
    {
        if (victimCollider.CompareTag("Player"))
        {
            PlayerStats playerStats = victimCollider.GetComponent<PlayerStats>();
            if (playerStats != null && !playerStats.isDead)
            {
                EnemyAttackActionSO currentAction = enemyManager.attackingState.GetCurrentAttackAction();
                if (currentAction != null)
                {
                    playerStats.TakeDamange(currentAction.damage, enemyManager.transform);
                }
                else if (attackingWeapon != null)
                {
                    playerStats.TakeDamange(attackingWeapon.lightAttackDmg, enemyManager.transform);
                }
            }
        }
    }

    public void ResetCooldown()
    {
        currentAttackCooldownTimer = Random.Range(minAttackCooldown, maxAttackCooldown);
    }

    public void SetGeneralAttackCooldown(float duration)
    {
        currentAttackCooldownTimer = duration;
    }

    public void ClearBackstabVictim()
    {
        CurrentBackstabVictim = null;
    }
}


--- END FILE: Characters\Enemy\EnemyCombat.cs ---

--- START FILE: Characters\Enemy\EnemyLocomotion.cs ---

using UnityEngine;
using UnityEngine.AI;

[RequireComponent(typeof(NavMeshAgent), typeof(Rigidbody))]
public class EnemyLocomotion : MonoBehaviour
{
    private EnemyManager enemyManager;
    private NavMeshAgent agent;
    private Rigidbody rb;
    private EnemyAnimator enemyAnimator; // Renamed from AnimatorManager

    [Header("Movement Settings")]
    public float baseSpeed = 3f;
    public float chaseSpeed = 3.5f;
    public float rotationSpeed = 10f;
    public float stoppingDistance = 1.5f; // Agent's stopping distance

    public bool IsMoving => agent.enabled && agent.velocity.sqrMagnitude > 0.01f;
    public bool HasReachedDestination => agent.enabled && !agent.pathPending && agent.remainingDistance <= agent.stoppingDistance;


    public void Initialize(EnemyManager manager)
    {
        enemyManager = manager;
        agent = GetComponent<NavMeshAgent>();
        rb = GetComponent<Rigidbody>();
        enemyAnimator = manager.EnemyAnimator; // Get from manager

        agent.stoppingDistance = stoppingDistance;
        agent.speed = baseSpeed;
        DisableAgentAndPhysicsControl(); // Start in a controlled state
    }

    public void EnableAgentNavigation()
    {
        rb.isKinematic = true; // Agent controls movement
        agent.enabled = true;
        agent.updatePosition = true;
        agent.updateRotation = true; // Let agent handle rotation initially
    }

    public void DisableAgentNavigation(bool makeNonKinematic = true)
    {
        if (agent.enabled)
        {
            if (agent.isOnNavMesh) agent.ResetPath();
            agent.velocity = Vector3.zero;
        }
        agent.enabled = false;
        if (makeNonKinematic) rb.isKinematic = false; // Allow physics/root motion
    }

    public void DisableAgentAndPhysicsControl()
    {
        DisableAgentNavigation(false); // Don't make non-kinematic yet
        rb.velocity = Vector3.zero;
        rb.angularVelocity = Vector3.zero;
        rb.isKinematic = true; // Full animation control or snapping
    }

    public void EnableCharacterControllerPhysics() // For being pushed, ragdoll prep
    {
        DisableAgentNavigation(true); // Make non-kinematic
    }

    public void MoveToPoint(Vector3 destination)
    {
        if (agent.enabled && agent.isOnNavMesh)
        {
            agent.SetDestination(destination);
        }
    }

    public void FollowTarget(Transform target)
    {
        if (agent.enabled && agent.isOnNavMesh && target != null)
        {
            agent.SetDestination(target.position);
        }
    }

    public void StopMovement()
    {
        if (agent.enabled && agent.isOnNavMesh)
        {
            agent.ResetPath();
            agent.velocity = Vector3.zero; // Explicitly stop
        }
        //rb.velocity = Vector3.zero; // Stop Rigidbody too if it was moving
    }

    public void RotateTowards(Vector3 targetPosition, float customRotationSpeed = -1f)
    {
        if (enemyManager.IsReceivingCriticalHit || enemyManager.IsPerformingCriticalAction) return; // No manual rotation during criticals

        Vector3 direction = (targetPosition - transform.position).normalized;
        direction.y = 0; // Keep rotation horizontal

        if (direction == Vector3.zero) return;

        Quaternion targetRotation = Quaternion.LookRotation(direction);
        float speed = (customRotationSpeed > 0) ? customRotationSpeed : rotationSpeed;
        transform.rotation = Quaternion.Slerp(transform.rotation, targetRotation, speed * Time.deltaTime);
    }

    public void FaceTargetInstantly(Transform target)
    {
        if (target == null) return;
        Vector3 direction = (target.position - transform.position).normalized;
        direction.y = 0;
        if (direction != Vector3.zero)
        {
            transform.rotation = Quaternion.LookRotation(direction);
        }
    }

    public void ApplyRootMotion(Vector3 deltaPosition, Quaternion deltaRotation)
    {
        // This is called from EnemyAnimator.OnAnimatorMove
        // Assumes RB is non-kinematic and Agent is disabled OR current state allows root motion override
        if (!rb.isKinematic && Time.deltaTime > 0)
        {
            // Position
            // If you want to preserve Y velocity (gravity):
            // Vector3 newVelocity = deltaPosition / Time.deltaTime;
            // newVelocity.y = rb.velocity.y;
            // rb.velocity = newVelocity;
            // OR:
            rb.MovePosition(rb.position + deltaPosition);

            // Rotation
            rb.MoveRotation(rb.rotation * deltaRotation);
        }
        else if (rb.isKinematic) // e.g. during critical hit victim animation
        {
            transform.position += deltaPosition;
            transform.rotation *= deltaRotation;
        }
    }

    public void UpdateAnimatorMovementParameters()
    {
        if (enemyAnimator == null) return;

        float verticalSpeed = 0f;
        float horizontalSpeed = 0f;

        if (agent.enabled && agent.isOnNavMesh && agent.desiredVelocity.sqrMagnitude > 0.01f)
        {
            // Get the desired velocity of the agent (this is what it *wants* to do)
            Vector3 worldDesiredVelocity = agent.desiredVelocity;

            // Transform this world velocity into the enemy's local space
            // This gives us how much it wants to move forward/backward (local Z)
            // and left/right (local X) relative to its current orientation.
            Vector3 localDesiredVelocity = transform.InverseTransformDirection(worldDesiredVelocity);

            // Normalize these local values to be typically between -1 and 1
            // The agent.speed is its current maximum speed.
            verticalSpeed = localDesiredVelocity.z / agent.speed;
            horizontalSpeed = localDesiredVelocity.x / agent.speed;

            // Clamp them to ensure they are within the expected animator range
            // If your blend tree's max for run is 1 and sprint is 2:
            float maxAnimatorSpeed = 1.0f;

            verticalSpeed = Mathf.Clamp(verticalSpeed, -maxAnimatorSpeed, maxAnimatorSpeed);
            horizontalSpeed = Mathf.Clamp(horizontalSpeed, -maxAnimatorSpeed, maxAnimatorSpeed);
        }
        // If the agent is disabled, or not moving, speeds should be 0.
        enemyAnimator.SetMovementValues(verticalSpeed, horizontalSpeed);
    }

    public void SetAgentSpeed(float speed)
    {
        if (agent.enabled) agent.speed = speed;
    }
}


--- END FILE: Characters\Enemy\EnemyLocomotion.cs ---

--- START FILE: Characters\Enemy\EnemyManager.cs ---

using UnityEngine;

public class EnemyManager : CharacterManager
{
    // AI Core Components
    public EnemyStats Stats { get; private set; }
    public EnemyLocomotion Locomotion { get; private set; }
    public EnemyAnimator EnemyAnimator { get; private set; }
    public EnemyCombat Combat { get; private set; }
    public EnemySenses Senses { get; private set; }

    // State Machine
    public IEnemyState CurrentState { get; private set; }
    public IdleState idleState;
    public PatrolState patrolState;
    public ChaseState chaseState;
    public CombatStanceState combatStanceState;
    public AttackingState attackingState;
    public PerformingBackstabState performingBackstabState; // Attacker
    public BeingBackstabbedState beingBackstabbedState;   // Victim
    public HitReactionState hitReactionState;
    public ReturnToPostState returnToPostState;
    public RepositionState repositionState;
    public DeadState deadState;
    // TODO: Add more states: InvestigateState, PoiseBreakState

    public EnemyWeaponSlotManager EnemyWeaponSlotManager { get; private set; }

    public CharacterManager CurrentTarget { get; set; } // Who the AI is focused on
    public PatrolRoute patrolRoute;
    [HideInInspector] public Vector3 initialPosition;
    [HideInInspector] public Quaternion initialRotation;

    [Header("AI Behavior Settings")]
    public bool canRepositionWhileOnCooldown = true;
    public float defaultStoppingDistance = 1.5f;
    public bool isInvincibleDuringStun = false;
    public float hitStunDuration = 0.1f;

    [Header("UI")]
    [SerializeField] private GameObject healthBarPrefab;
    [SerializeField] private Transform healthBarAttachPoint;
    private EnemyHealthBarUI healthBarUI;

    public bool IsPerformingCriticalAction => CurrentState is PerformingBackstabState;
    public bool IsReceivingCriticalHit => CurrentState is BeingBackstabbedState;

    public bool HasAttackActionConcluded { get; set; }


    protected override void Awake()
    {
        base.Awake(); // From your CharacterManager

        Stats = GetComponent<EnemyStats>();
        Locomotion = GetComponent<EnemyLocomotion>();
        EnemyAnimator = GetComponentInChildren<EnemyAnimator>();
        Combat = GetComponent<EnemyCombat>();
        Senses = GetComponent<EnemySenses>();

        if (Stats == null) Debug.LogError("EnemyStats not found!", this);
        if (Locomotion == null) Debug.LogError("EnemyLocomotion not found!", this);
        if (EnemyAnimator == null) Debug.LogError("EnemyAnimator not found or not assigned!", this);
        if (Combat == null) Debug.LogError("EnemyCombat not found!", this);
        if (Senses == null) Debug.LogError("EnemySenses not found!", this);

        EnemyWeaponSlotManager = GetComponentInChildren<EnemyWeaponSlotManager>();
        if (EnemyWeaponSlotManager == null) Debug.LogWarning($"{name} is missing an EnemyWeaponSlotManager component in children.");

        // Initialize components
        //Stats.Initialize(this);
        Locomotion.Initialize(this);
        EnemyAnimator.Initialize(this);
        Combat.Initialize(this);
        Senses.Initialize(this);

        // Create state instances
        idleState = new IdleState();
        patrolState = new PatrolState();
        chaseState = new ChaseState();
        combatStanceState = new CombatStanceState();
        attackingState = new AttackingState();
        performingBackstabState = new PerformingBackstabState();
        beingBackstabbedState = new BeingBackstabbedState();
        hitReactionState = new HitReactionState(isInvincibleDuringStun, hitStunDuration);
        returnToPostState = new ReturnToPostState();
        repositionState = new RepositionState();
        deadState = new DeadState();
    }

    private void Start()
    {
        // Capture initial position and rotation
        initialPosition = transform.position;
        initialRotation = transform.rotation;

        if (healthBarPrefab != null)
        {
            GameObject healthBarInstance = Instantiate(healthBarPrefab, healthBarAttachPoint);
            healthBarUI = healthBarInstance.GetComponent<EnemyHealthBarUI>();
            // Initialize the UI with the stats component, passing the reference
            healthBarUI.Initialize(Stats);
        }
        else Debug.LogWarning($"Enemy {name} is missing a Health Bar Prefab.");

        // Subscribe to events
        Stats.OnDamagedEvent += HandleDamageTaken;
        Stats.OnDeathEvent += HandleDeath;
        Senses.OnTargetSpotted += HandleTargetSpotted;
        Senses.OnTargetLost += HandleTargetLost;

        // Set initial state
        if (patrolRoute != null && patrolRoute.patrolPoints.Count > 0)
        {
            SwitchState(patrolState);
        }
        else
        {
            SwitchState(idleState);
        }
    }

    private void Update()
    {
        CurrentState?.Tick();
        Combat.TickCombat();
        HandleStateTransitions();
        Locomotion.UpdateAnimatorMovementParameters(); // Update animator based on locomotion state
    }

    private void FixedUpdate()
    {
        CurrentState?.FixedTick();
    }

    private void OnDestroy()
    {
        // Unsubscribe
        if (Stats != null)
        {
            Stats.OnDamagedEvent -= HandleDamageTaken;
            Stats.OnDeathEvent -= HandleDeath;
        }
        if (Senses != null)
        {
            Senses.OnTargetSpotted -= HandleTargetSpotted;
            Senses.OnTargetLost -= HandleTargetLost;
        }
    }

    private void FindAndAssignAttachPoint()
    {
        healthBarAttachPoint = transform.Find("HealthBarAttachPoint");
        if (healthBarAttachPoint == null)
        {
            // Create one dynamically if it doesn't exist
            GameObject attachPointGO = new GameObject("HealthBarAttachPoint");
            attachPointGO.transform.SetParent(transform);
            // Position it above the character's head.
            float height = GetComponent<CapsuleCollider>()?.height ?? 2.0f;
            attachPointGO.transform.localPosition = new Vector3(0, height + 0.5f, 0);
            healthBarAttachPoint = attachPointGO.transform;
        }
    }

    public void SwitchState(IEnemyState newState)
    {
        if (CurrentState == deadState && newState != deadState) return; // Cannot leave dead state except for cleanup

        CurrentState?.Exit();
        CurrentState = newState;

        HasAttackActionConcluded = false;

        if (healthBarUI != null)
        {
            // Show health bar if in combat-related states, hide otherwise
            bool shouldBeVisible = (newState is ChaseState || newState is CombatStanceState ||
                                    newState is AttackingState || newState is RepositionState);
            healthBarUI.SetVisibility(shouldBeVisible);
        }

        Debug.Log($"{name} transitioning to {newState.GetType().Name}");
        CurrentState.Enter(this);
    }

    private void HandleStateTransitions()
    {
        if (CurrentState == null) return;
        IEnemyState nextState = CurrentState.Transition();
        if (nextState != null)
        {
            SwitchState(nextState);
        }
    }

    // --- Event Handlers ---
    private void HandleTargetSpotted(CharacterManager target)
    {
        CurrentTarget = target;
        // Current state might react to this by transitioning (e.g., Idle to Chase)
    }

    private void HandleTargetLost()
    {
        CurrentTarget = null;
        // Current state might react (e.g., Chase to Idle/ReturnToPost)
    }

    private void HandleDamageTaken(int damageAmount, DamageType type, Transform attacker)
    {
        if (CurrentState == deadState || CurrentState == beingBackstabbedState) return; // Already dead or in critical hit anim

        // Specific handling for backstabs
        if (type == DamageType.BackstabCritical)
        {
            // The GetBackstabbed method should have already been called by the attacker
            // This event is more for logging or if additional logic is needed after damage application
            // SwitchState(beingBackstabbedState); // This is usually initiated by GetBackstabbed
            return;
        }

        // For other damage, transition to HitReactionState
        // unless in a state that shouldn't be interrupted (e.g. performing critical action)
        if (!(CurrentState is PerformingBackstabState)) // Don't interrupt own backstab
        {
            hitReactionState.SetAttacker(attacker); // Pass attacker for facing
            SwitchState(hitReactionState);
        }
    }

    private void HandleDeath()
    {
        SwitchState(deadState);
    }

    // --- Critical Action Control Methods ---
    public override void GetBackstabbed(Transform attacker) // Called by PlayerAttacker or other enemies
    {
        if (CurrentState == deadState || !canBeBackstabbed) return;

        Debug.Log($"{gameObject.name} is being backstabbed by {attacker.name}");
        base.GetBackstabbed(attacker); // Calls CharacterManager version if any shared logic needed

        beingBackstabbedState.SetAttacker(attacker);
        SwitchState(beingBackstabbedState);
    }

    public void SetPerformingCriticalAction(bool isPerforming, bool isAttackerPerspective)
    {
        // This method helps states like PerformingBackstabState to manage overall enemy behavior.
        // The flags `isPerformingCriticalAction` and `isReceivingCriticalHit` on CharacterManager
        // are now effectively controlled by being IN these specific states.
        if (isPerforming)
        {
            EnemyAnimator.IsInvulnerable = true; // Usually invulnerable during criticals
            Locomotion.DisableAgentAndPhysicsControl();
        }
        else
        {
            EnemyAnimator.IsInvulnerable = false; // Reset on exit from critical state
            // Locomotion re-enabled by the exiting state
        }
        // The boolean flags on EnemyManager are now less important than the state itself
    }

    // Called by EnemyAnimator's animation event when ENEMY'S ATTACKING critical animation finishes
    public void Notify_FinishedPerformingCriticalAction()
    {
        if (CurrentState is PerformingBackstabState performingState)
        {
            performingState.OnCriticalActionAnimationEnd();
        }
        Combat.ClearBackstabVictim();
    }

    // Called by EnemyAnimator's animation event when ENEMY'S VICTIM critical animation finishes
    public void Notify_FinishedBeingCriticallyHit()
    {
        if (CurrentState is BeingBackstabbedState victimState)
        {
            victimState.OnCriticalHitAnimationEnd();
        }
        // Check if health is <=0, if so, transition to DeadState if not already handled
        if (Stats.currentHealth <= 0 && CurrentState != deadState)
        {
            SwitchState(deadState);
        }
    }

    public void Notify_AttackActionConcluded()
    {
        Debug.Log($"{name}: AttackActionConcluded reported by animation.");
        HasAttackActionConcluded = true;
    }
}


--- END FILE: Characters\Enemy\EnemyManager.cs ---

--- START FILE: Characters\Enemy\EnemySenses.cs ---

using System;
using UnityEngine;

public class EnemySenses : MonoBehaviour
{
    public event Action<CharacterManager> OnTargetSpotted;
    public event Action OnTargetLost; // Assumes current target

    private EnemyManager enemyManager;

    [Header("Vision Settings")]
    public float sightRadius = 20f;
    [Range(0, 360)] public float sightAngle = 90f;
    public float loseSightDistanceMultiplier = 1.5f;
    public float timeToLoseTargetAfterLoSBreak = 5f;

    [Header("Proximity Settings")]
    public float proximityDetectionRadius = 5f;
    public float timeToLoseTargetAfterProximityBreak = 2f;

    [Header("Layers")]
    public LayerMask targetLayers; // Player layer
    public LayerMask obstructionLayers; // Walls, environment

    public CharacterManager CurrentPerceivedTarget { get; private set; }
    private float currentLoseTargetTimer = 0f;
    private enum DetectionMethod { None, LoS, Proximity }
    private DetectionMethod lastFrameDetectionMethod = DetectionMethod.None;

    public void Initialize(EnemyManager manager)
    {
        enemyManager = manager;
    }

    public void TickSenses()
    {
        if (enemyManager.CurrentState is DeadState)
        {
            if (CurrentPerceivedTarget != null) LoseCurrentTargetAndNotify();
            return;
        }

        CharacterManager freshlyDetectedThisFrame = null;
        DetectionMethod currentFrameDetectionMethod = DetectionMethod.None;

        // --- Step 1: Attempt to Detect a Target THIS FRAME ---
        Collider[] collidersInVision = Physics.OverlapSphere(transform.position, sightRadius, targetLayers);
        foreach (var col in collidersInVision)
        {
            CharacterManager pTarget = col.GetComponent<CharacterManager>();
            if (pTarget != null && pTarget != enemyManager && pTarget.isActiveAndEnabled)
            {
                if (IsTargetInDirectSight(pTarget)) // Line of Sight check
                {
                    freshlyDetectedThisFrame = pTarget;
                    currentFrameDetectionMethod = DetectionMethod.LoS;
                    break; // Prioritize LoS target
                }
            }
        }

        if (freshlyDetectedThisFrame == null) // If no LoS target, check proximity
        {
            Collider[] collidersInProximity = Physics.OverlapSphere(transform.position, proximityDetectionRadius, targetLayers);
            foreach (var col in collidersInProximity)
            {
                CharacterManager pTarget = col.GetComponent<CharacterManager>();
                if (pTarget != null && pTarget != enemyManager && pTarget.isActiveAndEnabled)
                {
                    PlayerManager player = pTarget as PlayerManager;
                    // Proximity only detects non-crouching players, or any non-player CharacterManager
                    if (player == null || (player != null && !player.playerAnimator.IsCrouching))
                    {
                        freshlyDetectedThisFrame = pTarget;
                        currentFrameDetectionMethod = DetectionMethod.Proximity;
                        break;
                    }
                }
            }
        }

        // --- Step 2: Update Target State based on Detection ---
        if (freshlyDetectedThisFrame != null)
        {
            if (CurrentPerceivedTarget == null)
            {
                SetNewTarget(freshlyDetectedThisFrame, currentFrameDetectionMethod);
            }
            else if (CurrentPerceivedTarget == freshlyDetectedThisFrame)
            {
                currentLoseTargetTimer = 0f;
                lastFrameDetectionMethod = currentFrameDetectionMethod;
            }
            else // Switched target (e.g., player ran past another valid target closer by LoS)
            {
                LoseCurrentTargetAndNotify();
                SetNewTarget(freshlyDetectedThisFrame, currentFrameDetectionMethod); // Spot new one
            }
        }
        else
        {
            if (CurrentPerceivedTarget != null) // We *were* tracking someone
            {
                currentLoseTargetTimer += Time.deltaTime;
                float maxTimeToLose = (lastFrameDetectionMethod == DetectionMethod.LoS) ? timeToLoseTargetAfterLoSBreak : timeToLoseTargetAfterProximityBreak;
                if (lastFrameDetectionMethod == DetectionMethod.None) maxTimeToLose = 0.1f;

                // Instant loss if they get too far, regardless of timer
                float distanceToLastKnown = Vector3.Distance(transform.position, CurrentPerceivedTarget.transform.position);
                if (distanceToLastKnown > sightRadius * loseSightDistanceMultiplier)
                {
                    Debug.Log($"Target {CurrentPerceivedTarget.name} lost due to excessive distance.");
                    LoseCurrentTargetAndNotify();
                }
                else if (currentLoseTargetTimer >= maxTimeToLose)
                {
                    Debug.Log($"Target {CurrentPerceivedTarget.name} lost due to timer ({currentLoseTargetTimer} >= {maxTimeToLose}), last seen via {lastFrameDetectionMethod}.");
                    LoseCurrentTargetAndNotify();
                }
                // else, still in grace period, keep CurrentPerceivedTarget for now
            }
            // If CurrentPerceivedTarget is already null and we didn't detect anyone, do nothing.
        }
    }

    private bool IsTargetInDirectSight(CharacterManager target)
    {
        if (target == null || target.lockOnTransform == null) return false;
        Vector3 directionToTarget = target.lockOnTransform.position - transform.position;
        if (directionToTarget.magnitude > sightRadius) return false; // Check distance first

        float angle = Vector3.Angle(transform.forward, directionToTarget.normalized);
        if (angle > sightAngle / 2f) return false;

        Vector3 sightOrigin = transform.position + Vector3.up * (enemyManager.GetComponent<UnityEngine.AI.NavMeshAgent>()?.height * 0.8f ?? 1.5f);
        if (Physics.Linecast(sightOrigin, target.lockOnTransform.position, out RaycastHit hit, obstructionLayers, QueryTriggerInteraction.Ignore))
        {
            return hit.transform.root == target.transform.root; // True if hit target, false if obstructed
        }
        return true; // Clear LoS
    }

    private void SetNewTarget(CharacterManager target, DetectionMethod method)
    {
        CurrentPerceivedTarget = target;
        lastFrameDetectionMethod = method; // Store how we initially saw them
        currentLoseTargetTimer = 0f;       // Reset loss timer
        OnTargetSpotted?.Invoke(target);
        Debug.Log($"{enemyManager.name} spotted target: {target.name} via {method}");
    }

    private void LoseCurrentTargetAndNotify()
    {
        if (CurrentPerceivedTarget != null)
        {
            Debug.Log($"{enemyManager.name} lost target: {CurrentPerceivedTarget.name} (was {lastFrameDetectionMethod})");
        }
        CurrentPerceivedTarget = null;
        lastFrameDetectionMethod = DetectionMethod.None;
        currentLoseTargetTimer = 0f;
        OnTargetLost?.Invoke(); // Notify manager and other systems
    }

    public void ForceLoseTarget() => LoseCurrentTargetAndNotify();

    void OnDrawGizmosSelected()
    {
        if (enemyManager == null && TryGetComponent(out enemyManager)) { /* Initialized for gizmo */ }
        if (enemyManager == null) return;


        // Vision Cone
        Gizmos.color = Color.yellow;
        Gizmos.DrawWireSphere(transform.position, sightRadius);
        Vector3 fovLine1 = Quaternion.AngleAxis(sightAngle / 2, transform.up) * transform.forward * sightRadius;
        Vector3 fovLine2 = Quaternion.AngleAxis(-sightAngle / 2, transform.up) * transform.forward * sightRadius;
        Gizmos.color = Color.blue;
        Gizmos.DrawRay(transform.position, fovLine1);
        Gizmos.DrawRay(transform.position, fovLine2);

        // Proximity Radius
        Gizmos.color = new Color(0.5f, 0, 0.5f, 0.3f); // Purpleish
        Gizmos.DrawWireSphere(transform.position, proximityDetectionRadius);


        if (CurrentPerceivedTarget != null && CurrentPerceivedTarget.lockOnTransform != null)
        {
            Gizmos.color = (lastFrameDetectionMethod == DetectionMethod.LoS) ? Color.green : ((lastFrameDetectionMethod == DetectionMethod.Proximity) ? Color.magenta : Color.red);
            Vector3 sightOrigin = transform.position + Vector3.up * (enemyManager.GetComponent<UnityEngine.AI.NavMeshAgent>()?.height * 0.8f ?? 1.5f);
            Gizmos.DrawLine(sightOrigin, CurrentPerceivedTarget.lockOnTransform.position);
        }
    }
}


--- END FILE: Characters\Enemy\EnemySenses.cs ---

--- START FILE: Characters\Enemy\EnemyStats.cs ---

using System;
using UnityEngine;

public class EnemyStats : CharacterStats
{
    public event Action<int, DamageType, Transform> OnDamagedEvent;
    public event Action OnDeathEvent;
    public event Action<int, int> OnHealthChanged; // First int: currentHealth, Second int: maxHealth

    private EnemyManager enemyManager;
    private EnemyHealthBarUI healthBarUI;

    [Header("Enemy Specific Stats")]
    [SerializeField] private int baseHealthAmount = 100;
    public float poise = 100f;
    public float currentPoise;

    protected void Awake()
    {
        //base.Awake();
        enemyManager = GetComponent<EnemyManager>();
        if (enemyManager == null)
        {
            Debug.LogError("EnemyStats could not find EnemyManager component.", this);
        }
    }

    private void Start()
    {
        maxHealth = CalculateMaxHealth();
        currentHealth = maxHealth;

        OnHealthChanged?.Invoke(currentHealth, maxHealth);

        currentPoise = poise;
        isDead = false;
    }

    private int CalculateMaxHealth()
    {
        int levelBasedGainedHealth = 0;

        if (characterLevel < 20)
        {
            levelBasedGainedHealth = 15 * characterLevel;
        }
        else if (characterLevel >= 20 && characterLevel <= 40)
        {
            levelBasedGainedHealth = 300 + 10 * (characterLevel - 19);
        }
        else if (characterLevel > 40)
        {
            levelBasedGainedHealth = 510 + 5 * (characterLevel - 40);
        }

        return baseHealthAmount + levelBasedGainedHealth;
    }

    public void TakeDamage(int damage, DamageType damageType, Transform attacker)
    {
        if (isDead) return;
        if (enemyManager.EnemyAnimator.IsInvulnerable && damageType != DamageType.BackstabCritical) // Backstabs should always hit
        {
            // TODO: Maybe some damage types bypass invulnerability
            Debug.Log($"{gameObject.name} is invulnerable. Damage blocked.");
            return;
        }

        currentHealth -= damage;
        Debug.Log($"{gameObject.name} took {damage} damage. Current health: {currentHealth}/{maxHealth}");

        OnHealthChanged?.Invoke(currentHealth, maxHealth);
        OnDamagedEvent?.Invoke(damage, damageType, attacker); // Notify EnemyManager

        if (currentHealth <= 0)
        {
            currentHealth = 0;
            if (!isDead) // Ensure OnDeathEvent is invoked only once
            {
                isDead = true;
                if (healthBarUI != null) healthBarUI.gameObject.SetActive(false);
                OnDeathEvent?.Invoke(); // Notify EnemyManager
            }
        }
        // else
        // {
        //    // Handle poise damage
        //    // currentPoise -= poiseDamageFromAttack;
        //    // if (currentPoise <= 0) { // Trigger PoiseBreak state }
        // }
    }

    public void Heal(int amount)
    {
        if (isDead) return;

        currentHealth = Mathf.Min(currentHealth + amount, maxHealth);
        OnHealthChanged?.Invoke(currentHealth, maxHealth);
    }
}


--- END FILE: Characters\Enemy\EnemyStats.cs ---

--- START FILE: Characters\Enemy\EnemyWeaponSlotManager.cs ---

using UnityEngine;

public class EnemyWeaponSlotManager : MonoBehaviour
{
    public EnemyManager enemyManager;
    public WeaponItem rightHandWeapon;

    private WeaponHolderSlot rightHandSlot;
    private DamageCollider rightHandDamageCollider;

    private void Awake()
    {
        if (enemyManager == null)
            enemyManager = GetComponentInParent<EnemyManager>();
        if (enemyManager == null)
            Debug.LogError("EnemyWeaponSlotManager: EnemyManager reference not set!", this);

        rightHandSlot = GetComponentInChildren<WeaponHolderSlot>();
        if (rightHandSlot == null)
            Debug.LogError("EnemyWeaponSlotManager: No WeaponHolderSlot found in children!", this);
    }

    private void Start()
    {
        if (rightHandWeapon != null && rightHandSlot != null)
        {
            LoadWeaponOnSlot(rightHandWeapon, WeaponHand.Right);
        }
    }

    public void LoadWeaponOnSlot(WeaponItem weapon, WeaponHand hand)
    {
        if (hand == WeaponHand.Right && rightHandSlot != null)
        {
            if (rightHandDamageCollider != null)
            {
                rightHandDamageCollider.OnDamageableHit -= HandleRightHandHit;
            }

            rightHandSlot.LoadWeaponModel(weapon);
            rightHandDamageCollider = null;

            if (rightHandSlot.currentWeaponModel != null)
            {
                rightHandDamageCollider = rightHandSlot.currentWeaponModel.GetComponentInChildren<DamageCollider>();
                if (rightHandDamageCollider != null)
                {
                    rightHandDamageCollider.Wielder = enemyManager; // Set wielder
                    rightHandDamageCollider.OnDamageableHit += HandleRightHandHit; // Subscribe
                }
            }
            else if (weapon != null && weapon.isUnarmed) // Handle unarmed "fist" collider for enemy
            {

            }
        }
    }

    private void HandleRightHandHit(Collider victimCollider)
    {
        if (enemyManager != null && enemyManager.Combat != null)
        {
            enemyManager.Combat.ProcessHit(victimCollider, rightHandWeapon); 
        }
    }

    public void OpenDamageCollider(WeaponHand hand)
    {
        if (hand == WeaponHand.Right && rightHandDamageCollider != null)
        {
            rightHandDamageCollider.EnableDamageCollider();
        }
    }

    public void CloseDamageCollider(WeaponHand hand)
    {
        if (hand == WeaponHand.Right && rightHandDamageCollider != null)
        {
            rightHandDamageCollider.DisableDamageCollider();
        }
    }

    #region Handle Weapon's Stamina Consumption
    public void DrainStaminaLightAttack()
    {

    }

    public void DrainStaminaHeavyAttack()
    {

    }
    #endregion

    public void EnableCombo()
    {
        //anim.SetBool("canDoCombo", true);
    }

    public void DisableCombo()
    {
        //anim.SetBool("canDoCombo", false);
    }
}

--- END FILE: Characters\Enemy\EnemyWeaponSlotManager.cs ---

--- START FILE: Characters\Enemy\PatrolRoute.cs ---

using System.Collections.Generic;
using UnityEngine;

public class PatrolRoute : MonoBehaviour
{
    public List<Transform> patrolPoints = new List<Transform>();
    public bool loop = true;
    public float patrolWaitTime = 3f;

    void OnDrawGizmos() // Visualize the route
    {
        if (patrolPoints == null || patrolPoints.Count < 2) return;

        Gizmos.color = Color.cyan;
        for (int i = 0; i < patrolPoints.Count; i++)
        {
            if (patrolPoints[i] == null) continue;
            Gizmos.DrawSphere(patrolPoints[i].position, 0.3f);
            if (i < patrolPoints.Count - 1)
            {
                if (patrolPoints[i + 1] != null) Gizmos.DrawLine(patrolPoints[i].position, patrolPoints[i + 1].position);
            }
            else if (loop && patrolPoints[0] != null) // Loop back to start
            {
                Gizmos.DrawLine(patrolPoints[i].position, patrolPoints[0].position);
            }
        }
    }
}


--- END FILE: Characters\Enemy\PatrolRoute.cs ---

--- START FILE: Characters\Enemy\RepositionState.cs ---

using UnityEngine;
using UnityEngine.AI;

public class RepositionState : IEnemyState
{
    private EnemyManager manager;
    private NavMeshAgent agent;

    private float repositionTimer;
    private Vector3 chosenRepositionDestination;
    private bool isStrafing;

    // --- State Configuration (Consider moving to EnemyManager or a ScriptableObject for per-enemy tuning) ---
    private const float MinRepositionDuration = 1.5f;
    private const float MaxRepositionDuration = 3.0f;
    private const float StrafeDistance = 2.0f; // How far to strafe sideways
    private const float IdealMinDistanceFromTarget = 2f; // Try to stay at least this far
    private const float IdealMaxDistanceFromTarget = 4f; // Try to stay within this distance
    private const float RepositionSpeedMultiplier = 0.8f; // Speed during reposition vs base speed
    private const float FacePlayerRotationSpeed = 10f;

    public void Enter(EnemyManager manager)
    {
        this.manager = manager;
        agent = manager.Locomotion.GetComponent<NavMeshAgent>();

        Debug.Log($"{manager.name} entered RepositionState.");

        manager.Locomotion.EnableAgentNavigation();
        agent.speed = manager.Locomotion.baseSpeed * RepositionSpeedMultiplier;
        agent.stoppingDistance = 0.5f; // Allow getting closer to the chosen reposition point
        agent.updateRotation = true; // Let agent handle rotation towards path initially, but we might override to face player

        repositionTimer = Random.Range(MinRepositionDuration, MaxRepositionDuration);
        ChooseAndSetRepositionManeuver();
    }

    private void ChooseAndSetRepositionManeuver()
    {
        if (manager.CurrentTarget == null)
        {
            // Should not happen if called correctly, but as a safeguard
            chosenRepositionDestination = manager.transform.position;
            isStrafing = false;
            manager.Locomotion.StopMovement();
            repositionTimer = 0.1f;
            return;
        }

        Vector3 enemyPos = manager.transform.position;
        Vector3 targetPos = manager.CurrentTarget.transform.position;
        float distanceToTarget = Vector3.Distance(enemyPos, targetPos);
        Vector3 directionToTarget = (targetPos - enemyPos).normalized;
        Vector3 directionAwayFromTarget = -directionToTarget;

        isStrafing = false; // Default

        // Strategy:
        // 1. If too close, try to back away.
        // 2. If too far (but still in reasonable combat range), try to move diagonally closer.
        // 3. Otherwise, strafe left or right.

        if (distanceToTarget < IdealMinDistanceFromTarget)
        {
            // Try to move backward or diagonally backward
            Vector3 perpendicular = Vector3.Cross(Vector3.up, directionToTarget).normalized;
            chosenRepositionDestination = enemyPos + directionAwayFromTarget * StrafeDistance * 0.75f +
                                         (Random.value > 0.5f ? perpendicular : -perpendicular) * StrafeDistance * 0.5f;
            Debug.Log($"{manager.name} reposition: Too close, moving back/diagonally.");
        }
        else if (distanceToTarget > IdealMaxDistanceFromTarget && distanceToTarget < manager.Senses.sightRadius * 0.9f)
        {
            // Try to move diagonally forward
            Vector3 perpendicular = Vector3.Cross(Vector3.up, directionToTarget).normalized;
            chosenRepositionDestination = enemyPos + directionToTarget * StrafeDistance * 0.5f +
                                         (Random.value > 0.5f ? perpendicular : -perpendicular) * StrafeDistance * 0.75f;
            Debug.Log($"{manager.name} reposition: Bit far, moving diagonally closer.");
        }
        else
        {
            // Strafe: Pick a point to the side of the target, maintaining similar distance
            isStrafing = true;
            Vector3 perpendicular = Vector3.Cross(Vector3.up, directionToTarget).normalized;
            Vector3 strafeDir = Random.value > 0.5f ? perpendicular : -perpendicular;

            // Project current position onto line perpendicular to target, then move along it
            Vector3 pointOnStrafeLine = enemyPos + strafeDir * StrafeDistance;
            chosenRepositionDestination = pointOnStrafeLine;
            Debug.Log($"{manager.name} reposition: Strafing.");
        }

        // Validate destination on NavMesh
        if (NavMesh.SamplePosition(chosenRepositionDestination, out NavMeshHit hit, 2.0f, NavMesh.AllAreas))
        {
            chosenRepositionDestination = hit.position;
            manager.Locomotion.MoveToPoint(chosenRepositionDestination);
        }
        else
        {
            // Fallback: could not find valid point, maybe just stay put or try simpler strafe
            Debug.LogWarning($"{manager.name} reposition: Could not find valid NavMesh point for maneuver. Staying put for now.");
            manager.Locomotion.StopMovement();
            repositionTimer = 0.2f; // Quickly exit state if stuck
        }
    }

    public void Tick()
    {
        manager.Senses.TickSenses();
        repositionTimer -= Time.deltaTime;

        if (manager.CurrentTarget != null)
        {
            // --- DYNAMIC ROTATION CONTROL ---
            bool shouldManuallyFacePlayer = false;

            if (agent.enabled && agent.isOnNavMesh)
            {
                // If we are performing a strafing maneuver OR if we are very close to our NavMesh destination,
                // prioritize facing the player.
                if (isStrafing || (!agent.pathPending && agent.remainingDistance <= agent.stoppingDistance + 0.2f))
                {
                    shouldManuallyFacePlayer = true;
                }
            }
            else
            {
                // If agent is somehow disabled but we have a target, try to face them.
                shouldManuallyFacePlayer = true;
            }


            if (shouldManuallyFacePlayer)
            {
                if (agent.enabled) agent.updateRotation = false; // Disable agent's auto-rotation
                manager.Locomotion.RotateTowards(manager.CurrentTarget.transform.position, FacePlayerRotationSpeed);
            }
            else
            {
                if (agent.enabled) agent.updateRotation = true; // Let agent control rotation towards its path
            }
        }
        else // No target
        {
            if (agent.enabled) agent.updateRotation = true; // Let agent control rotation if no target (e.g., returning to post)
        }
    }

    public void FixedTick()
    {
        // Movement is handled by NavMeshAgent.SetDestination in ChooseAndSetRepositionManeuver
        // and updated by EnemyLocomotion.UpdateAnimatorMovementParameters() via EnemyManager.Update()
    }

    public IEnemyState Transition()
    {
        if (manager.CurrentTarget == null)
        {
            return manager.returnToPostState;
        }

        if (!manager.Combat.IsAttackOnCooldown)
        {
            // Debug.Log($"{manager.name} RepositionState: Attack cooldown ended. To CombatStance.");
            return manager.combatStanceState;
        }

        // Check if maneuver is complete (timer or reached destination)
        bool maneuverComplete = repositionTimer <= 0;
        if (agent.enabled && agent.isOnNavMesh && !agent.pathPending)
        {
            if (agent.remainingDistance <= agent.stoppingDistance)
            {
                maneuverComplete = true;
            }
        }
        else if (!agent.enabled || !agent.isOnNavMesh)
        { // If agent gets disabled or off mesh, consider maneuver "done" to avoid getting stuck
            maneuverComplete = true;
        }


        if (maneuverComplete)
        {
            // Debug.Log($"{manager.name} RepositionState: Maneuver/timer complete. To CombatStance (still on cooldown).");
            return manager.combatStanceState;
        }

        float distanceToTarget = Vector3.Distance(manager.transform.position, manager.CurrentTarget.transform.position);
        if (distanceToTarget > manager.Senses.sightRadius * manager.Senses.loseSightDistanceMultiplier * 0.9f)
        {
            // Debug.Log($"{manager.name} RepositionState: Target too far. To ChaseState.");
            return manager.chaseState;
        }

        return null;
    }

    public void Exit()
    {
        // Restore default agent settings
        if (agent.enabled && agent.isOnNavMesh)
        {
            agent.stoppingDistance = manager.defaultStoppingDistance;
            agent.updateRotation = true;
        }
        // manager.Locomotion.StopMovement(); // Let the next state decide to stop or continue
        Debug.Log($"{manager.name} exited RepositionState.");
    }
}


--- END FILE: Characters\Enemy\RepositionState.cs ---

--- START FILE: Characters\Enemy\States\AttackingState.cs ---

using UnityEngine;

public class AttackingState : IEnemyState
{
    private EnemyManager manager;
    private EnemyAttackActionSO currentAttack;
    //private float animationTimer;

    public void SetAttackAction(EnemyAttackActionSO attack)
    {
        currentAttack = attack;
    }

    public void Enter(EnemyManager manager)
    {
        this.manager = manager;
        if (currentAttack == null)
        {
            Debug.LogError("AttackingState entered without an attack action set!");
            manager.SwitchState(manager.combatStanceState);
            return;
        }

        // Debug.Log($"{manager.name} entered AttackingState with {currentAttack.actionName}.");
        manager.EnemyAnimator.IsInMidAction = true; // Animation starts, enemy is busy
        manager.HasAttackActionConcluded = false;   // Reset for this new attack

        manager.Locomotion.StopMovement();
        manager.Locomotion.DisableAgentNavigation(true);
        if (manager.CurrentTarget != null) manager.Locomotion.FaceTargetInstantly(manager.CurrentTarget.transform);

        manager.Combat.NotifyAttackActionStarted(currentAttack); // This sets the gameplay cooldown
        manager.EnemyAnimator.PlayTargetAnimation(currentAttack.animationName, true);
        // Animation should have AnimEvent_AttackActionConcluded and AnimEvent_FinishAction
    }

    public void Tick() { } // Transitions driven by IsInMidAction and hasAttackActionConcluded

    public void FixedTick() { }

    public IEnemyState Transition()
    {
        if (manager.HasAttackActionConcluded)
        {
            if (manager.canRepositionWhileOnCooldown && manager.Combat.IsAttackOnCooldown && manager.CurrentTarget != null)
            {
                return manager.repositionState;
            }
        }

        if (!manager.EnemyAnimator.IsInMidAction) // Entire animation sequence is complete
        {
            if (manager.CurrentTarget == null)
            {
                return manager.idleState;
            }
            return manager.combatStanceState; // Default back to combat stance to re-evaluate
        }
        return null;
    }

    public void Exit()
    {
        // Ensure IsInMidAction is false if exiting for any reason other than normal animation end.
        // If AnimEvent_FinishAction fired, IsInMidAction is already false.
        // If transitioning to RepositionState while IsInMidAction is still true (visual recovery),
        // then RepositionState.Enter doesn't mess with IsInMidAction, and AttackingState.Exit doesn't need to force it false.
        // The enemy is still "in an action sequence" until the original attack animation's FinishAction.
        // However, for safety if interrupted:
        if(manager.EnemyAnimator.IsInMidAction) manager.EnemyAnimator.IsInMidAction = false; // Or let the new state manage.

        manager.HasAttackActionConcluded = false; // Reset for next time
        currentAttack = null;
        Debug.Log($"{manager.name} exited AttackingState.");
    }

    public EnemyAttackActionSO GetCurrentAttackAction()
    {
        return currentAttack;
    }
}


--- END FILE: Characters\Enemy\States\AttackingState.cs ---

--- START FILE: Characters\Enemy\States\BeingBackstabbedState.cs ---

using UnityEngine;

public class BeingBackstabbedState : IEnemyState
{
    private EnemyManager manager;
    private Transform attacker;
    private bool animationFinishedNotified = false; // Flag set by animation event

    public void SetAttacker(Transform attackerTransform)
    {
        attacker = attackerTransform;
    }

    public void Enter(EnemyManager manager)
    {
        this.manager = manager;
        animationFinishedNotified = false;
        manager.isBeingCriticallyHit = true;
        manager.EnemyAnimator.IsInvulnerable = true;  // Invulnerable while being backstabbed

        manager.Locomotion.DisableAgentAndPhysicsControl(); // Animation takes full control

        // Orient self relative to attacker
        if (attacker != null)
        {
            Vector3 directionFromAttacker = manager.transform.position - attacker.position;
            directionFromAttacker.y = 0;
            directionFromAttacker.Normalize();
            if (directionFromAttacker != Vector3.zero)
            {
                manager.transform.rotation = Quaternion.LookRotation(directionFromAttacker);
            }
        }

        manager.EnemyAnimator.PlayTargetAnimation(manager.beingBackstabbedAnimation, true, 0.05f);
        Debug.Log($"{manager.name} entered BeingBackstabbedState.");
    }

    public void Tick()
    {
        // Logic is mostly driven by animation events.
    }

    public void FixedTick() { }

    // Called from EnemyManager via AnimEvent_FinishBeingCriticallyHit
    public void OnCriticalHitAnimationEnd()
    {
        animationFinishedNotified = true;
    }

    public IEnemyState Transition()
    {
        if (animationFinishedNotified)
        {
            if (manager.Stats.isDead)
            {
                return manager.deadState;
            }
            // If survived, decide next state (e.g., briefly stunned or back to combat/idle)
            // For now, just go to idle/chase based on target presence
            if (manager.CurrentTarget != null) return manager.chaseState;
            return manager.idleState;
        }
        return null;
    }

    public void Exit()
    {
        manager.isBeingCriticallyHit = false;
        manager.EnemyAnimator.IsInvulnerable = false;
        manager.EnemyAnimator.IsInMidAction = false;
        manager.canBeBackstabbed = true;
        // Re-enable appropriate locomotion, handled by the next state's Enter usually
        // manager.Locomotion.EnableAgentNavigation(); // Example
        attacker = null;
        Debug.Log($"{manager.name} exited BeingBackstabbedState.");
    }
}


--- END FILE: Characters\Enemy\States\BeingBackstabbedState.cs ---

--- START FILE: Characters\Enemy\States\ChaseState.cs ---

using UnityEngine;

public class ChaseState : IEnemyState
{
    private EnemyManager manager;

    public void Enter(EnemyManager manager)
    {
        this.manager = manager;
        manager.Locomotion.EnableAgentNavigation();
        manager.Locomotion.SetAgentSpeed(manager.Locomotion.chaseSpeed);
        Debug.Log($"{manager.name} entered ChaseState, chasing {manager.CurrentTarget?.name}.");
    }

    public void Tick()
    {
        manager.Senses.TickSenses(); // Continuously update target status
    }

    public void FixedTick()
    {
        if (manager.CurrentTarget != null)
        {
            manager.Locomotion.FollowTarget(manager.CurrentTarget.transform);
            manager.Locomotion.RotateTowards(manager.CurrentTarget.transform.position, manager.Locomotion.rotationSpeed);
        }
    }

    public IEnemyState Transition()
    {
        if (manager.CurrentTarget == null)
        {
            return manager.returnToPostState;
        }

        float distanceToTarget = Vector3.Distance(manager.transform.position, manager.CurrentTarget.transform.position);
        //Debug.Log("Distance towards player: " + distanceToTarget);
        if (distanceToTarget <= manager.defaultStoppingDistance)
        {
            return manager.combatStanceState;
        }
        return null;
    }

    public void Exit()
    {
        manager.Locomotion.StopMovement(); // Stop if transitioning out abruptly
    }
}


--- END FILE: Characters\Enemy\States\ChaseState.cs ---

--- START FILE: Characters\Enemy\States\CombatStanceState.cs ---

using UnityEngine;

public class CombatStanceState : IEnemyState
{
    private EnemyManager manager;
    private float _timeSpentInStance = 0f;
    private const float MaxWaitTimeInStanceOnCooldown = 2.0f;

    // Internal flags to store decisions made in Tick()
    private bool _wantsToBackstab = false;
    private EnemyAttackActionSO _selectedAttackAction = null;

    public void Enter(EnemyManager manager)
    {
        this.manager = manager;
        manager.Locomotion.StopMovement();
        manager.Locomotion.EnableAgentNavigation();
        manager.Locomotion.GetComponent<UnityEngine.AI.NavMeshAgent>().updateRotation = false; // Manual rotation
        manager.Locomotion.SetAgentSpeed(manager.Locomotion.baseSpeed * 0.5f);

        // Reset decision flags
        _wantsToBackstab = false;
        _selectedAttackAction = null;
        _timeSpentInStance = 0f;

        Debug.Log($"{manager.name} entered CombatStanceState against {manager.CurrentTarget?.name}.");
    }

    public void Tick()
    {
        manager.Senses.TickSenses();
        if (manager.CurrentTarget == null) return;

        manager.Locomotion.RotateTowards(manager.CurrentTarget.transform.position);

        _selectedAttackAction = null; // Reset decision each tick
        _wantsToBackstab = false;

        if (manager.Combat.IsAttackOnCooldown)
        {
            _timeSpentInStance += Time.deltaTime;
        }
        else // Not on cooldown, try to select an action
        {
            _timeSpentInStance = 0f;
            // Priority 1: Backstab
            if (manager.CurrentTarget is PlayerManager playerTarget &&
                manager.Combat.CanAttemptBackstab(playerTarget) &&
                Random.value < manager.Combat.chanceToAttemptBackstab)
            {
                _wantsToBackstab = true;
            }

            // Priority 2: Regular Attack
            if (!_wantsToBackstab)
            {
                _selectedAttackAction = manager.Combat.GetAvailableAttack(manager.CurrentTarget);
            }
        }
    }

    public void FixedTick()
    {
        // If NavMeshAgent is enabled for minor adjustments, ensure it's not causing unwanted sliding.
        // manager.Locomotion.StopMovement(); // Or implement slight strafing logic here if desired for stance
    }

    public IEnemyState Transition()
    {
        if (manager.CurrentTarget == null)
        {
            return manager.returnToPostState;
        }

        float distanceToTarget = Vector3.Distance(manager.transform.position, manager.CurrentTarget.transform.position);
        if (distanceToTarget > manager.defaultStoppingDistance * 1.2f) // Target moved too far
        {
            return manager.chaseState;
        }

        // If an attack action was chosen (and not on cooldown)
        if (_selectedAttackAction != null)
        {
            manager.attackingState.SetAttackAction(_selectedAttackAction);
            return manager.attackingState;
        }
        if (_wantsToBackstab && manager.CurrentTarget is PlayerManager playerForBackstab)
        {
            manager.Combat.InitiateBackstabSequence(playerForBackstab);
            return manager.performingBackstabState;
        }

        // If attack is on cooldown AND repositioning is enabled AND waited long enough in stance
        if (manager.Combat.IsAttackOnCooldown && manager.canRepositionWhileOnCooldown && _timeSpentInStance >= MaxWaitTimeInStanceOnCooldown)
        {
            return manager.repositionState;
        }

        return null; // Stay in CombatStanceState
    }

    public void Exit()
    {
        var agent = manager.Locomotion.GetComponent<UnityEngine.AI.NavMeshAgent>();
        if (agent != null && agent.enabled)
        {
            agent.updateRotation = true; // Restore agent rotation control
        }
        Debug.Log($"{manager.name} exited CombatStanceState.");
    }
}


--- END FILE: Characters\Enemy\States\CombatStanceState.cs ---

--- START FILE: Characters\Enemy\States\DeadState.cs ---

using UnityEngine;

public class DeadState : IEnemyState
{
    private EnemyManager manager;
    private float despawnTimer = 5f;

    public void Enter(EnemyManager manager)
    {
        this.manager = manager;
        Debug.Log($"{manager.name} entered DeadState.");

        manager.CurrentTarget = null; // No longer has a target
        manager.Senses.ForceLoseTarget(); // Ensure senses are cleared
        manager.Locomotion.DisableAgentAndPhysicsControl(); // Stop all movement, make kinematic
        manager.GetComponent<Collider>().enabled = false; // Disable main collider
        if (manager.lockOnTransform != null) manager.lockOnTransform.gameObject.SetActive(false); // Disable lock-on point

        // Play death animation. Ensure it's not interrupted by isPerformingCriticalHit checks
        if (!manager.isBeingCriticallyHit)
        {
            manager.EnemyAnimator.PlayTargetAnimation("Death_01", true); // "Death_01" or appropriate
        }
        manager.EnemyAnimator.SetBool("isDead", true); // For animator transitions if any

        // TODO: Handle dropping loot, notifying quest systems, etc.
    }

    public void Tick()
    {
        despawnTimer -= Time.deltaTime;
        if (despawnTimer <= 0)
        {
            // TODO: Maybe pool instead of destroy
            Object.Destroy(manager.gameObject);
        }
    }

    public void FixedTick() { }

    public IEnemyState Transition()
    {
        return null; // No transitions out of DeadState except destruction
    }

    public void Exit()
    {
        // Cleanup if needed before destroy, but usually handled by OnDestroy()
    }
}


--- END FILE: Characters\Enemy\States\DeadState.cs ---

--- START FILE: Characters\Enemy\States\HitReactionState.cs ---

using UnityEngine;

public class HitReactionState : IEnemyState
{
    private EnemyManager manager;
    private Transform attacker;
    private bool isInvincibleDuringStun;
    private float hitStunDuration; // Or get from attack data / animation length

    public HitReactionState(bool isInvincibleDuringStun = false, float hitStunDuration = 0.1f)
    {
        this.isInvincibleDuringStun = isInvincibleDuringStun;
        this.hitStunDuration = hitStunDuration;
    }

    public void SetAttacker(Transform attackerTransform)
    {
        attacker = attackerTransform;
    }

    public void Enter(EnemyManager manager)
    {
        this.manager = manager;
        manager.Locomotion.StopMovement();
        manager.Locomotion.DisableAgentNavigation(true); // Allow root motion or physics pushes

        if (isInvincibleDuringStun) manager.EnemyAnimator.IsInvulnerable = true;

        if (attacker != null) manager.Locomotion.FaceTargetInstantly(attacker);

        // TODO: Choose hit animation based on damage type, direction, etc.
        manager.EnemyAnimator.PlayTargetAnimation("Damage_01", true); // Generic damage animation
        Debug.Log($"{manager.name} entered HitReactionState.");

        // Reset attacker after use
        attacker = null;
    }

    public void Tick()
    {
        hitStunDuration = isInvincibleDuringStun ? (hitStunDuration - Time.deltaTime) : 0;
    }

    public void FixedTick() { }

    public IEnemyState Transition()
    {
        if (hitStunDuration <= 0)
        {
            if (manager.Stats.isDead) return manager.deadState; // Check for death from this hit

            if (manager.CurrentTarget != null)
            {
                float distanceToTarget = Vector3.Distance(manager.transform.position, manager.CurrentTarget.transform.position);
                if (distanceToTarget <= manager.defaultStoppingDistance * 1.2f)
                {
                    return manager.combatStanceState;
                }
                return manager.chaseState;
            }
            return manager.returnToPostState;
        }
        return null;
    }

    public void Exit()
    {
        if (isInvincibleDuringStun) manager.EnemyAnimator.IsInvulnerable = false;
    }
}


--- END FILE: Characters\Enemy\States\HitReactionState.cs ---

--- START FILE: Characters\Enemy\States\IdleState.cs ---

using UnityEngine;

public class IdleState : IEnemyState
{
    private EnemyManager manager;
    private float idleTimer;
    private readonly float minIdleTime = 2f;
    private readonly float maxIdleTime = 5f;

    public void Enter(EnemyManager manager)
    {
        this.manager = manager;
        manager.Locomotion.StopMovement();
        manager.Locomotion.DisableAgentNavigation(true); // Ensure non-kinematic for idle physics if any
        manager.EnemyAnimator.SetMovementValues(0, 0);
        //manager.EnemyAnimator.PlayTargetAnimation("Idle", false);
        idleTimer = Random.Range(minIdleTime, maxIdleTime);
        Debug.Log($"{manager.name} entered IdleState.");
    }

    public void Tick()
    {
        manager.Senses.TickSenses(); // Keep looking for targets

        idleTimer -= Time.deltaTime;
    }

    public void FixedTick() { }

    public IEnemyState Transition()
    {
        if (manager.CurrentTarget != null)
        {
            return manager.chaseState;
        }
        if (idleTimer <= 0 && manager.patrolRoute != null && manager.patrolRoute.patrolPoints.Count > 0)
        {
            return manager.patrolState;
        }
        return null;
    }

    public void Exit() { }
}


--- END FILE: Characters\Enemy\States\IdleState.cs ---

--- START FILE: Characters\Enemy\States\IEnemyState.cs ---

public interface IEnemyState
{
    void Enter(EnemyManager manager);
    void Tick();              // For Update logic
    void FixedTick();         // For FixedUpdate logic
    IEnemyState Transition(); // Returns new state if transition occurs, else null
    void Exit();
}


--- END FILE: Characters\Enemy\States\IEnemyState.cs ---

--- START FILE: Characters\Enemy\States\PatrolState.cs ---

using UnityEngine;

public class PatrolState : IEnemyState
{
    private EnemyManager manager;
    private int currentPatrolPointIndex = 0;
    private float waitTimer;
    private bool isWaitingAtPoint = false;

    public void Enter(EnemyManager manager)
    {
        this.manager = manager;

        if (manager.patrolRoute == null || manager.patrolRoute.patrolPoints.Count == 0)
        {
            Debug.LogWarning($"{manager.name} tried to enter PatrolState but has no patrol path. Switching to Idle.");
            // No immediate switch here, let Transition handle it to avoid recursion if Idle also tries to go to Patrol.
            return;
        }

        manager.Locomotion.EnableAgentNavigation();
        manager.Locomotion.SetAgentSpeed(manager.Locomotion.baseSpeed); // Normal patrol speed
        currentPatrolPointIndex = GetClosestPatrolPointIndex(); // Start at the closest point
        SetNextDestination();
        isWaitingAtPoint = false;
        waitTimer = 0f;
        Debug.Log($"{manager.name} entered PatrolState.");
    }

    public void Tick()
    {
        manager.Senses.TickSenses(); // Keep an eye out for targets

        if (isWaitingAtPoint)
        {
            waitTimer -= Time.deltaTime;
            if (waitTimer <= 0)
            {
                isWaitingAtPoint = false;
                AdvancePatrolPoint();
                SetNextDestination();
            }
        }
        else
        {
            // Check if reached destination
            if (manager.Locomotion.HasReachedDestination)
            {
                isWaitingAtPoint = true;
                waitTimer = manager.patrolRoute.patrolWaitTime;
                manager.EnemyAnimator.SetMovementValues(0, 0); // Stop animation
                // Optional: Play a specific "waiting" or "looking around" animation
            }
        }
    }

    public void FixedTick()
    {
        // Locomotion is handled by NavMeshAgent, animator params updated in EnemyManager.Update()
    }

    private void SetNextDestination()
    {
        if (manager.patrolRoute != null && manager.patrolRoute.patrolPoints.Count > 0)
        {
            Transform targetPoint = manager.patrolRoute.patrolPoints[currentPatrolPointIndex];
            if (targetPoint != null)
            {
                manager.Locomotion.MoveToPoint(targetPoint.position);
                // Debug.Log($"{manager.name} patrolling to point {currentPatrolPointIndex}: {targetPoint.name}");
            }
            else
            {
                Debug.LogWarning($"{manager.name} patrol point {currentPatrolPointIndex} is null. Advancing.");
                AdvancePatrolPoint(); // Skip null point
                SetNextDestination();
            }
        }
    }

    private void AdvancePatrolPoint()
    {
        if (manager.patrolRoute == null || manager.patrolRoute.patrolPoints.Count == 0) return;

        currentPatrolPointIndex = (currentPatrolPointIndex + 1) % manager.patrolRoute.patrolPoints.Count;
    }

    private int GetClosestPatrolPointIndex()
    {
        if (manager.patrolRoute == null || manager.patrolRoute.patrolPoints.Count == 0) return 0;

        int closestIndex = 0;
        float minDistance = float.MaxValue;

        for (int i = 0; i < manager.patrolRoute.patrolPoints.Count; i++)
        {
            if (manager.patrolRoute.patrolPoints[i] == null) continue;

            float distance = Vector3.Distance(manager.transform.position, manager.patrolRoute.patrolPoints[i].position);
            if (distance < minDistance)
            {
                minDistance = distance;
                closestIndex = i;
            }
        }
        return closestIndex;
    }

    public IEnemyState Transition()
    {
        if (manager.patrolRoute == null || manager.patrolRoute.patrolPoints.Count == 0)
        {
            return manager.idleState; // No path, go idle
        }

        if (manager.CurrentTarget != null)
        {
            return manager.chaseState;
        }
        return null;
    }

    public void Exit()
    {
        // Stop movement if transitioning out abruptly
        if (!isWaitingAtPoint) manager.Locomotion.StopMovement();
    }
}


--- END FILE: Characters\Enemy\States\PatrolState.cs ---

--- START FILE: Characters\Enemy\States\PerformingBackstabState.cs ---

using UnityEngine;

public class PerformingBackstabState : IEnemyState
{
    private EnemyManager manager;
    private bool animationFinishedNotified = false; // Flag set by animation event

    public void Enter(EnemyManager manager)
    {
        this.manager = manager;
        animationFinishedNotified = false;

        PlayerManager victim = manager.Combat.CurrentBackstabVictim as PlayerManager;

        if (victim == null)
        {
            Debug.LogError($"{manager.name} entered PerformingBackstabState but CurrentBackstabVictim is null or not PlayerManager. Exiting to CombatStance.");
            manager.SwitchState(manager.combatStanceState); // Failsafe, go back
            return;
        }

        manager.EnemyAnimator.IsInvulnerable = true;
        manager.Locomotion.DisableAgentAndPhysicsControl();

        // Snap enemy to player's backstab receiver point
        Transform victimReceiverPoint = victim.backstabReceiverPoint;
        manager.transform.position = victimReceiverPoint.position;

        // Enemy should look towards the player's core
        Vector3 lookAtTargetPos = victim.lockOnTransform != null ? victim.lockOnTransform.position : victim.transform.position + victim.transform.up * 1f;
        Vector3 directionToLook = lookAtTargetPos - manager.transform.position;
        directionToLook.y = 0;
        if (directionToLook != Vector3.zero) manager.transform.rotation = Quaternion.LookRotation(directionToLook);

        // Notify player they are being backstabbed
        victim.GetBackstabbed(manager.transform);

        // Play enemy's backstab animation
        manager.EnemyAnimator.PlayTargetAnimation(manager.Combat.backstabAction.animationName, true, 0.05f);

        Debug.Log($"{manager.name} entered PerformingBackstabState, executing backstab on {victim.name}.");
    }

    public void Tick()
    {
        // Logic is mostly driven by animation events.
        // If victim dies mid-animation, we might want to abort early.
        if (manager.Combat.CurrentBackstabVictim != null && manager.Combat.CurrentBackstabVictim.GetComponent<CharacterStats>().isDead)
        {
            // Victim died, perhaps prematurely end animation or ensure cleanup.
            // For now, let animation finish.
        }
    }

    public void FixedTick() { }

    // Called from EnemyManager via AnimEvent_FinishPerformingCriticalAction
    public void OnCriticalActionAnimationEnd()
    {
        animationFinishedNotified = true;
    }

    public IEnemyState Transition()
    {
        if (animationFinishedNotified)
        {
            if (manager.CurrentTarget == null || manager.Combat.CurrentBackstabVictim == null || manager.Combat.CurrentBackstabVictim.GetComponent<CharacterStats>().isDead)
            {
                return manager.idleState; // Target gone or dead
            }
            // After backstab, usually go back to combat stance
            return manager.combatStanceState;
        }
        return null;
    }

    public void Exit()
    {
        manager.charAnimManager.IsInMidAction = false;
        manager.EnemyAnimator.IsInvulnerable = false;
        manager.Locomotion.EnableAgentNavigation();
        manager.Combat.ClearBackstabVictim();
        // Set cooldown for the backstab action via Combat
        manager.Combat.SetGeneralAttackCooldown(manager.Combat.backstabAction.recoveryTime + Random.Range(manager.Combat.minAttackCooldown, manager.Combat.maxAttackCooldown));
        Debug.Log($"{manager.name} exited PerformingBackstabState.");
    }
}


--- END FILE: Characters\Enemy\States\PerformingBackstabState.cs ---

--- START FILE: Characters\Enemy\States\ReturnToPostState.cs ---

using UnityEngine;

public class ReturnToPostState : IEnemyState
{
    private EnemyManager manager;
    private float repathTimer;
    private const float repathInterval = 1.0f; // How often to re-check path if stuck

    public void Enter(EnemyManager manager)
    {
        this.manager = manager;
        Debug.Log($"{manager.name} entered ReturnToPostState, returning to {manager.initialPosition}.");

        manager.CurrentTarget = null; // Ensure no target is being tracked
        manager.Senses.ForceLoseTarget(); // Explicitly clear senses

        manager.Locomotion.EnableAgentNavigation();
        manager.Locomotion.SetAgentSpeed(manager.Locomotion.baseSpeed * 0.6f); // Slightly slower than normal walk
        manager.Locomotion.MoveToPoint(manager.initialPosition);
        repathTimer = repathInterval;
    }

    public void Tick()
    {
        // If senses pick up a target again while returning, transition immediately
        manager.Senses.TickSenses();

        repathTimer -= Time.deltaTime;
        if (repathTimer <= 0)
        {
            // Periodically re-issue the move command in case the agent got stuck or path invalidated
            if (!manager.Locomotion.HasReachedDestination)
            {
                manager.Locomotion.MoveToPoint(manager.initialPosition);
            }
            repathTimer = repathInterval;
        }
    }

    public void FixedTick()
    {
        // Rotation is handled by NavMeshAgent as it moves back
        // Or, if agent.updateRotation is false, you might want to rotate towards initialRotation when very close
        if (manager.Locomotion.HasReachedDestination)
        {
            // Smoothly orient to initial rotation
            manager.transform.rotation = Quaternion.Slerp(
                manager.transform.rotation,
                manager.initialRotation,
                manager.Locomotion.rotationSpeed * Time.fixedDeltaTime * 0.5f // Slower final orientation
            );
        }
    }

    public IEnemyState Transition()
    {
        // Priority 1: If a target is spotted while returning, go back to chasing
        if (manager.CurrentTarget != null)
        {
            return manager.chaseState;
        }

        // Priority 2: Reached destination
        if (manager.Locomotion.HasReachedDestination)
        {
            // Check if rotation is close enough to initialRotation
            if (Quaternion.Angle(manager.transform.rotation, manager.initialRotation) < 5.0f) // Threshold for orientation
            {
                Debug.Log($"{manager.name} has returned to post and oriented.");
                // Decide what to do next: Idle or Patrol
                if (manager.patrolRoute != null && manager.patrolRoute.patrolPoints.Count > 0)
                {
                    return manager.patrolState;
                }
                return manager.idleState;
            }
        }
        return null;
    }

    public void Exit()
    {
        // Ensure NavMeshAgent is stopped if transitioning out for another reason (like spotting target)
        if (manager.CurrentTarget != null) // Exiting because we spotted a target
        {
            manager.Locomotion.StopMovement();
        }
        // Agent speed and updateRotation will be set by the next state.
    }
}


--- END FILE: Characters\Enemy\States\ReturnToPostState.cs ---

--- START FILE: Characters\Player\PlayerAnimator.cs ---

using UnityEngine;

public class PlayerAnimator : AnimatorManager
{
    public readonly int hashVertical = Animator.StringToHash("Vertical");
    public readonly int hashHorizontal = Animator.StringToHash("Horizontal");
    public readonly int hashTriggerAttack = Animator.StringToHash("Attack");

    private PlayerLocomotion playerLocomotion;
    private PlayerManager playerManager;
    private CameraController cameraController;
    private WeaponSlotManager weaponSlotManager;

    public bool CanRotate { get; set; } = true;

    public bool IsTwoHanding
    {
        get => GetAnimatorBool();
        set => SetAnimatorBool(value);
    }

    public bool IsDodging
    {
        get => GetAnimatorBool();
        set => SetAnimatorBool(value);
    }

    public bool IsCrouching
    {
        get => GetAnimatorBool();
        set => SetAnimatorBool(value);
    }

    public bool CanDoCombo
    {
        get => GetAnimatorBool();
        set => SetAnimatorBool(value);
    }

    public bool IsGrounded
    {
        get => GetAnimatorBool();
        set => SetAnimatorBool(value);
    }
    
    public bool IsInAir
    {
        get => GetAnimatorBool();
        set => SetAnimatorBool(value);
    }

    public int RollDirection
    {
        get => GetAnimatorInt();
        set => SetAnimatorInt(value);
    }

    public void Initialize()
    {
        anim = GetComponent<Animator>();
        playerLocomotion = GetComponentInParent<PlayerLocomotion>();
        playerManager = GetComponentInParent<PlayerManager>();
        cameraController = FindObjectOfType<CameraController>();
        weaponSlotManager = GetComponentInParent<WeaponSlotManager>();

        if (playerManager == null) Debug.LogError("PlayerManager not found in parent", this);
        if (playerLocomotion == null) Debug.LogError("PlayerLocomotion not found in parent", this);
        if (cameraController == null) Debug.LogError("CameraController not found in scene", this);
        if (weaponSlotManager == null) Debug.LogError("WeaponSlotManager not found in scene", this);
    }

    public void OnAnimatorMove()
    {
        // Only apply root motion if playerManager says they are in an action that *should* use it.
        // And if not in air where root motion can be problematic unless specifically designed for it.
        if (playerManager != null && IsInMidAction && IsGrounded)
        {
            if (anim != null && anim.applyRootMotion)
            {
                float deltaTime = Time.deltaTime;
                if (deltaTime > 0)
                {
                    playerLocomotion.rigidbody.drag = 0;
                    Vector3 deltaPosition = anim.deltaPosition;
                    deltaPosition.y = 0; // Comment this out IF the animation (like a hop in an attack) has intentional Y movement
                    Vector3 velocity = deltaPosition / deltaTime;
                    playerLocomotion.rigidbody.velocity = new Vector3(velocity.x, playerLocomotion.rigidbody.velocity.y, velocity.z);
                    playerLocomotion.transform.rotation *= anim.deltaRotation;

                    if (CanRotate) // If manual rotation is generally allowed by PlayerLocomotion during this action
                    {
                        // Manual rotation is handled by PlayerLocomotion.HandleRotation()
                        // Do nothing here with anim.deltaRotation.
                    }
                    else // Animation has explicitly set canRotate = false, so root motion rotation should dominate
                    {
                        playerLocomotion.transform.rotation *= anim.deltaRotation;
                    }
                }
            }
        }
    }


    public void UpdateAnimatorValues(float verticalInput, float horizontalInput, bool isSprinting, bool isCrouching, bool isLockedOn)
    {
        if (anim == null || playerManager == null || cameraController == null) return;

        float v = 0; // Vertical output for animator
        float h = 0; // Horizontal output for animator

        if (isLockedOn && !isSprinting && !isCrouching) // Locked-on standard movement (not sprinting/crouching)
        {
            // Input is already player-relative (forward/strafe)
            v = verticalInput;
            h = horizontalInput;
        }
        else // Free-look, or Sprinting/Crouching (even if locked on, these might use camera-relative for freedom)
        {
            // Convert camera-relative input to player-local space for the animator
            Vector3 moveDirWorld = (cameraController.transform.forward * verticalInput) + (cameraController.transform.right * horizontalInput);
            moveDirWorld.y = 0;
            moveDirWorld.Normalize();

            if (moveDirWorld.sqrMagnitude > 0.01f)
            {
                Vector3 moveDirLocal = playerManager.transform.InverseTransformDirection(moveDirWorld);
                v = moveDirLocal.z;
                h = moveDirLocal.x;
            }
            else // No input
            {
                v = 0;
                h = 0;
            }
        }

        // Apply sprinting multiplier if applicable
        if (isSprinting && v > 0.5f && !isCrouching)
        {
            v = 2f;
        }

        // Crouching state is handled by a separate animator bool usually,
        // but v and h still determine crouch walk/strafe direction within the crouch blend tree/layer.
        // No specific change to v, h needed here just for crouching itself,
        // unless your crouch animations are at different 'speed' values in the blend tree (e.g., crouch walk at v=0.25)
        // If so, you'd scale v and h here when isCrouching is true.
        // For example: if (isCrouching) { v *= 0.5f; h *= 0.5f; } // If crouch anims are at half magnitude

        anim.SetFloat(hashVertical, v, 0.1f, Time.deltaTime);
        anim.SetFloat(hashHorizontal, h, 0.1f, Time.deltaTime);
        IsCrouching = isCrouching;
    }

    public void PlayTargetAnimation(string targetAnim, bool isPlayerInAction, float crossFadeDuration = 0.1f, bool? rootMotion = null)
    {
        if (anim == null) return;
        IsInMidAction = isPlayerInAction;
        anim.applyRootMotion = rootMotion ?? isPlayerInAction; // General rule, can be overridden by specific anims
        anim.CrossFade(targetAnim, crossFadeDuration);
    }

    public void EnableRotation() => CanRotate = true;

    public void DisableRotation() => CanRotate = false;

    public void SetBool(string paramName, bool value)
    {
        if (anim != null) anim.SetBool(paramName, value);
    }

    public void EnableCombo() => CanDoCombo = true;
    public void DisableCombo() => CanDoCombo = false;

    public void TriggerAttack()
    {
        anim.SetTrigger(hashTriggerAttack);
    }

    public void EnableInvulnerability() => IsInvulnerable = true;
    public void DisableInvulnerability() => IsInvulnerable = false;

    public void OnDodgeAnimationEnd() => playerLocomotion.OnDodgeAnimationEnd();

    public void AnimEvent_FinishAction() => IsInMidAction = false;

    public void AnimEvent_ApplyBackstabDamage()
    {
        if (playerManager != null)
        {
            playerManager.AnimEvent_ApplyBackstabDamage();
        }
        else
        {
            Debug.LogError("AnimatorHandler: AnimEvent_ApplyBackstabDamage called, but PlayerManager is null!", this);
        }
    }

    public void AnimEvent_FinishPerformingBackstab()
    {
        if (playerManager != null)
        {
            playerManager.AnimEvent_FinishPerformingBackstab();
        }
        else
        {
            Debug.LogError("AnimatorHandler: AnimEvent_FinishPerformingBackstab called, but PlayerManager is null!", this);
        }
    }

    public void AnimEvent_FinishBeingBackstabbed()
    {
        if (playerManager != null)
        {
            playerManager.FinishBeingBackstabbed();
        }
        else
        {
            Debug.LogError("AnimEvent_FinishBeingBackstabbed called, but PlayerManager is null!", this);
        }
    }

    public void AnimEvent_ApplyJumpForce()
    {
        if (playerLocomotion != null)
        {
            playerLocomotion.TriggerApplyJumpForce();
        }
    }

    public void AnimEvent_FinishJumpAction() // Called from Jump_End animation
    {
        if (playerLocomotion != null)
        {
            playerLocomotion.FinishJumpAction();
        }
    }

    public void AnimEvent_OpenDamageCollider_RH()
    {
        weaponSlotManager?.OpenRightHandDamageCollider();
    }

    public void AnimEvent_CloseDamageCollider_RH()
    {
        weaponSlotManager?.CloseRightHandDamageCollider();
    }

    public void AnimEvent_DrainLightAttackStamina()
    {
        if (weaponSlotManager != null && playerManager.playerInventory.EquippedRightWeapon != null)
            weaponSlotManager?.DrainStaminaForAttack(PlayerAttackType.LightAttack);
    }
    public void AnimEvent_DrainRollAttackStamina()
    {
        if (weaponSlotManager != null && playerManager.playerInventory.EquippedRightWeapon != null)
            weaponSlotManager?.DrainStaminaForAttack(PlayerAttackType.RollAttack);
    }
    public void AnimEvent_DrainBackstepAttackStamina()
    {
        if (weaponSlotManager != null && playerManager.playerInventory.EquippedRightWeapon != null)
            weaponSlotManager?.DrainStaminaForAttack(PlayerAttackType.BackstepAttack);
    }
    public void AnimEvent_DrainJumpAttackStamina()
    {
        if (weaponSlotManager != null && playerManager.playerInventory.EquippedRightWeapon != null)
            weaponSlotManager?.DrainStaminaForAttack(PlayerAttackType.JumpAttack);
    }
}


--- END FILE: Characters\Player\PlayerAnimator.cs ---

--- START FILE: Characters\Player\PlayerAttacker.cs ---

using UnityEngine;

public class PlayerAttacker : MonoBehaviour
{
    private PlayerAnimator playerAnimator;
    private WeaponSlotManager weaponSlotManager;
    private PlayerManager playerManager;
    private PlayerStats playerStats;
    private PlayerInventory playerInventory;

    [Header("Backstab Settings")]
    [SerializeField] private float backstabRaycastDistance = 1.5f;
    [SerializeField] private float backstabMaxInteractionDistance = .6f;
    [SerializeField] private float backstabMaxAngle = 45f;
    [SerializeField] private LayerMask backstabLayerMask;
    [SerializeField] private string playerBackstabAnimation = "Backstab_Main_01";
    //[SerializeField] private float playerSnapSpeed = 15f;

    private PlayerAttackType currentAttackTypePerforming = PlayerAttackType.None;

    private void Awake()
    {
        playerAnimator = GetComponentInChildren<PlayerAnimator>();
        weaponSlotManager = GetComponentInChildren<WeaponSlotManager>();
        playerManager = GetComponent<PlayerManager>();
        playerStats = GetComponent<PlayerStats>();
        playerInventory = GetComponent<PlayerInventory>();

        if (backstabLayerMask == 0) // If not set in inspector
        {
            Debug.LogError("Backstab LayerMask not set on PlayerAttacker. Backstabs may not work.", this);
        }
    }

    public void HandleAttackButton()
    {
        if (playerAnimator.IsInMidAction && !playerAnimator.CanDoCombo)
            return;

        WeaponItem currentWeapon = playerInventory.EquippedRightWeapon ?? playerInventory.unarmedWeaponData;

        weaponSlotManager.attackingWeapon = currentWeapon;

        if (!playerAnimator.IsInMidAction && playerAnimator.IsGrounded && TryPerformBackstab())
        {
            playerAnimator.IsCrouching = false; // Stand up for backstab
            return;
        }

        PerformAttack(currentWeapon);
    }

    public void PerformAttack(WeaponItem weapon)
    {
        if (weapon == null) return;

        playerAnimator.IsInMidAction = true;
        playerAnimator.ApplyRootMotion(true);

        if (playerManager.playerAnimator.IsInAir)
        {
            currentAttackTypePerforming = PlayerAttackType.JumpAttack;
        }
        else if (playerManager.playerAnimator.IsDodging)
        {
            currentAttackTypePerforming = playerManager.playerAnimator.RollDirection == -1 ?
                PlayerAttackType.BackstepAttack : PlayerAttackType.RollAttack;
        }
        else
        {
            currentAttackTypePerforming = PlayerAttackType.LightAttack;
        }

        playerAnimator.TriggerAttack();
    }

    public void ProcessHit(Collider victimCollider, WeaponItem attackingWeaponUsed)
    {
        if (attackingWeaponUsed == null)
        {
            Debug.LogWarning("PlayerAttacker.ProcessHit: attackingWeaponUsed is null.");
            return;
        }

        int finalDamage = playerStats.CalculateAttackDamage(attackingWeaponUsed, currentAttackTypePerforming);

        // Apply to Enemy
        if (victimCollider.CompareTag("Enemy"))
        {
            EnemyStats enemyStats = victimCollider.GetComponent<EnemyStats>();
            if (enemyStats != null && !enemyStats.isDead)
            {
                Debug.Log($"Player's [{currentAttackTypePerforming}] with [{attackingWeaponUsed.name}] hit Enemy [{victimCollider.name}] for {finalDamage} damage.");
                enemyStats.TakeDamage(finalDamage, DamageType.Standard, playerManager.transform);
            }
        }
        // TODO: add logic for hitting other damageable objects if they have different tags/components
    }

    private bool TryPerformBackstab()
    {
        // Raycast forward from player's approximate chest height
        Vector3 rayOrigin = (playerManager.lockOnTransform != null ? playerManager.lockOnTransform.position : playerManager.transform.position + Vector3.up * 1f);

        RaycastHit[] hits = Physics.SphereCastAll(rayOrigin, 0.5f, playerManager.transform.forward, backstabRaycastDistance, backstabLayerMask, QueryTriggerInteraction.Ignore);

        if (hits.Length == 0) return false;

        // Find the closest valid CharacterManager that can be backstabbed
        CharacterManager potentialVictim = null;
        float closestVictimDistance = float.MaxValue;

        foreach (var hit in hits)
        {
            // Ensure we're not hitting ourselves if player is on the backstabLayerMask for some reason
            if (hit.transform.root == playerManager.transform.root) continue;

            CharacterManager targetCharManager = hit.collider.GetComponentInParent<CharacterManager>();
            if (targetCharManager != null && targetCharManager.canBeBackstabbed && !targetCharManager.charAnimManager.IsInMidAction)
            {
                float distanceToHitPoint = Vector3.Distance(playerManager.transform.position, hit.point);
                if (distanceToHitPoint < closestVictimDistance) // Prioritize by actual hit point for spherecast
                {
                    closestVictimDistance = distanceToHitPoint;
                    potentialVictim = targetCharManager;
                }
            }
        }

        if (potentialVictim == null) return false;

        // Check angle and precise distance to the victim's backstab receiver point
        Vector3 directionToVictimReceiver = (potentialVictim.backstabReceiverPoint.position - playerManager.transform.position);
        float distanceToReceiver = directionToVictimReceiver.magnitude;

        if (distanceToReceiver > backstabMaxInteractionDistance)
        {
            return false;
        }

        // Angle check: Player needs to be behind the enemy.
        // Vector from enemy's forward to the player.
        Vector3 victimForward = potentialVictim.transform.forward;
        Vector3 playerRelativePos = playerManager.transform.position - potentialVictim.transform.position;
        playerRelativePos.y = 0; // Flatten for pure horizontal angle
        victimForward.y = 0;     // Flatten

        float angle = Vector3.Angle(victimForward, playerRelativePos.normalized * -1f); // * -1f because we want angle to enemy's back

        if (angle <= backstabMaxAngle)
        {
            ExecuteBackstab(potentialVictim);
            return true;
        }

        return false;
    }

    private void ExecuteBackstab(CharacterManager victim)
    {
        Debug.Log($"Executing backstab on {victim.name}");
        playerAnimator.IsInMidAction = true;
        playerAnimator.IsInvulnerable = true;
        //playerManager.isBeingCriticallyHit = true; // Player is also in a critical sequence
        playerManager.currentBackstabTarget = victim;

        // Snap player to victim's backstab receiver point.
        // The receiver point on the enemy should be positioned where the player *stands* to initiate the backstab.
        // The player should then look towards the enemy's core.
        Vector3 snapPosition = victim.backstabReceiverPoint.position;
        Quaternion snapRotation = Quaternion.LookRotation(victim.transform.position - snapPosition);

        // Coroutine for smooth snapping (optional, direct set is simpler to start)
        // StartCoroutine(SmoothSnap(snapPosition, snapRotation));
        playerManager.transform.position = snapPosition; // Direct snap for now
        playerManager.transform.rotation = snapRotation; // Direct snap


        // Tell victim they are being backstabbed. Victim handles its own animation and orientation.
        victim.GetBackstabbed(playerManager.transform); // Pass player's transform as attacker

        // Play player's backstab animation
        playerAnimator.PlayTargetAnimation(playerBackstabAnimation, true);

        // Animation events on playerBackstabAnimation will call:
        // 1. PlayerManager.AnimEvent_ApplyBackstabDamage()
        // 2. PlayerManager.AnimEvent_FinishPerformingBackstab()
    }
}


--- END FILE: Characters\Player\PlayerAttacker.cs ---

--- START FILE: Characters\Player\PlayerInventory.cs ---

using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

public class PlayerInventory : MonoBehaviour
{
    public static event Action OnInventoryUpdated; // Fire when any item is added/removed
    public static event Action OnEquipmentUpdated; // Fire when any equipped item changes

    [Header("Core References")]
    [SerializeField] private WeaponSlotManager weaponSlotManager;
    [SerializeField] public WeaponItem unarmedWeaponData;

    // --- Equipped Items ---
    [Header("Current Loadout")]
    public WeaponItem[] rightHandWeaponSlots = new WeaponItem[4];
    public Item leftHandItem; // Could be a shield or other item later
    public ArmorItem headArmor, bodyArmor, handArmor, legArmor;
    public TalismanItem[] talismanSlots = new TalismanItem[4];

    [Tooltip("The list of consumables available for quick cycling.")]
    public List<InventorySlot> consumableQuickSlots = new ();
    [SerializeField] private int maxConsumableQuickSlots = 8;

    public int CurrentRightWeaponIndex { get; private set; } = 0;
    public int CurrentConsumableIndex { get; private set; } = 0;

    public WeaponItem EquippedRightWeapon => (CurrentRightWeaponIndex >= 0 && CurrentRightWeaponIndex < rightHandWeaponSlots.Length) ? rightHandWeaponSlots[CurrentRightWeaponIndex] : null;
    public InventorySlot CurrentConsumableSlot => GetSlotAtIndex(CurrentConsumableIndex);
    public InventorySlot NextConsumableSlot => GetNextValidSlot(CurrentConsumableIndex);

    // --- Master Item Lists ---
    [Header("Collected Items")]
    public List<InventorySlot> weaponsInventory = new();
    public List<InventorySlot> armorInventory = new();
    public List<InventorySlot> talismanInventory = new();
    public List<InventorySlot> consumableInventory = new();

    [Header("Flasks")]
    public HealthConsumable healingFlaskSO;
    public int maxFlaskCharges = 3;
    private InventorySlot _healingFlaskSlot;

    private PlayerManager playerManager;

    private void Awake()
    {
        if (weaponSlotManager == null) weaponSlotManager = GetComponentInChildren<WeaponSlotManager>();
        if (unarmedWeaponData == null) Debug.LogError("PlayerInventory: Unarmed Weapon Data not assigned!");

        playerManager = GetComponent<PlayerManager>();

        for (int i = 0; i < maxConsumableQuickSlots; i++)
        {
            consumableQuickSlots.Add(null);
        }
    }

    private void Start()
    {
        InitializeFlasks();
        EquipWeapon(CurrentRightWeaponIndex);
        OnEquipmentUpdated?.Invoke();
    }

    private void OnEnable()
    {
        InputHandler.DPadRightButtonPressed += CycleNextWeapon;
        InputHandler.DPadUpButtonPressed += UseCurrentConsumable;
        InputHandler.DPadDownButtonPressed += CycleNextConsumable;
    }

    private void OnDisable()
    {
        InputHandler.DPadRightButtonPressed -= CycleNextWeapon;
        InputHandler.DPadUpButtonPressed -= UseCurrentConsumable;
        InputHandler.DPadDownButtonPressed -= CycleNextConsumable;
    }

    private void InitializeFlasks()
    {
        _healingFlaskSlot = consumableInventory.FirstOrDefault(slot => slot?.item == healingFlaskSO);
        if (_healingFlaskSlot == null)
        {
            _healingFlaskSlot = new InventorySlot(healingFlaskSO, maxFlaskCharges);
            consumableInventory.Add(_healingFlaskSlot);
        }
        else
        {
            _healingFlaskSlot.quantity = maxFlaskCharges;
        }

        // Equip flask to the first empty quick slot, or slot 0 if it's empty
        int firstEmptySlot = consumableQuickSlots.FindIndex(s => s == null);
        if (firstEmptySlot != -1)
        {
            consumableQuickSlots[firstEmptySlot] = _healingFlaskSlot;
        }
    }

    public void RefillFlasks()
    {
        if (_healingFlaskSlot != null)
        {
            _healingFlaskSlot.quantity = maxFlaskCharges;
            OnInventoryUpdated?.Invoke(); // Notify UI to update flask count
        }
    }

    public void AddItem(Item item, int quantity = 1)
    {
        if (item == null || quantity <= 0) return;

        List<InventorySlot> targetInventory = GetInventoryListForItemType(item);
        if (targetInventory == null) return;

        // Find if the item already exists in the inventory
        InventorySlot existingSlot = targetInventory.FirstOrDefault(slot => slot.item == item);

        if (existingSlot != null)
        {
            // Add to existing stack
            existingSlot.AddQuantity(quantity);
        }
        else
        {
            // Create a new stack
            targetInventory.Add(new InventorySlot(item, quantity));
        }

        OnInventoryUpdated?.Invoke();
    }

    public void RemoveItem(Item item, int quantity = 1)
    {
        if (item == null || quantity <= 0) return;

        List<InventorySlot> targetInventory = GetInventoryListForItemType(item);
        if (targetInventory == null) return;

        InventorySlot existingSlot = targetInventory.FirstOrDefault(slot => slot.item == item);
        if (existingSlot != null)
        {
            existingSlot.RemoveQuantity(quantity);
            if (existingSlot.quantity <= 0)
            {
                // Also check if this item is in any quick slots and clear them
                for (int i = 0; i < consumableQuickSlots.Count; i++)
                {
                    if (consumableQuickSlots[i]?.item == item)
                    {
                        consumableQuickSlots[i] = null;
                    }
                }
                targetInventory.Remove(existingSlot);
                OnEquipmentUpdated?.Invoke(); // Fire this too, in case it was a quick-slotted item
            }
        }

        OnInventoryUpdated?.Invoke();
    }

    private List<InventorySlot> GetInventoryListForItemType(Item item)
    {
        return item switch
        {
            WeaponItem => weaponsInventory,
            ArmorItem => armorInventory,
            TalismanItem => talismanInventory,
            ConsumableItem => consumableInventory,
            _ => null
        };
    }

    // --- Equipment Management ---

    public void EquipWeapon(int slotIndex)
    {
        if (slotIndex < 0 || slotIndex >= rightHandWeaponSlots.Length) return;

        CurrentRightWeaponIndex = slotIndex;
        WeaponItem weaponToEquip = rightHandWeaponSlots[CurrentRightWeaponIndex] ?? unarmedWeaponData;
        weaponSlotManager.LoadWeaponOnSlot(weaponToEquip, true);
        OnEquipmentUpdated?.Invoke();
    }

    public void EquipArmor(ArmorItem armor)
    {
        if (armor == null) return;
        switch (armor.armorType)
        {
            case ArmorType.Head: headArmor = armor; break;
            case ArmorType.Body: bodyArmor = armor; break;
            case ArmorType.Hands: handArmor = armor; break;
            case ArmorType.Legs: legArmor = armor; break;
        }
        // TODO: Logic to visually change player model
        OnEquipmentUpdated?.Invoke();
    }

    // Similar EquipTalisman, EquipConsumable methods...

    public Item GetItemInSlot(EquipmentSlotCategory category, int slotIndex)
    {
        switch (category)
        {
            case EquipmentSlotCategory.RightHand:
                return slotIndex >= 0 && slotIndex < rightHandWeaponSlots.Length ? rightHandWeaponSlots[slotIndex] : null;
            case EquipmentSlotCategory.Head: return headArmor;
            case EquipmentSlotCategory.Body: return bodyArmor;
            case EquipmentSlotCategory.Hands: return handArmor;
            case EquipmentSlotCategory.Legs: return legArmor;
            case EquipmentSlotCategory.Talisman:
                return slotIndex >= 0 && slotIndex < talismanSlots.Length ? talismanSlots[slotIndex] : null;

            case EquipmentSlotCategory.Consumable:
                return slotIndex >= 0 && slotIndex < consumableQuickSlots.Count && consumableQuickSlots[slotIndex] != null
                    ? consumableQuickSlots[slotIndex].item
                    : null;

            default:
                return null;
        }
    }

    // --- Action Handlers ---

    private void CycleNextWeapon()
    {
        if (playerManager.playerAnimator.IsInMidAction) return;

        ChangeWeapon(1);
    }

    private void ChangeWeapon(int direction)
    {
        if (playerManager.playerAnimator.IsInMidAction) return;
        if (rightHandWeaponSlots.All(slot => slot == null)) { EquipWeapon(CurrentRightWeaponIndex); return; }

        int nextIndex = CurrentRightWeaponIndex;
        for (int i = 0; i < rightHandWeaponSlots.Length; i++)
        {
            nextIndex = (nextIndex + direction + rightHandWeaponSlots.Length) % rightHandWeaponSlots.Length;
            if (rightHandWeaponSlots[nextIndex] != null)
            {
                EquipWeapon(nextIndex);
                return;
            }
        }
    }

    public void UseConsumable(InventorySlot consumableSlot)
    {
        if (consumableSlot?.item == null || consumableSlot.quantity <= 0 || playerManager.playerAnimator.IsInMidAction) return;
        var consumable = consumableSlot.item as ConsumableItem;
        if (consumable == null) return;

        consumable.Use(playerManager);

        if (consumableSlot.item != healingFlaskSO) RemoveItem(consumableSlot.item, 1);
        else _healingFlaskSlot.RemoveQuantity(1);

        OnInventoryUpdated?.Invoke();
    }

    public bool IsItemEquipped(Item item)
    {
        if (item == null) return false;

        // Check weapon slots
        if (item is WeaponItem)
        {
            if (rightHandWeaponSlots.Contains(item as WeaponItem)) return true;
        }
        // Check armor slots
        if (item is ArmorItem armor)
        {
            if (headArmor == armor || bodyArmor == armor || handArmor == armor || legArmor == armor) return true;
        }
        // Check talisman slots
        if (item is TalismanItem)
        {
            if (talismanSlots.Contains(item as TalismanItem)) return true;
        }
        // Check consumable slots
        if (item is ConsumableItem)
        {
            if (consumableQuickSlots.Select(slot => slot?.item).Contains(item)) return true;
        }
        // Check left hand item
        if (leftHandItem == item) return true;

        return false;
    }

    public void EquipItem(Item item, EquipmentSlotCategory category, int slotIndex)
    {
        UnequipItem(item);
        switch (category)
        {
            case EquipmentSlotCategory.RightHand:
                if (item is WeaponItem weapon && slotIndex < rightHandWeaponSlots.Length)
                {
                    rightHandWeaponSlots[slotIndex] = weapon;
                    if (CurrentRightWeaponIndex == slotIndex) EquipWeapon(slotIndex);
                }
                break;
            case EquipmentSlotCategory.Head: if (item is ArmorItem h) headArmor = h; break;
            case EquipmentSlotCategory.Body: if (item is ArmorItem b) bodyArmor = b; break;
            case EquipmentSlotCategory.Hands: if (item is ArmorItem ha) handArmor = ha; break;
            case EquipmentSlotCategory.Legs: if (item is ArmorItem l) legArmor = l; break;
            case EquipmentSlotCategory.Talisman:
                if (item is TalismanItem t && slotIndex < talismanSlots.Length) talismanSlots[slotIndex] = t;
                break;
            case EquipmentSlotCategory.Consumable:
                if (item is ConsumableItem c && slotIndex < consumableQuickSlots.Count)
                {
                    InventorySlot sourceSlot = consumableInventory.FirstOrDefault(s => s?.item == c);
                    consumableQuickSlots[slotIndex] = sourceSlot;
                }
                break;
        }
        OnEquipmentUpdated?.Invoke();
    }

    public void UnequipItem(Item item)
    {
        if (item == null) return;

        // Check weapon slots
        for (int i = 0; i < rightHandWeaponSlots.Length; i++)
        {
            if (rightHandWeaponSlots[i] == item)
            {
                rightHandWeaponSlots[i] = null;
                // If it was the active weapon, re-equip to trigger unarmed state
                if (CurrentRightWeaponIndex == i) EquipWeapon(i);
            }
        }

        // Check armor slots
        if (headArmor == item) headArmor = null;
        if (bodyArmor == item) bodyArmor = null;
        if (handArmor == item) handArmor = null;
        if (legArmor == item) legArmor = null;

        // Check talisman slots
        for (int i = 0; i < talismanSlots.Length; i++)
        {
            if (talismanSlots[i] == item) talismanSlots[i] = null;
        }

        // Check consumable quick slots
        for (int i = 0; i < consumableQuickSlots.Count; i++)
        {
            if (consumableQuickSlots[i]?.item == item)
            {
                consumableQuickSlots[i] = null;
            }
        }
    }

    public void UnequipItemFromSlot(EquipmentSlotCategory category, int slotIndex)
    {
        bool changed = false;
        switch (category)
        {
            case EquipmentSlotCategory.RightHand:
                if (slotIndex < rightHandWeaponSlots.Length && rightHandWeaponSlots[slotIndex] != null)
                {
                    rightHandWeaponSlots[slotIndex] = null;
                    if (CurrentRightWeaponIndex == slotIndex) // If we unequipped the active weapon
                    {
                        EquipWeapon(slotIndex); // This will re-evaluate and load unarmed
                    }
                    changed = true;
                }
                break;
            case EquipmentSlotCategory.Armor:
                Debug.LogWarning("UnequipItemFromSlot called with generic 'Armor' category. Please specify Head, Body, etc.");
                break;
            case EquipmentSlotCategory.Head: if (headArmor != null) { headArmor = null; changed = true; } break;
            case EquipmentSlotCategory.Body: if (bodyArmor != null) { bodyArmor = null; changed = true; } break;
            case EquipmentSlotCategory.Hands: if (handArmor != null) { handArmor = null; changed = true; } break;
            case EquipmentSlotCategory.Legs: if (legArmor != null) { legArmor = null; changed = true; } break;

            case EquipmentSlotCategory.Talisman:
                if (slotIndex >= 0 && slotIndex < talismanSlots.Length && talismanSlots[slotIndex] != null)
                {
                    talismanSlots[slotIndex] = null;
                    changed = true;
                }
                break;
            case EquipmentSlotCategory.Consumable:
                if (slotIndex < consumableQuickSlots.Count && consumableQuickSlots[slotIndex] != null)
                {
                    consumableQuickSlots[slotIndex] = null;
                    changed = true;
                }
                break;
        }

        if (changed)
        {
            OnEquipmentUpdated?.Invoke();
        }
    }

    public void AssignConsumableToQuickSlot(InventorySlot consumableSlot)
    {
        if (consumableSlot == null || consumableSlot.item as ConsumableItem == null) return;
        if (!consumableQuickSlots.Contains(consumableSlot))
        {
            consumableQuickSlots.Add(consumableSlot);
            OnEquipmentUpdated?.Invoke();
        }
    }

    public void RemoveConsumableFromQuickSlot(InventorySlot consumableSlot)
    {
        if (consumableSlot == null) return;
        if (consumableQuickSlots.Contains(consumableSlot))
        {
            consumableQuickSlots.Remove(consumableSlot);
            // Adjust index if we removed the current or a previous slot
            if (CurrentConsumableIndex >= consumableQuickSlots.Count && consumableQuickSlots.Count > 0)
            {
                CurrentConsumableIndex = consumableQuickSlots.Count - 1;
            }
            OnEquipmentUpdated?.Invoke();
        }
    }

    public void CycleNextConsumable()
    {
        if (playerManager.playerAnimator.IsInMidAction) return;
        int nextValidIndex = FindNextValidConsumableSlot(1);
        if (nextValidIndex != -1)
        {
            CurrentConsumableIndex = nextValidIndex;
            OnEquipmentUpdated?.Invoke();
        }
    }

    private int FindNextValidConsumableSlot(int direction)
    {
        if (consumableQuickSlots.All(slot => slot == null)) return -1;
        int nextIndex = CurrentConsumableIndex;
        for (int i = 0; i < consumableQuickSlots.Count; i++)
        {
            nextIndex = (nextIndex + direction + consumableQuickSlots.Count) % consumableQuickSlots.Count;
            if (consumableQuickSlots[nextIndex] != null) return nextIndex;
        }
        return CurrentConsumableIndex; // Fallback to current if it's the only one
    }

    private void UseCurrentConsumable()
    {
        InventorySlot slotToUse = CurrentConsumableSlot;
        if (slotToUse == null) return;
        UseConsumable(slotToUse);
    }

    private InventorySlot GetSlotAtIndex(int index)
    {
        if (consumableQuickSlots == null || consumableQuickSlots.Count == 0 || index < 0 || index >= consumableQuickSlots.Count) return null;
        return consumableQuickSlots[index];
    }

    private InventorySlot GetNextValidSlot(int startIndex)
    {
        if (consumableQuickSlots.Count(s => s != null) <= 1) return null; // No "next" if 0 or 1 items
        int nextValidIndex = FindNextValidConsumableSlot(1);
        return consumableQuickSlots[nextValidIndex];
    }

    public void DropItem(Item item)
    {
        if (item == null || !item.isDroppable || item.itemPickupPrefab == null)
        {
            Debug.LogWarning($"Cannot drop item: {item?.itemName ?? "NULL"}");
            return;
        }

        // Instantiate the pickup prefab in front of the player
        Vector3 dropPosition = transform.position + transform.forward * 1.5f + Vector3.up * 0.5f;
        GameObject droppedItemGO = Instantiate(item.itemPickupPrefab, dropPosition, Quaternion.identity);

        // Ensure the pickup script on the prefab knows which item it contains
        ItemPickUp pickupScript = droppedItemGO.GetComponent<ItemPickUp>();
        if (pickupScript != null)
        {
            pickupScript.SetItem(item);
        }

        // Remove from inventory
        RemoveItem(item, 1);
    }
}

--- END FILE: Characters\Player\PlayerInventory.cs ---

--- START FILE: Characters\Player\PlayerManager.cs ---

using System.Collections.Generic;
using UnityEngine;

public struct Commands
{
    public ICommand AttackCommand;
    public ICommand JumpCommand;
    public ICommand DodgeCommand;
    public ICommand SprintHoldCommand;
    public ICommand SprintReleaseCommand;
    public ICommand CrouchCommand;
};

public class PlayerManager : CharacterManager
{
    public InteractableUI interactableUI;
    private PlayerStats playerStats;

    public PlayerAttacker playerAttacker;
    public PlayerLocomotion playerLocomotion;
    public PlayerInventory playerInventory;
    public PlayerAnimator playerAnimator;

    [Header("Player Flags")]
    public bool isSprinting;

    private bool isPickingUp = false;
    private bool pickedUpItem = false;

    private readonly List<Interactable> nearbyInteractables = new ();

    // Command buffering
    private ICommand pendingCommand;
    private Commands commands;
    [SerializeField] private float pendingCommandInterval = 0.2f;
    private float pendingCommandTimer;

    public CharacterManager currentBackstabTarget;

    protected override void Awake()
    {
        base.Awake();
        playerStats = GetComponent<PlayerStats>();
        playerInventory = GetComponent<PlayerInventory>();
        charAnimator = GetComponentInChildren<Animator>();
        playerAnimator = GetComponentInChildren<PlayerAnimator>();
        playerLocomotion = GetComponent<PlayerLocomotion>();
        playerAttacker = GetComponent<PlayerAttacker>();
        interactableUI = FindObjectOfType<InteractableUI>();
    }

    private void Start()
    {
        InitCommands();
    }

    private void Update()
    {
        // Execute pending command when action ends
        if (pendingCommand != null)
        {
            if (pendingCommand.CanExecute())
            {
                pendingCommand.Execute();
                pendingCommand = null;
            }
            
            pendingCommandTimer -= Time.deltaTime;
            if (pendingCommandTimer < 0)
            {
                pendingCommand = null;
            }
        }

        HandleInteractableUI();
    }

    private void LateUpdate()
    {
        if (playerAnimator.IsInAir)
        {
            playerLocomotion.inAirTimer += Time.deltaTime;
        }
    }

    private void OnEnable()
    {
        InputHandler.InteractButtonPressed += HandleInteractButtonPressed;
        InputHandler.JumpButtonPressed += HandleJumpInput;
        InputHandler.DodgeTapped += HandleDodgeButton;
        InputHandler.SprintHolding += HandleSprintHolding;
        InputHandler.SprintReleased += HandleSprintReleased;
        InputHandler.CrouchButtonPressed += HandleCrouchInput;
        InputHandler.AttackButtonPressed += HandleAttackInput;
    }

    private void OnDisable()
    {
        InputHandler.InteractButtonPressed -= HandleInteractButtonPressed;
        InputHandler.JumpButtonPressed -= HandleJumpInput;
        InputHandler.DodgeTapped -= HandleDodgeButton;
        InputHandler.SprintHolding -= HandleSprintHolding;
        InputHandler.SprintReleased -= HandleSprintReleased;
        InputHandler.CrouchButtonPressed -= HandleCrouchInput;
        InputHandler.AttackButtonPressed -= HandleAttackInput;
    }

    private void InitCommands()
    {
        commands = new Commands
        {
            AttackCommand = new RelayCommand(
                () => playerStats.CanPerformStaminaConsumingAction() &&
                    (!playerAnimator.IsInMidAction || playerAnimator.CanDoCombo),
                playerAttacker.HandleAttackButton),

            JumpCommand = new RelayCommand(
                () => playerStats.CanPerformStaminaConsumingAction() &&
                    !playerAnimator.IsInMidAction && playerAnimator.IsGrounded,
                playerLocomotion.HandleJumpButtonPressed),

            DodgeCommand = new RelayCommand(
                () => playerStats.CanPerformStaminaConsumingAction() && !playerAnimator.IsInMidAction,
                playerLocomotion.HandleDodgeTapped),

            SprintHoldCommand = new RelayCommand(
                () => playerStats.CanPerformStaminaConsumingAction() && 
                    !playerAnimator.IsInMidAction && !playerAnimator.IsCrouching && playerAnimator.IsGrounded,
                playerLocomotion.HandleSprintHolding),

            SprintReleaseCommand = new RelayCommand(
                () => true,
                playerLocomotion.HandleSprintReleased),

            CrouchCommand = new RelayCommand(
                () => !playerAnimator.IsInMidAction && playerAnimator.IsGrounded,
                ToggleCrouchState)
        };
    }

    public void ToggleCrouchState()
    {
        if (playerAnimator.IsInAir) return;

        playerAnimator.IsCrouching = !playerAnimator.IsCrouching;

        if (playerAnimator.IsCrouching)
        {
            isSprinting = false; // Cannot sprint while crouching
        }
    }

    public override void GetBackstabbed(Transform attacker)
    {
        if (playerAnimator.IsCrouching) // Force stand up if backstabbed while crouching
        {
            playerAnimator.IsCrouching = false;
            // Animator should transition out of crouch automatically due to isCrouching=false
        }
        base.GetBackstabbed(attacker);
    }

    #region Handle Commands
    private void HandleCommand(ICommand command)
    {
        if (command.CanExecute())
        {
            // If a command could be exectuted,there is
            // no reason to hold for the pending command
            pendingCommand = null;
            command.Execute();
        }
        else
        {
            pendingCommandTimer = pendingCommandInterval;
            pendingCommand = command;
        }
    }

    private void HandleAttackInput() => HandleCommand(commands.AttackCommand);
    private void HandleJumpInput() => HandleCommand(commands.JumpCommand);
    private void HandleDodgeButton() => HandleCommand(commands.DodgeCommand);
    private void HandleSprintHolding() => HandleCommand(commands.SprintHoldCommand);
    private void HandleSprintReleased() => HandleCommand(commands.SprintReleaseCommand);
    private void HandleCrouchInput() => HandleCommand(commands.CrouchCommand);
    private void HandleInteractButtonPressed() => isPickingUp = true;
    #endregion

    #region Handle Interactables UI
    public void AddInteractable(Interactable interactable)
    {
        if (!nearbyInteractables.Contains(interactable))
        {
            nearbyInteractables.Add(interactable);
        }
    }

    public void RemoveInteractable(Interactable interactable)
    {
        nearbyInteractables.Remove(interactable);
    }

    private void HandleInteractableUI()
    {
        if (nearbyInteractables.Count > 0)
        {
            Interactable closest = GetClosestInteractable();
            if (closest != null)
            {
                // Allow re-showing interaction if item popup closed
                if (pickedUpItem && !interactableUI.itemPopUp.activeSelf)
                {
                    pickedUpItem = false;
                }

                if (pickedUpItem) return;

                interactableUI.interactableInfoText.text = closest.interactableInfoText;
                interactableUI.EnableInteractionPopUpGameObject(true);

                if (isPickingUp)
                {
                    isPickingUp = false;

                    interactableUI.itemInfoText.text = closest.GetItemName();
                    interactableUI.itemImage.sprite = closest.GetItemIcon();

                    closest.OnInteract(this);
                    // TODO: Let OnInteract handle removal if necessary
                    //nearbyInteractables.Remove(closest);

                    interactableUI.EnableInteractionPopUpGameObject(false);
                    interactableUI.EnableItemPopUpGameObject(true);
                    pickedUpItem = true;
                }
            }
            else // No closest, but list not empty (e.g. all became null)
            {
                interactableUI.EnableInteractionPopUpGameObject(false);
            }
        }
        else
        {
            interactableUI.EnableInteractionPopUpGameObject(false);

            if (isPickingUp || pickedUpItem)
            {
                isPickingUp = false;

                interactableUI.EnableItemPopUpGameObject(false);
                pickedUpItem = false;
            }
        }
    }

    private Interactable GetClosestInteractable()
    {
        Interactable closest = null;
        float minDistance = float.MaxValue;
        Vector3 playerPos = transform.position;

        nearbyInteractables.RemoveAll(item => item == null);

        foreach (var interactable in nearbyInteractables)
        {
            float distance = Vector3.Distance(playerPos, interactable.transform.position);
            if (distance < minDistance)
            {
                minDistance = distance;
                closest = interactable;
            }
        }
        return closest;
    }
    #endregion

    #region Animation Events
    public void AnimEvent_ApplyBackstabDamage()
    {
        if (currentBackstabTarget != null && playerAttacker != null)
        {
            WeaponItem weaponItem = playerInventory.EquippedRightWeapon;
            int backstabDamage = weaponItem != null ? weaponItem.GetBackstabDmg() : 200;
            Debug.Log($"Player applying {backstabDamage} backstab damage to {currentBackstabTarget.name}");

            EnemyStats victimStats = currentBackstabTarget.GetComponent<EnemyStats>();
            if (victimStats != null)
            {
                victimStats.TakeDamage(backstabDamage, DamageType.BackstabCritical, transform);
            }
        }
        else
        {
            Debug.LogWarning("ApplyBackstabDamage called, but currentBackstabTarget or playerAttacker is null.");
        }
    }

    public void AnimEvent_FinishPerformingBackstab()
    {
        Debug.Log("Player finished performing backstab animation.");
        charAnimManager.IsInMidAction = false;
        charAnimManager.IsInvulnerable = false;
        isBeingCriticallyHit = false;
        currentBackstabTarget = null;
    }
    #endregion
}


--- END FILE: Characters\Player\PlayerManager.cs ---

--- START FILE: Characters\Player\PlayerStats.cs ---

using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

// Struct to hold information about an active buff for the UI
public struct ActiveBuffInfo
{
    public string BuffName;
    public Sprite BuffIcon;
    public float RemainingDuration;
}

public class PlayerStats : CharacterStats
{
    [SerializeField] private StatUIBar healthBar;
    [SerializeField] private StatUIBar staminaBar;

    private PlayerAnimator playerAnimator;
    private PlayerManager playerManager;
    private PlayerInventory playerInventory;

    [Header("Hit Animation Names")]
    [SerializeField] private string frontHitAnimation = "Damage_Front_01";
    [SerializeField] private string backHitAnimation = "Damage_Back_01";
    [SerializeField] private string genericHitAnimation = "Damage_01"; // Fallback if direction is ambiguous or not needed

    [Header("Leveling Stats")]
    public int currentHealthLevel;
    public int currentStaminaLevel;
    public static event Action OnStatsRecalculated;

    [Header("Stats Settings")]
    [SerializeField] private int baseHealthAmount = 300;
    [SerializeField] private int baseStaminaAmount = 100;
    [SerializeField] private float staminaRegenAmount = 10;
    [SerializeField] private float staminaRegenDelay = 1;

    [Header("Currency")]
    public int currentCurrency = 0;
    public static event Action<int> OnCurrencyChanged;

    // Buffs
    public int CurrentAttackBuff { get; private set; } = 0;
    public float CurrentStaminaRegenBuff { get; private set; } = 0f;

    private Dictionary<string, Coroutine> activeBuffCoroutines = new ();
    private readonly List<ActiveBuffInfo> activeBuffsForUI = new ();

    public float FinalStaminaRegen => staminaRegenAmount + CurrentStaminaRegenBuff;
    public int TotalAttackPower => CalculateAttackDamage(playerManager.playerInventory.EquippedRightWeapon, PlayerAttackType.LightAttack);
    public int TotalDefense => baseDefense; // Later this will be: baseDefense + armorDefense;

    private float staminaRegenTimer = 0;

    private void Awake()
    {
        playerAnimator = GetComponentInChildren<PlayerAnimator>();
        playerManager = GetComponent<PlayerManager>();
        playerInventory = GetComponent<PlayerInventory>();
    }

    private void Start()
    {
        RecalculateStats();
        OnCurrencyChanged?.Invoke(currentCurrency);
    }

    private void Update()
    {
        RegenerateStamina();
    }

    private void OnEnable()
    {
        PlayerInventory.OnEquipmentUpdated += RecalculateStats;
    }

    private void OnDisable()
    {
        PlayerInventory.OnEquipmentUpdated -= RecalculateStats;
    }

    private void RecalculateStats()
    {
        float healthPercent = (maxHealth > 0) ? (float)currentHealth / maxHealth : 1f;
        float staminaPercent = (maxStamina > 0) ? currentStamina / maxStamina : 1f;

        baseAttackPower = GetBaseAttackPowerForLevel(characterLevel);
        baseDefense = GetBaseDefenseForLevel(characterLevel);
        maxHealth = GetMaxHealthForLevel(characterLevel);
        maxStamina = GetMaxStaminaForLevel(characterLevel);

        currentHealthLevel = characterLevel;
        currentStaminaLevel = characterLevel;


        // Apply talisman bonuses AFTER calculating base values
        ApplyTalismanBonuses();

        currentHealth = Mathf.RoundToInt(maxHealth * healthPercent);
        currentStamina = maxStamina * staminaPercent;

        if (healthBar != null) healthBar.SetMaxSliderValue(maxHealth);
        if (staminaBar != null) staminaBar.SetMaxSliderValue(maxStamina);
        if (healthBar != null) healthBar.SetCurrentStatValue(currentHealth);
        if (staminaBar != null) staminaBar.SetCurrentStatValue(currentStamina);

        OnStatsRecalculated?.Invoke();
        Debug.Log($"Stats recalculated for Level {characterLevel}. HP:{maxHealth}, Stamina:{maxStamina}, Atk:{base.baseAttackPower}, Def:{base.baseDefense}");
    }

    private void ApplyTalismanBonuses()
    {
        float totalHealthMultiplier = 1.0f;
        float totalStaminaMultiplier = 1.0f;

        foreach (TalismanItem talisman in playerInventory.talismanSlots)
        {
            if (talisman != null)
            {
                totalHealthMultiplier += talisman.healthBonusMultiplier;
                totalStaminaMultiplier += talisman.staminaBonusMultiplier;
            }
        }

        maxHealth = Mathf.RoundToInt(maxHealth * totalHealthMultiplier);
        maxStamina = Mathf.RoundToInt(maxStamina * totalStaminaMultiplier);
    }

    #region Stat Calculation Formulas

    public int GetMaxHealthForLevel(int level)
    {
        int levelBasedHealth = 0;
        if (level < 27) levelBasedHealth = 20 * level;
        else if (level >= 27 && level <= 49) levelBasedHealth = 540 + 13 * (level - 26);
        else if (level > 49) levelBasedHealth = 858 + 5 * (level - 49);
        return baseHealthAmount + levelBasedHealth;
    }

    public float GetMaxStaminaForLevel(int level)
    {
        return baseStaminaAmount + level * 5;
    }

    public int GetBaseAttackPowerForLevel(int level)
    {
        return baseAttackPower + ((level - 1) / 2);
    }

    public int GetBaseDefenseForLevel(int level)
    {
        // Adds +1 for every 2 levels (level 2, 4, 6...)
        return baseDefense + (level - 1) / 2;
    }

    #endregion

    public int CalculateAttackDamage(WeaponItem weapon, PlayerAttackType attackType)
    {
        if (weapon == null) weapon = playerInventory.unarmedWeaponData; // Ensure we have data

        int baseWeaponDamage = 0;
        switch (attackType)
        {
            case PlayerAttackType.LightAttack: baseWeaponDamage = weapon.lightAttackDmg; break;
            case PlayerAttackType.RollAttack: baseWeaponDamage = weapon.rollAttackDmg; break;
            case PlayerAttackType.BackstepAttack: baseWeaponDamage = weapon.backstepAttackDmg; break;
            case PlayerAttackType.JumpAttack: baseWeaponDamage = weapon.jumpAttackDmg; break;
            default: baseWeaponDamage = weapon.lightAttackDmg; break;
        }

        // Combine base stats and weapon damage
        int preMultiplierDamage = baseAttackPower + baseWeaponDamage + CurrentAttackBuff;

        // Apply Talisman Damage Multiplier
        float totalDamageMultiplier = 1.0f;
        foreach (TalismanItem talisman in playerInventory.talismanSlots)
        {
            if (talisman != null)
            {
                totalDamageMultiplier *= talisman.totalDamageMultiplier; // Multipliers should multiply each other
            }
        }

        return Mathf.RoundToInt(preMultiplierDamage * totalDamageMultiplier);
    }

    public void RestoreVitals()
    {
        currentHealth = maxHealth;
        currentStamina = maxStamina;

        if (healthBar != null) healthBar.SetCurrentStatValue(currentHealth);
        if (staminaBar != null) staminaBar.SetCurrentStatValue(currentStamina);

        playerInventory.RefillFlasks();

        Debug.Log("Player vitals and flasks have been restored.");
    }


    public void TakeDamange(int damage, Transform attackerTransform = null)
    {
        if (isDead)
            return;

        if (playerAnimator.IsInvulnerable)
            return;

        int damageAfterDefense = Mathf.Max(1, damage - TotalDefense);

        currentHealth -= damageAfterDefense;
        healthBar.SetCurrentStatValue(currentHealth);

        if (!playerManager.isBeingCriticallyHit && currentHealth > 0)
        {
            string hitAnimToPlay = genericHitAnimation;

            if (attackerTransform != null)
            {
                Vector3 directionFromAttacker = (playerManager.transform.position - attackerTransform.position).normalized;
                directionFromAttacker.y = 0; // Ignore vertical difference for front/back determination

                float dotProduct = Vector3.Dot(playerManager.transform.forward, directionFromAttacker);

                if (dotProduct < -0.3f)
                {
                    hitAnimToPlay = frontHitAnimation;
                }
                else if (dotProduct > 0.3f)
                {
                    hitAnimToPlay = backHitAnimation;
                }
                // else, if dotProduct is close to 0, it's a side hit.
            }

            if (string.IsNullOrEmpty(hitAnimToPlay) || (hitAnimToPlay == frontHitAnimation && string.IsNullOrEmpty(frontHitAnimation)) || (hitAnimToPlay == backHitAnimation && string.IsNullOrEmpty(backHitAnimation)))
            {
                hitAnimToPlay = genericHitAnimation;
            }

            // Reset bools that may conflict because were interuped by taking dmg
            playerAnimator.IsDodging = false;
            playerAnimator.IsCrouching = false;

            playerAnimator.PlayTargetAnimation(hitAnimToPlay, false, rootMotion: true);
        }

        if (currentHealth <= 0 && !isDead)
        {
            currentHealth = 0;
            isDead = true;

            playerAnimator.anim.SetBool("isDead", true);

            // If not already in a critical hit (backstab), play normal death.
            // If being critically hit, the backstab victim animation sequence will handle death.
            if (!playerManager.isBeingCriticallyHit)
            {
                playerAnimator.PlayTargetAnimation("Death_01", true);
            }
            
            //playerManager.RaiseDeath();
        }
    }

    public bool CanPerformStaminaConsumingAction()
    {
        return currentStamina > 0;
    }
    
    public void ConsumeStamina(float staminaToConsume)
    {
        if (staminaToConsume <= 0) return;

        currentStamina -= staminaToConsume;
        if (currentStamina < 0)
        {
            currentStamina = 0;
        }

        if (staminaBar != null) staminaBar.SetCurrentStatValue(currentStamina);

        staminaRegenTimer = 0;
    }

    public void Heal(int amount)
    {
        currentHealth = Mathf.Min(currentHealth + amount, maxHealth);
        if (healthBar != null) healthBar.SetCurrentStatValue(currentHealth);
    }

    public void RegenerateStamina()
    {
        if (currentStamina >= maxStamina)
            return;

        if (playerManager.playerAnimator.IsInMidAction && !playerManager.playerAnimator.IsInAir) // while falling stamina is regenerating
        {
            staminaRegenTimer = 0;
            return;
        }

        staminaRegenTimer += Time.deltaTime;

        if (staminaRegenTimer > staminaRegenDelay)
        {
            float finalRegenAmount = staminaRegenAmount + CurrentStaminaRegenBuff;

            currentStamina += finalRegenAmount * Time.deltaTime;
            if (currentStamina > maxStamina) currentStamina = maxStamina;
            if (staminaBar != null) staminaBar.SetCurrentStatValue(currentStamina);
        }
    }

    // --- Buff Application Methods ---
    public void ApplyAttackBuff(int attackBonus, float duration, ConsumableItem sourceItem)
    {
        // If a buff of the same type is already active, stop the old one before starting the new one
        if (activeBuffCoroutines.ContainsKey(sourceItem.itemName))
        {
            var duplicateBuff = activeBuffsForUI.Find(buff => buff.BuffName == sourceItem.itemName);
            activeBuffsForUI.Remove(duplicateBuff);
            StopCoroutine(activeBuffCoroutines[sourceItem.itemName]);
        }
        activeBuffCoroutines[sourceItem.itemName] = StartCoroutine(AttackBuffCoroutine(attackBonus, duration, sourceItem));
    }

    private IEnumerator AttackBuffCoroutine(int attackBonus, float duration, ConsumableItem sourceItem)
    {
        CurrentAttackBuff += attackBonus;
        var buffInfo = new ActiveBuffInfo { BuffName = sourceItem.itemName, BuffIcon = sourceItem.itemIcon, RemainingDuration = duration };
        activeBuffsForUI.Add(buffInfo);

        while (buffInfo.RemainingDuration > 0)
        {
            buffInfo.RemainingDuration -= Time.deltaTime;
            // Update the entry in the list
            int index = activeBuffsForUI.FindIndex(b => b.BuffName == sourceItem.itemName);
            if (index != -1) activeBuffsForUI[index] = buffInfo;
            yield return null;
        }

        CurrentAttackBuff -= attackBonus;
        activeBuffCoroutines.Remove(sourceItem.itemName);
        activeBuffsForUI.RemoveAll(b => b.BuffName == sourceItem.itemName);
    }

    public void ApplyStaminaBuff(float regenBonus, float duration, ConsumableItem sourceItem)
    {
        if (activeBuffCoroutines.ContainsKey(sourceItem.itemName))
        {
            var duplicateBuff = activeBuffsForUI.Find(buff => buff.BuffName == sourceItem.itemName);
            activeBuffsForUI.Remove(duplicateBuff);
            StopCoroutine(activeBuffCoroutines[sourceItem.itemName]);
        }
        activeBuffCoroutines[sourceItem.itemName] = StartCoroutine(StaminaBuffCoroutine(regenBonus, duration, sourceItem));
    }

    private IEnumerator StaminaBuffCoroutine(float regenBonus, float duration, ConsumableItem sourceItem)
    {
        CurrentStaminaRegenBuff += regenBonus;
        var buffInfo = new ActiveBuffInfo { BuffName = sourceItem.itemName, BuffIcon = sourceItem.itemIcon, RemainingDuration = duration };
        activeBuffsForUI.Add(buffInfo);

        while (buffInfo.RemainingDuration > 0)
        {
            buffInfo.RemainingDuration -= Time.deltaTime;
            int index = activeBuffsForUI.FindIndex(b => b.BuffName == sourceItem.itemName);
            if (index != -1) activeBuffsForUI[index] = buffInfo;
            yield return null;
        }

        CurrentStaminaRegenBuff -= regenBonus;
        activeBuffCoroutines.Remove(sourceItem.itemName);
        activeBuffsForUI.RemoveAll(b => b.BuffName == sourceItem.itemName);
    }

    public List<ActiveBuffInfo> GetActiveBuffs()
    {
        return activeBuffsForUI;
    }

    public void AddCurrency(int amount)
    {
        if (amount <= 0) return;
        currentCurrency += amount;
        OnCurrencyChanged?.Invoke(currentCurrency);
    }

    public bool SpendCurrency(int amount)
    {
        if (amount <= 0) return false;

        if (currentCurrency >= amount)
        {
            currentCurrency -= amount;
            OnCurrencyChanged?.Invoke(currentCurrency);
            return true;
        }

        Debug.Log("Not enough currency!");
        return false;
    }

    #region Leveling System Logic

    public int GetLevelUpCost()
    {
        // A formula that increases the cost with each level.
        return Mathf.RoundToInt(50 + (characterLevel * 100) + Mathf.Pow(characterLevel, 2) * 5);
    }

    public (int health, float stamina, int attack, int defense) GetStatPreviewForNextLevel()
    {
        int nextLevel = characterLevel + 1;
        int nextHealth = GetMaxHealthForLevel(nextLevel);
        float nextStamina = GetMaxStaminaForLevel(nextLevel);
        int nextAttack = GetBaseAttackPowerForLevel(nextLevel);
        int nextDefense = GetBaseDefenseForLevel(nextLevel);
        return (nextHealth, nextStamina, nextAttack, nextDefense);
    }

    public void LevelUp()
    {
        int cost = GetLevelUpCost();
        if (!SpendCurrency(cost))
        {
            Debug.Log("Not enough currency to level up!");
            return;
        }

        characterLevel++;

        RecalculateStats();
        RestoreVitals();
    }

    #endregion
}


--- END FILE: Characters\Player\PlayerStats.cs ---

--- START FILE: Data\InventorySlot.cs ---

using System;

[Serializable]
public class InventorySlot
{
    public Item item;
    public int quantity;

    public InventorySlot(Item item, int quantity)
    {
        this.item = item;
        this.quantity = quantity;
    }

    public void AddQuantity(int amount)
    {
        quantity += amount;
    }

    public void RemoveQuantity(int amount)
    {
        quantity -= amount;
    }
}

--- END FILE: Data\InventorySlot.cs ---

--- START FILE: Enums\ArmorType.cs ---

public enum ArmorType
{ 
    Head,
    Body,
    Hands,
    Legs
}

--- END FILE: Enums\ArmorType.cs ---

--- START FILE: Enums\DamageType.cs ---

public enum DamageType
{
    Standard,
    Critical, // General critical hit
    BackstabCritical, // Specifically a backstab
    PoiseBreakRiposte, // Future: Riposte after poise break
    FallDamage
    // Add more...
}


--- END FILE: Enums\DamageType.cs ---

--- START FILE: Enums\PlayerAttackType.cs ---

public enum PlayerAttackType
{
    None,
    LightAttack,
    RollAttack,
    BackstepAttack,
    JumpAttack
    // More...
}


--- END FILE: Enums\PlayerAttackType.cs ---

--- START FILE: Enums\WeaponHand.cs ---

public enum WeaponHand
{
    Right,
    Left
}


--- END FILE: Enums\WeaponHand.cs ---

--- START FILE: Items\ArmorItem.cs ---

using UnityEngine;

[CreateAssetMenu(menuName = "Items/Armor Item")]
public class ArmorItem : Item
{
    public GameObject modelPrefab;
    public ArmorType armorType;

    [Header("Defense Stats")]
    public float physicalDefense;
    public float magicDefense;
    // TODO: Add other resistances...
}


--- END FILE: Items\ArmorItem.cs ---

--- START FILE: Items\BonfireInteractable.cs ---

using UnityEngine;

public class BonfireInteractable : Interactable
{
    [Header("Core References")]
    [SerializeField] private UIManager uiManager;
    [SerializeField] private PlayerStats playerStats;

    [Header("Bonfire Settings")]
    [SerializeField] private ParticleSystem fireParticles;
    [SerializeField] private float enemyDetectionRadius = 15f;
    [SerializeField] private float enemyCheckInterval = 1.0f; // Check for enemies every second
    [SerializeField] private LayerMask enemyLayer;

    
    private Collider interactableCollider;

    private float enemyCheckTimer;
    private bool isSafe = true;

    private void Awake()
    {
        interactableCollider = GetComponent<Collider>();
        if (interactableCollider == null)
        {
            Debug.LogError("BonfireInteractable is missing a Collider component!", this);
            enabled = false;
            return;
        }

        if (fireParticles == null)
        {
            // Try to find it in children if not assigned
            fireParticles = GetComponentInChildren<ParticleSystem>();
            if (fireParticles == null)
                Debug.LogWarning("BonfireInteractable: No fire particle system assigned or found in children.", this);
        }

        if (enemyLayer == 0) // If layer is not set in inspector
        {
            Debug.LogError("BonfireInteractable: Enemy Layer is not set. The safety check will not work.", this);
        }
    }
    private void Start()
    {
        if (uiManager == null)
        {
            Debug.LogError("BonfireInteractable does not have a UIManager reference!");
        }
        if (playerStats == null)
        {
            Debug.LogError("BonfireInteractable does not have a PlayerStats reference!");
        }

        interactableInfoText = "Rest";
        enemyCheckTimer = enemyCheckInterval;
    }

    private void Update()
    {
        enemyCheckTimer -= Time.deltaTime;
        if (enemyCheckTimer <= 0f)
        {
            CheckForNearbyEnemies();
            enemyCheckTimer = enemyCheckInterval;
        }
    }

    private void CheckForNearbyEnemies()
    {
        bool enemyFound = Physics.CheckSphere(transform.position, enemyDetectionRadius, enemyLayer, QueryTriggerInteraction.Ignore);

        if (enemyFound)
        {
            if (isSafe)
            {
                Debug.Log("Bonfire is now unsafe due to nearby enemies.");
                SetSafeState(false);
            }
        }
        else
        {
            if (!isSafe)
            {
                Debug.Log("Bonfire is safe again.");
                SetSafeState(true);
            }
        }
    }

    private void SetSafeState(bool safe)
    {
        isSafe = safe;
        interactableCollider.enabled = safe;

        if (fireParticles != null)
        {
            if (safe)
            {
                fireParticles.Play();
            }
            else
            {
                fireParticles.Stop(true);
            }
        }

        // If the bonfire becomes unsafe while the player is in the trigger zone,
        // we need to manually remove the interaction prompt.
        if (!safe)
        {
            PlayerManager player = FindObjectOfType<PlayerManager>();
            if (player != null)
            {
                player.RemoveInteractable(this);
            }
        }
    }

    public override void OnInteract(PlayerManager playerManager)
    {
        // Safety check
        if (!isSafe)
        {
            Debug.LogWarning("Tried to interact with an unsafe bonfire.");
            return;
        }

        if (playerStats != null)
        {
            playerStats.RestoreVitals();
        }

        if (uiManager != null)
        {
            Debug.Log("Interacting with bonfire. Vitals restored. Opening level up menu.");
            uiManager.OpenLevelUpWindow();
        }
    }

    private void OnDrawGizmosSelected()
    {
        Gizmos.color = Color.red;
        Gizmos.DrawWireSphere(transform.position, enemyDetectionRadius);
    }
}

--- END FILE: Items\BonfireInteractable.cs ---

--- START FILE: Items\ConsumableItem.cs ---

using UnityEngine;

[CreateAssetMenu(menuName = "Items/Consumable Item")]
public abstract class ConsumableItem : Item
{
    [Header("Consumable Details")]
    public string useAnimation;

    public abstract void Use(PlayerManager playerManager);
}


--- END FILE: Items\ConsumableItem.cs ---

--- START FILE: Items\DamageCollider.cs ---

using System;
using System.Collections.Generic;
using UnityEngine;

public class DamageCollider : MonoBehaviour
{
    public event Action<Collider> OnDamageableHit;

    private Collider _collider;
    private readonly List<Collider> _collidedTargetsThisSwing = new();

    [Header("Debug")]
    [SerializeField] private bool logHits = false;

    // Set by WeaponSlotManager when the weapon is equipped.
    public CharacterManager Wielder { get; set; }


    private void Awake()
    {
        _collider = GetComponent<Collider>();
        if (_collider == null)
        {
            Debug.LogError($"DamageCollider on {gameObject.name} is missing its Collider component!", this);
            enabled = false;
            return;
        }
        _collider.gameObject.SetActive(true);
        _collider.isTrigger = true;
        _collider.enabled = false; // Start disabled
    }

    public void EnableDamageCollider()
    {
        if (Wielder == null)
        {
            Debug.LogWarning($"DamageCollider on {gameObject.name} enabled without a Wielder assigned. It might not function correctly for player/enemy distinctions.");
        }
        _collidedTargetsThisSwing.Clear();
        _collider.enabled = true;
        if (logHits) Debug.Log($"{Wielder?.name ?? "Unknown Wielder"}'s DamageCollider Enabled.");
    }

    public void DisableDamageCollider()
    {
        _collider.enabled = false;
        if (logHits) Debug.Log($"{Wielder?.name ?? "Unknown Wielder"}'s DamageCollider Disabled.");
    }

    private void OnTriggerStay(Collider other)
    {
        if (!_collider.enabled || Wielder == null) return;

        // Prevent hitting self
        if (other.transform.root == Wielder.transform.root)
        {
            return;
        }

        if (_collidedTargetsThisSwing.Contains(other))
        {
            return; // Already hit this target in this swing
        }

        _collidedTargetsThisSwing.Add(other);

        // Notify the owner that a damageable target was hit
        OnDamageableHit?.Invoke(other);

        if (logHits) Debug.Log($"{Wielder.name}'s DamageCollider hit {other.name}. Event invoked.");
    }

    private float MaxComponent(Vector3 v) => Mathf.Max(Mathf.Max(v.x, v.y), v.z);
}


--- END FILE: Items\DamageCollider.cs ---

--- START FILE: Items\Interactable.cs ---

using UnityEngine;
using UnityEngine.UI;

public class Interactable : MonoBehaviour
{
    public string interactableInfoText;

    private void OnTriggerEnter(Collider other)
    {
        if (other.CompareTag("Player"))
        {
            PlayerManager player = other.GetComponent<PlayerManager>();
            if (player != null)
            {
                player.AddInteractable(this);
            }
        }
    }

    private void OnTriggerExit(Collider other)
    {
        if (other.CompareTag("Player"))
        {
            PlayerManager player = other.GetComponent<PlayerManager>();
            if (player != null)
            {
                player.RemoveInteractable(this);
            }
        }
    }

    public virtual void OnInteract(PlayerManager playerManager)
    {
        Debug.Log("You picked up an Item.");
    }

    public virtual string GetItemName()
    {
        return "Item";
    }

    public virtual Sprite GetItemIcon()
    {
        return null;
    }
}


--- END FILE: Items\Interactable.cs ---

--- START FILE: Items\Item.cs ---

using UnityEngine;

public class Item : ScriptableObject
{
    [Header("Item Information")]
    public Sprite itemIcon;
    public string itemName;
    [TextArea(4, 8)]
    public string itemDescription;
    public string itemStatsText;

    [Header("Item Properties")]
    public bool isDroppable = true;
    public GameObject itemPickupPrefab;

    public virtual string GetItemStatsText()
    {
        return itemStatsText;
    }
}


--- END FILE: Items\Item.cs ---

--- START FILE: Items\ItemPickUp.cs ---

using UnityEngine;
using UnityEngine.UI;

public class ItemPickUp : Interactable
{
    [SerializeField] private Item itemToPickUp;
    [SerializeField] private string pickUpAnimation = "Pick_Up_Item";

    // Setting the item dynamically (for when dropping from inventory)
    public void SetItem(Item item)
    {
        interactableInfoText = item.itemName;
        itemToPickUp = item;
    }

    public override void OnInteract(PlayerManager playerManager)
    {
        if (itemToPickUp == null)
        {
            Debug.LogError("WeaponPickUp: weaponToPickUp is not assigned!", this);
            return;
        }
        PickUpItem(playerManager);
    }

    private void PickUpItem(PlayerManager playerManager)
    {
        if (playerManager.playerAnimator.IsInMidAction) return; // Don't pickup if busy

        playerManager.playerAnimator.IsInMidAction = true;
        playerManager.playerLocomotion.rigidbody.velocity = Vector3.zero;
        playerManager.playerAnimator.PlayTargetAnimation(pickUpAnimation, true);

        playerManager.playerInventory.AddItem(itemToPickUp);

        // Update UI prompt
        var interactable = playerManager.interactableUI;
        interactable.itemInfoText.text = GetItemName();
        interactable.itemImage.sprite = GetItemIcon();
        interactable.EnableInteractionPopUpGameObject(false);
        interactable.EnableItemPopUpGameObject(true);

        // Disable interactable immediately
        GetComponent<Collider>().enabled = false;

        // Visually disable or hide the pickup model
        foreach (Renderer r in GetComponentsInChildren<Renderer>()) r.enabled = false;

        Destroy(gameObject, 2f);
    }

    public override string GetItemName()
    {
        return itemToPickUp != null ? itemToPickUp.itemName : "Unknown Weapon";
    }

    public override Sprite GetItemIcon()
    {
        return itemToPickUp != null ? itemToPickUp.itemIcon : null;
    }
}


--- END FILE: Items\ItemPickUp.cs ---

--- START FILE: Items\TalismanItem.cs ---

using UnityEngine;

[CreateAssetMenu(menuName = "Items/Talisman Item")]
public class TalismanItem : Item
{
    [Header("Talisman Effects")]
    [Tooltip("Percentage bonus to max health. 0.1 = 10% bonus.")]
    public float healthBonusMultiplier;

    [Tooltip("Percentage bonus to max stamina. 0.05 = 5% bonus.")]
    public float staminaBonusMultiplier;

    [Tooltip("Multiplier for ALL outgoing damage. 1.0 = no change, 1.1 = 10% bonus damage.")]
    public float totalDamageMultiplier = 1.0f;

    public override string GetItemStatsText()
    {
        return $"{itemStatsText}";//: {GetStatValue(healthBonusMultiplier)}{GetStatValue(staminaBonusMultiplier)}{GetStatValue(totalDamageMultiplier)}";
    }

    private string GetStatValue(float value)
    {
        return value != 0 ? value.ToString() : "";
    }
}

--- END FILE: Items\TalismanItem.cs ---

--- START FILE: Items\WeaponHolderSlot.cs ---

using UnityEngine;

public class WeaponHolderSlot : MonoBehaviour
{
    public Transform parentOverride;
    public GameObject currentWeaponModel { get; private set; }

    // Shield specific logic might be added later if this slot is also for shields
    // public bool isShieldSlot;

    public void UnloadWeaponAndDestroy()
    {
        if (currentWeaponModel != null)
        {
            Destroy(currentWeaponModel);
            currentWeaponModel = null;
        }
    }

    public void LoadWeaponModel(WeaponItem weaponItem)
    {
        UnloadWeaponAndDestroy();

        if (weaponItem == null || weaponItem.modelPrefab == null)
        {
            return; // Nothing to load for unarmed or if no prefab
        }

        currentWeaponModel = Instantiate(weaponItem.modelPrefab);
        if (currentWeaponModel != null)
        {
            Transform actualParent = parentOverride != null ? parentOverride : transform;
            currentWeaponModel.transform.SetParent(actualParent, false); // Set parent and reset local transform
        }
    }
}


--- END FILE: Items\WeaponHolderSlot.cs ---

--- START FILE: Items\WeaponItem.cs ---

using UnityEngine;

[CreateAssetMenu(menuName = "Items/Weapon Item")]
public class WeaponItem : Item
{
    public GameObject modelPrefab;
    public bool isUnarmed;

    [Header("Idle Animations")]
    public string Right_Arm_Idle;
    public string Two_Handed_Idle;

    [Header("Attack Animations")]
    public string OH_Light_Attack_01;
    public string OH_Light_Attack_02;
    public string TH_Light_Attack_01;
    public string TH_Light_Attack_02;

    public string OH_Roll_Attack_01;
    public string OH_Backstep_Attack_01;
    public string OH_Jump_Attack_Start;
    public string OH_Jump_Attack_Idle;
    public string OH_Jump_Attack_End;

    [Header("Stamina Costs")]
    public int baseStamina;
    public float lightAttackStaminaMultiplier;
    public float rollAttackStaminaMultiplier = 1.2f;
    public float backstepAttackStaminaMultiplier = 1.0f;
    public float jumpAttackStaminaMultiplier = 1.1f;

    [Header("Damage Stats")]
    public int lightAttackDmg = 10;
    public int rollAttackDmg = 12;
    public int backstepAttackDmg = 10;
    public int jumpAttackDmg = 15;
    public int critDmgMultiplier = 2;

    public int GetBackstabDmg()
    {
        return (lightAttackDmg > 0 ? lightAttackDmg : 5) * critDmgMultiplier;
    }

    public override string GetItemStatsText()
    {
        return itemStatsText + lightAttackDmg.ToString();
    }
}


--- END FILE: Items\WeaponItem.cs ---

--- START FILE: Items\WeaponSlotManager.cs ---

using UnityEngine;

public class WeaponSlotManager : MonoBehaviour
{
    [Header("References")]
    [SerializeField] private PlayerManager playerManager;
    [SerializeField] private PlayerInventory playerInventory;
    [SerializeField] private PlayerStats playerStats;
    [SerializeField] private Animator animator;

    [Header("Weapon Slots")]
    [SerializeField] private WeaponHolderSlot rightHandSlot;
    // [SerializeField] private WeaponHolderSlot leftHandSlot; // For shield later
    // [SerializeField] private WeaponHolderSlot backSlot; // If you have visible sheathing

    private DamageCollider rightHandDamageCollider;
    // private DamageCollider leftHandDamageCollider; // For shield bash later

    public WeaponItem attackingWeapon { get; set; } // Set by PlayerAttacker

    // isTwoHanding concept might be simplified or removed if only one weapon
    // public bool isTwoHanding = false;

    private void Awake()
    {
        if (playerManager == null) playerManager = GetComponentInParent<PlayerManager>();
        if (playerInventory == null) playerInventory = GetComponentInParent<PlayerInventory>();
        if (playerStats == null) playerStats = GetComponentInParent<PlayerManager>().GetComponent<PlayerStats>();
        if (animator == null && playerManager != null) animator = playerManager.GetComponentInChildren<Animator>(); // Get player animator

        if (rightHandSlot == null) Debug.LogError("WeaponSlotManager: Right Hand Slot not assigned!");
    }

    // No longer needs OnEnable/OnDisable for TwoHandingButtonPressed
    // Two-handing logic would need to be re-evaluated if you want to keep it.
    // For now, assuming single right-hand weapon focus.

    public void LoadWeaponOnSlot(WeaponItem weaponItem, bool isRightHand)
    {
        if (!isRightHand)
        {
            // Handle left hand (shield) later
            return;
        }

        if (rightHandSlot == null) return;

        // Unsubscribe from old collider's event if it exists
        if (rightHandDamageCollider != null)
        {
            rightHandDamageCollider.OnDamageableHit -= HandleRightHandHit;
        }

        rightHandSlot.LoadWeaponModel(weaponItem);
        attackingWeapon = weaponItem ?? playerInventory.unarmedWeaponData;

        LoadRightWeaponDamageCollider(); // This finds/initializes the new collider
        //UpdateAnimatorOverrides(attackingWeapon); // Use the potentially unarmed weapon data
    }

    private void LoadRightWeaponDamageCollider()
    {
        DamageCollider newCollider;
        if (rightHandSlot.currentWeaponModel != null)
        {
            newCollider = rightHandSlot.currentWeaponModel.GetComponentInChildren<DamageCollider>();
        }
        else // Unarmed: Try to find a persistent DamageCollider on the player's hand model
        {
            newCollider = playerManager.GetComponentInChildren<DamageCollider>(true); // Find inactive ones too
            if (newCollider != null && newCollider.transform.parent != rightHandSlot.transform) // Ensure it's not a weapon's collider
            {
                // This is likely the fist collider.
            }
            else
            {
                newCollider = null; // Didn't find a dedicated fist collider
            }
        }

        rightHandDamageCollider = newCollider;

        if (rightHandDamageCollider != null)
        {
            rightHandDamageCollider.Wielder = playerManager; // Set the wielder
            rightHandDamageCollider.OnDamageableHit += HandleRightHandHit; // Subscribe to the event
        }
        else
        {
            Debug.LogWarning("No DamageCollider found for right hand/unarmed.");
        }
    }

    private void HandleRightHandHit(Collider victimCollider)
    {
        playerManager.playerAttacker.ProcessHit(victimCollider, attackingWeapon);
    }

    // Left hand would be similar if/when shields are added
    // private void LoadLeftWeaponDamageCollider() { ... }

    public void OpenRightHandDamageCollider()
    {
        if (rightHandDamageCollider != null)
        {
            rightHandDamageCollider.EnableDamageCollider();
        }
        else
        {
            Debug.LogWarning("Attempted to open Right Hand Damage Collider, but it's null.");
        }
    }

    public void CloseRightHandDamageCollider()
    {
        if (rightHandDamageCollider != null)
        {
            rightHandDamageCollider.DisableDamageCollider();
        }
    }

    // Open/CloseLeftHandDamageCollider for shields later

    // Stamina consumption will be triggered by Animation Events on PlayerAnimator
    public void DrainStaminaForAttack(PlayerAttackType attackType)
    {
        if (attackingWeapon == null || playerStats == null) return;

        float multiplier = attackType switch
        {
            PlayerAttackType.LightAttack => attackingWeapon.lightAttackStaminaMultiplier,
            PlayerAttackType.RollAttack => attackingWeapon.rollAttackStaminaMultiplier,
            PlayerAttackType.BackstepAttack => attackingWeapon.backstepAttackStaminaMultiplier,
            PlayerAttackType.JumpAttack => attackingWeapon.jumpAttackStaminaMultiplier,
            _ => 1f
        };

        playerStats.ConsumeStamina(attackingWeapon.baseStamina * multiplier);
    }
}


--- END FILE: Items\WeaponSlotManager.cs ---

--- START FILE: Items\Consumables\AttackBuffConsumable.cs ---

using UnityEngine;

[CreateAssetMenu(menuName = "Items/Consumables/Attack Buff")]
public class AttackBuffConsumable : ConsumableItem
{
    [Header("Buff Effects")]
    public int attackBonus = 20;    // Flat damage bonus
    public float buffDuration = 30f;

    public override void Use(PlayerManager playerManager)
    {
        Debug.Log($"Using {itemName}. Applying attack buff for {buffDuration}s.");
        PlayerStats playerStats = playerManager.GetComponent<PlayerStats>();
        if (playerStats != null)
        {
            // PlayerStats will need a method to handle this
            playerStats.ApplyAttackBuff(attackBonus, buffDuration, this);
        }
    }
}


--- END FILE: Items\Consumables\AttackBuffConsumable.cs ---

--- START FILE: Items\Consumables\CurrencyConsumable.cs ---

using UnityEngine;

[CreateAssetMenu(menuName = "Items/Consumables/Currency Item")]
public class CurrencyConsumable : ConsumableItem
{
    [Header("Currency Effect")]
    public int currencyAmount = 100;

    public override void Use(PlayerManager playerManager)
    {
        PlayerStats playerStats = playerManager.GetComponent<PlayerStats>();
        if (playerStats != null)
        {
            Debug.Log($"Using {itemName}. Gained {currencyAmount} currency.");
            playerStats.AddCurrency(currencyAmount);
        }
    }
}


--- END FILE: Items\Consumables\CurrencyConsumable.cs ---

--- START FILE: Items\Consumables\HealthConsumable.cs ---

using UnityEngine;

[CreateAssetMenu(menuName = "Items/Consumables/Health Potion")]
public class HealthConsumable : ConsumableItem
{
    [Header("Potion Effects")]
    public int healthRestoreAmount;
    public bool isFlask; // Is this the main regenerating flask?

    public override void Use(PlayerManager playerManager)
    {
        Debug.Log($"Using {itemName}. Restoring {healthRestoreAmount} health.");
        PlayerStats playerStats = playerManager.GetComponent<PlayerStats>();
        if (playerStats != null)
        {
            playerStats.Heal(healthRestoreAmount);
        }
    }
}


--- END FILE: Items\Consumables\HealthConsumable.cs ---

--- START FILE: Items\Consumables\StaminaBuffConsumable.cs ---

using UnityEngine;

[CreateAssetMenu(menuName = "Items/Consumables/Stamina Buff")]
public class StaminaBuffConsumable : ConsumableItem
{
    [Header("Buff Effects")]
    public float staminaRegenBonus = 15f; // Extra regen per second
    public float buffDuration = 30f;      // How long the buff lasts

    public override void Use(PlayerManager playerManager)
    {
        Debug.Log($"Using {itemName}. Applying stamina buff for {buffDuration}s.");
        PlayerStats playerStats = playerManager.GetComponent<PlayerStats>();
        if (playerStats != null)
        {
            playerStats.ApplyStaminaBuff(staminaRegenBonus, buffDuration, this);
        }
    }
}


--- END FILE: Items\Consumables\StaminaBuffConsumable.cs ---

--- START FILE: Player Controls\ICommand.cs ---

using System;

public interface ICommand
{
    bool CanExecute();
    void Execute();
}

public class RelayCommand : ICommand
{
    private readonly Func<bool> canExecute;
    private readonly Action execute;

    public RelayCommand(Func<bool> canExecute, Action execute)
    {
        this.canExecute = canExecute;
        this.execute = execute;
    }

    public bool CanExecute() => canExecute();
    public void Execute() => execute();
}


--- END FILE: Player Controls\ICommand.cs ---

--- START FILE: Player Controls\InputHandler.cs ---

using System;
using UnityEngine;
using UnityEngine.InputSystem;

public class InputHandler : MonoBehaviour
{
    public static event Action<Vector2> PlayerMovementPerformed;
    public static event Action<Vector2> CameraMovementPerformed;

    // Dodge and Sprint related events
    public static event Action DodgeTapped;
    public static event Action SprintHolding;
    public static event Action SprintReleased;

    // Action Buttons
    public static event Action JumpButtonPressed;
    public static event Action AttackButtonPressed;
    public static event Action InteractButtonPressed;
    public static event Action OptionsButtonPressed;
    public static event Action LockOnButtonPressed;
    public static event Action TwoHandingButtonPressed;
    public static event Action CrouchButtonPressed;

    // Lock-On Target Switching
    public static event Action LeftLockOnTargetButtonPressed;
    public static event Action RightLockOnTargetButtonPressed;

    // D-Pad for Quick Slots
    public static event Action DPadLeftButtonPressed;
    public static event Action DPadRightButtonPressed;
    public static event Action DPadUpButtonPressed;
    public static event Action DPadDownButtonPressed;

    // UI Events
    public static event Action<Vector2> UINavigatePerformed;
    public static event Action UISubmitPressed;
    public static event Action UICancelPressed;
    public static event Action UIContextMenuPressed;
    public static event Action UITabLeftPressed;
    public static event Action UITabRightPressed;


    PlayerControls inputActions;

    private void OnEnable()
    {
        inputActions ??= new PlayerControls();
        inputActions.Enable();
        SubscribeInputEventsToHandlers();

        // Start with gameplay map enabled by default
        SwitchToActionMap(inputActions.PlayerActions);
    }

    private void OnDisable()
    {
        inputActions.Disable();
    }

    private void SubscribeInputEventsToHandlers()
    {
        // Player Movement
        inputActions.PlayerMovement.Movement.performed += ctx => PlayerMovementPerformed?.Invoke(ctx.ReadValue<Vector2>());
        inputActions.PlayerMovement.Camera.performed += ctx => CameraMovementPerformed?.Invoke(ctx.ReadValue<Vector2>());
        inputActions.PlayerMovement.LockOnTargetLeft.performed += _ => LeftLockOnTargetButtonPressed?.Invoke();
        inputActions.PlayerMovement.LockOnTargetRight.performed += _ => RightLockOnTargetButtonPressed?.Invoke();

        // Player Actions
        inputActions.PlayerActions.Dodge.performed += _ => DodgeTapped?.Invoke();
        inputActions.PlayerActions.Sprint.performed += _ => SprintHolding?.Invoke();
        inputActions.PlayerActions.Sprint.canceled += _ => SprintReleased?.Invoke();
        inputActions.PlayerActions.Jump.performed += _ => JumpButtonPressed?.Invoke();
        inputActions.PlayerActions.Attack.performed += _ => AttackButtonPressed?.Invoke();
        inputActions.PlayerActions.Interact.performed += _ => InteractButtonPressed?.Invoke();
        inputActions.PlayerActions.LockOn.performed += _ => LockOnButtonPressed?.Invoke();
        inputActions.PlayerActions.TwoHanding.performed += _ => TwoHandingButtonPressed?.Invoke();
        inputActions.PlayerActions.Crouch.performed += _ => CrouchButtonPressed?.Invoke();
        inputActions.PlayerActions.Options.performed += _ => OptionsButtonPressed?.Invoke();

        // Player Quick Slots
        inputActions.PlayerQuickSlots.DPadLeft.performed += _ => DPadLeftButtonPressed?.Invoke();
        inputActions.PlayerQuickSlots.DPadRight.performed += _ => DPadRightButtonPressed?.Invoke();
        inputActions.PlayerQuickSlots.DPadUp.performed += _ => DPadUpButtonPressed?.Invoke();
        inputActions.PlayerQuickSlots.DPadDown.performed += _ => DPadDownButtonPressed?.Invoke();

        // UI Map
        inputActions.UI.Navigate.performed += ctx => UINavigatePerformed?.Invoke(ctx.ReadValue<Vector2>());
        inputActions.UI.Submit.performed += _ => UISubmitPressed?.Invoke();
        inputActions.UI.Cancel.performed += _ => UICancelPressed?.Invoke();
        inputActions.UI.ContextMenu.performed += _ => UIContextMenuPressed?.Invoke();
        inputActions.UI.TabLeft.performed += _ => UITabLeftPressed?.Invoke();
        inputActions.UI.TabRight.performed += _ => UITabRightPressed?.Invoke();
    }

    public void SwitchToActionMap(InputActionMap actionMap)
    {
        if (!actionMap.enabled)
        {
            inputActions.PlayerMovement.Disable();
            inputActions.PlayerActions.Disable();
            inputActions.PlayerQuickSlots.Disable();
            inputActions.UI.Disable();

            actionMap.Enable();
            Debug.Log($"Switched to Action Map: {actionMap.name}");
        }
    }

    // Public methods for UIManager to call
    public void EnableGameplayInput()
    {
        inputActions.UI.Disable();
        inputActions.PlayerMovement.Enable();
        inputActions.PlayerActions.Enable();
        inputActions.PlayerQuickSlots.Enable();
    }

    public void EnableUIInput()
    {
        CameraMovementPerformed?.Invoke(new Vector2()); // reset camera movement
        inputActions.PlayerMovement.Disable();
        inputActions.PlayerActions.Disable();
        inputActions.PlayerQuickSlots.Disable();
        inputActions.UI.Enable();
    }
}


--- END FILE: Player Controls\InputHandler.cs ---

--- START FILE: Player Controls\PlayerControls.cs ---

//------------------------------------------------------------------------------
// <auto-generated>
//     This code was auto-generated by com.unity.inputsystem:InputActionCodeGenerator
//     version 1.11.2
//     from Assets/Emberveil/Scripts/Player Controls/PlayerControls.inputactions
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine.InputSystem;
using UnityEngine.InputSystem.Utilities;

public partial class @PlayerControls: IInputActionCollection2, IDisposable
{
    public InputActionAsset asset { get; }
    public @PlayerControls()
    {
        asset = InputActionAsset.FromJson(@"{
    ""name"": ""PlayerControls"",
    ""maps"": [
        {
            ""name"": ""Player Movement"",
            ""id"": ""26b34fc4-d9d3-4133-8598-9454335e1f57"",
            ""actions"": [
                {
                    ""name"": ""Movement"",
                    ""type"": ""PassThrough"",
                    ""id"": ""bf916cc0-daf9-470d-b2e7-ff9f1d17bb42"",
                    ""expectedControlType"": ""Vector2"",
                    ""processors"": """",
                    ""interactions"": """",
                    ""initialStateCheck"": false
                },
                {
                    ""name"": ""Camera"",
                    ""type"": ""PassThrough"",
                    ""id"": ""1f2f6fae-3f83-4204-81f1-1e47e4857683"",
                    ""expectedControlType"": ""Vector2"",
                    ""processors"": """",
                    ""interactions"": """",
                    ""initialStateCheck"": false
                },
                {
                    ""name"": ""Lock On Target Left"",
                    ""type"": ""Button"",
                    ""id"": ""7ba9bed7-c7b8-4f0c-b76a-e7c0f8bcdd45"",
                    ""expectedControlType"": """",
                    ""processors"": """",
                    ""interactions"": """",
                    ""initialStateCheck"": false
                },
                {
                    ""name"": ""Lock On Target Right"",
                    ""type"": ""Button"",
                    ""id"": ""b4b8fa8f-6ef5-47cf-b4d7-cbac25e43c4c"",
                    ""expectedControlType"": """",
                    ""processors"": """",
                    ""interactions"": """",
                    ""initialStateCheck"": false
                }
            ],
            ""bindings"": [
                {
                    ""name"": ""2D Vector"",
                    ""id"": ""b4a47bf0-88a0-49ed-9265-38185b18d2bf"",
                    ""path"": ""2DVector(mode=2)"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": """",
                    ""action"": ""Movement"",
                    ""isComposite"": true,
                    ""isPartOfComposite"": false
                },
                {
                    ""name"": ""up"",
                    ""id"": ""6ce7b753-9b8f-4d63-8fe0-16c272802841"",
                    ""path"": ""<Keyboard>/w"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": """",
                    ""action"": ""Movement"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": true
                },
                {
                    ""name"": ""down"",
                    ""id"": ""8385ead4-97b4-4849-ba5f-a14cd0ef781e"",
                    ""path"": ""<Keyboard>/s"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": """",
                    ""action"": ""Movement"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": true
                },
                {
                    ""name"": ""left"",
                    ""id"": ""3e8e5a45-1635-423c-9b93-b2ffbde2aea1"",
                    ""path"": ""<Keyboard>/a"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": """",
                    ""action"": ""Movement"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": true
                },
                {
                    ""name"": ""right"",
                    ""id"": ""df7707e2-9deb-4ae2-9da2-56ecaea8e41e"",
                    ""path"": ""<Keyboard>/d"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": """",
                    ""action"": ""Movement"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": true
                },
                {
                    ""name"": """",
                    ""id"": ""644e9cad-06e5-47f4-95f2-cdecbf4a2915"",
                    ""path"": ""<Gamepad>/leftStick"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": """",
                    ""action"": ""Movement"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": false
                },
                {
                    ""name"": """",
                    ""id"": ""95953cad-655a-4cd4-8a2c-4e783e514f08"",
                    ""path"": ""<Gamepad>/rightStick"",
                    ""interactions"": """",
                    ""processors"": ""StickDeadzone"",
                    ""groups"": """",
                    ""action"": ""Camera"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": false
                },
                {
                    ""name"": """",
                    ""id"": ""e74c18f2-cacb-4050-896b-7d0817481c0e"",
                    ""path"": ""<Mouse>/delta"",
                    ""interactions"": """",
                    ""processors"": ""NormalizeVector2"",
                    ""groups"": """",
                    ""action"": ""Camera"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": false
                },
                {
                    ""name"": """",
                    ""id"": ""6f799009-09f2-4f6c-aafa-aa36de1177f7"",
                    ""path"": ""<Keyboard>/comma"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": """",
                    ""action"": ""Lock On Target Left"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": false
                },
                {
                    ""name"": """",
                    ""id"": ""f6a4b6ac-435e-4494-961c-aa735bdb2d6a"",
                    ""path"": ""<Gamepad>/dpad/left"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": """",
                    ""action"": ""Lock On Target Left"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": false
                },
                {
                    ""name"": """",
                    ""id"": ""cfbbf6e8-f690-4f55-8a69-2465d246fa85"",
                    ""path"": ""<Keyboard>/period"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": """",
                    ""action"": ""Lock On Target Right"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": false
                },
                {
                    ""name"": """",
                    ""id"": ""5cb3c53f-0fff-47a5-92c1-2d7e79cd1f96"",
                    ""path"": ""<Gamepad>/dpad/right"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": """",
                    ""action"": ""Lock On Target Right"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": false
                }
            ]
        },
        {
            ""name"": ""Player Actions"",
            ""id"": ""ed307b72-f575-4ec4-9a85-93c3d844b1d6"",
            ""actions"": [
                {
                    ""name"": ""Sprint"",
                    ""type"": ""Button"",
                    ""id"": ""29d5c7d5-833a-4afd-83f0-fb98a91d0cbc"",
                    ""expectedControlType"": """",
                    ""processors"": """",
                    ""interactions"": """",
                    ""initialStateCheck"": false
                },
                {
                    ""name"": ""Dodge"",
                    ""type"": ""Button"",
                    ""id"": ""8f6d1d1a-fb58-4f4b-87f2-6f3b977e51ce"",
                    ""expectedControlType"": """",
                    ""processors"": """",
                    ""interactions"": """",
                    ""initialStateCheck"": false
                },
                {
                    ""name"": ""Attack"",
                    ""type"": ""Button"",
                    ""id"": ""a8d7f64d-8245-4983-954e-718ff3a14ecf"",
                    ""expectedControlType"": """",
                    ""processors"": """",
                    ""interactions"": """",
                    ""initialStateCheck"": false
                },
                {
                    ""name"": ""Interact"",
                    ""type"": ""Button"",
                    ""id"": ""c3bd08d3-cb52-43fa-9145-235319397f5d"",
                    ""expectedControlType"": """",
                    ""processors"": """",
                    ""interactions"": """",
                    ""initialStateCheck"": false
                },
                {
                    ""name"": ""Jump"",
                    ""type"": ""Button"",
                    ""id"": ""69d662fb-b282-4150-b346-dd4a919c4782"",
                    ""expectedControlType"": """",
                    ""processors"": """",
                    ""interactions"": """",
                    ""initialStateCheck"": false
                },
                {
                    ""name"": ""Options"",
                    ""type"": ""Button"",
                    ""id"": ""5d38eff5-be12-42af-b684-287515bbc8b5"",
                    ""expectedControlType"": """",
                    ""processors"": """",
                    ""interactions"": """",
                    ""initialStateCheck"": false
                },
                {
                    ""name"": ""Lock On"",
                    ""type"": ""Button"",
                    ""id"": ""212c8576-6e69-42f3-8904-dce563112f7f"",
                    ""expectedControlType"": """",
                    ""processors"": """",
                    ""interactions"": """",
                    ""initialStateCheck"": false
                },
                {
                    ""name"": ""Two Handing"",
                    ""type"": ""Button"",
                    ""id"": ""fe89ac5b-c6be-4eee-bf31-1216bc9ca6e3"",
                    ""expectedControlType"": """",
                    ""processors"": """",
                    ""interactions"": """",
                    ""initialStateCheck"": false
                },
                {
                    ""name"": ""Crouch"",
                    ""type"": ""Button"",
                    ""id"": ""681b2d47-1d0a-4cb7-906c-2023b925d8e1"",
                    ""expectedControlType"": """",
                    ""processors"": """",
                    ""interactions"": """",
                    ""initialStateCheck"": false
                }
            ],
            ""bindings"": [
                {
                    ""name"": """",
                    ""id"": ""8acf8b8b-b413-46e3-82cb-f02354b56bc3"",
                    ""path"": ""<Gamepad>/buttonEast"",
                    ""interactions"": ""Tap"",
                    ""processors"": """",
                    ""groups"": """",
                    ""action"": ""Dodge"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": false
                },
                {
                    ""name"": """",
                    ""id"": ""8920bb1d-f841-4dfb-bd83-263207a695da"",
                    ""path"": ""<Keyboard>/leftShift"",
                    ""interactions"": ""Tap"",
                    ""processors"": """",
                    ""groups"": """",
                    ""action"": ""Dodge"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": false
                },
                {
                    ""name"": """",
                    ""id"": ""2f8c50c3-dba9-4d2d-91c7-7b25668bf4dd"",
                    ""path"": ""<Keyboard>/r"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": """",
                    ""action"": ""Attack"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": false
                },
                {
                    ""name"": """",
                    ""id"": ""4737c24e-b191-42c2-90e2-2d6842df0ad3"",
                    ""path"": ""<Gamepad>/buttonWest"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": """",
                    ""action"": ""Attack"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": false
                },
                {
                    ""name"": """",
                    ""id"": ""f1f49577-09b4-4fa7-8f14-59774d294f28"",
                    ""path"": ""<Keyboard>/e"",
                    ""interactions"": ""Press"",
                    ""processors"": """",
                    ""groups"": """",
                    ""action"": ""Interact"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": false
                },
                {
                    ""name"": """",
                    ""id"": ""2ee3aed3-81ce-4f50-abcb-82bb5203de84"",
                    ""path"": ""<Gamepad>/buttonSouth"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": """",
                    ""action"": ""Interact"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": false
                },
                {
                    ""name"": """",
                    ""id"": ""6390c5e6-bb65-4bc2-8d1a-6f061a76982e"",
                    ""path"": ""<Keyboard>/space"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": """",
                    ""action"": ""Jump"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": false
                },
                {
                    ""name"": """",
                    ""id"": ""fbee9133-7773-4705-9063-d0b8db8561d3"",
                    ""path"": ""<Gamepad>/rightTrigger"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": """",
                    ""action"": ""Jump"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": false
                },
                {
                    ""name"": """",
                    ""id"": ""3d4737b7-b97c-4987-9cfc-f42292626603"",
                    ""path"": ""<Keyboard>/escape"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": """",
                    ""action"": ""Options"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": false
                },
                {
                    ""name"": """",
                    ""id"": ""7660e29e-2701-477b-ac4a-1a27cdeddbec"",
                    ""path"": ""<Gamepad>/start"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": """",
                    ""action"": ""Options"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": false
                },
                {
                    ""name"": """",
                    ""id"": ""2a03d960-c7a4-4623-aedd-eb94f709e514"",
                    ""path"": ""<Keyboard>/l"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": """",
                    ""action"": ""Lock On"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": false
                },
                {
                    ""name"": """",
                    ""id"": ""797a74ad-34c1-4b8f-b528-291d472af1c9"",
                    ""path"": ""<Gamepad>/rightStickPress"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": """",
                    ""action"": ""Lock On"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": false
                },
                {
                    ""name"": """",
                    ""id"": ""dcb6b759-5b30-487c-be75-26805fcc0739"",
                    ""path"": ""<Keyboard>/y"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": """",
                    ""action"": ""Two Handing"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": false
                },
                {
                    ""name"": """",
                    ""id"": ""fedbf8fc-70a3-4966-b317-b3d2c23b6eda"",
                    ""path"": ""<Gamepad>/leftStickPress"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": """",
                    ""action"": ""Two Handing"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": false
                },
                {
                    ""name"": """",
                    ""id"": ""2cc8a4dc-aefc-4d29-9757-a39cbc8f2bac"",
                    ""path"": ""<Gamepad>/buttonEast"",
                    ""interactions"": ""Hold"",
                    ""processors"": """",
                    ""groups"": """",
                    ""action"": ""Sprint"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": false
                },
                {
                    ""name"": """",
                    ""id"": ""4085dd57-db5b-489f-b2fe-467134a8b9af"",
                    ""path"": ""<Keyboard>/leftShift"",
                    ""interactions"": ""Hold"",
                    ""processors"": """",
                    ""groups"": """",
                    ""action"": ""Sprint"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": false
                },
                {
                    ""name"": """",
                    ""id"": ""5a84f93f-bb2a-4cd7-89ba-a5c229de2fa5"",
                    ""path"": ""<Keyboard>/c"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": """",
                    ""action"": ""Crouch"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": false
                },
                {
                    ""name"": """",
                    ""id"": ""5f12151a-ea2f-4ea0-b3d6-3c36a87f3a16"",
                    ""path"": ""<Gamepad>/leftTrigger"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": """",
                    ""action"": ""Crouch"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": false
                }
            ]
        },
        {
            ""name"": ""Player Quick Slots"",
            ""id"": ""894288c9-2d85-462a-ba28-b25b05252559"",
            ""actions"": [
                {
                    ""name"": ""D-Pad Up"",
                    ""type"": ""Button"",
                    ""id"": ""0339c410-3b5a-456a-acc3-1e8ee197dc30"",
                    ""expectedControlType"": """",
                    ""processors"": """",
                    ""interactions"": """",
                    ""initialStateCheck"": false
                },
                {
                    ""name"": ""D-Pad Down"",
                    ""type"": ""Button"",
                    ""id"": ""cc849bc6-5e68-4a35-a04f-a45547cd8722"",
                    ""expectedControlType"": """",
                    ""processors"": """",
                    ""interactions"": """",
                    ""initialStateCheck"": false
                },
                {
                    ""name"": ""D-Pad Left"",
                    ""type"": ""Button"",
                    ""id"": ""796deb5c-1a9e-49f9-8a6c-cf733947b488"",
                    ""expectedControlType"": """",
                    ""processors"": """",
                    ""interactions"": """",
                    ""initialStateCheck"": false
                },
                {
                    ""name"": ""D-Pad Right"",
                    ""type"": ""Button"",
                    ""id"": ""eb0c4481-fc18-4527-9b15-0a18a494154d"",
                    ""expectedControlType"": """",
                    ""processors"": """",
                    ""interactions"": """",
                    ""initialStateCheck"": false
                }
            ],
            ""bindings"": [
                {
                    ""name"": """",
                    ""id"": ""5bc1c29d-bd3e-4a57-930f-26c6e4a1ef01"",
                    ""path"": ""<Keyboard>/upArrow"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": """",
                    ""action"": ""D-Pad Up"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": false
                },
                {
                    ""name"": """",
                    ""id"": ""3ee22b05-850b-4af2-8900-688dce51b1f9"",
                    ""path"": ""<Gamepad>/dpad/up"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": """",
                    ""action"": ""D-Pad Up"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": false
                },
                {
                    ""name"": """",
                    ""id"": ""a54b13a7-09e9-4542-be80-be6d7365453e"",
                    ""path"": ""<Keyboard>/downArrow"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": """",
                    ""action"": ""D-Pad Down"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": false
                },
                {
                    ""name"": """",
                    ""id"": ""5aa6afbf-0f37-4726-a0e3-9e70413d7618"",
                    ""path"": ""<Gamepad>/dpad/down"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": """",
                    ""action"": ""D-Pad Down"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": false
                },
                {
                    ""name"": """",
                    ""id"": ""1d43442e-3217-4f6c-bb53-e94bffe7d941"",
                    ""path"": ""<Keyboard>/leftArrow"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": """",
                    ""action"": ""D-Pad Left"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": false
                },
                {
                    ""name"": """",
                    ""id"": ""4aa62085-f5f5-4fd6-aba8-1e4665b69c7e"",
                    ""path"": ""<Gamepad>/dpad/left"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": """",
                    ""action"": ""D-Pad Left"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": false
                },
                {
                    ""name"": """",
                    ""id"": ""40c59a53-5bbd-4cd7-8abd-df1094660296"",
                    ""path"": ""<Keyboard>/rightArrow"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": """",
                    ""action"": ""D-Pad Right"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": false
                },
                {
                    ""name"": """",
                    ""id"": ""1d747649-827a-40ff-9f68-d1bec4581914"",
                    ""path"": ""<Gamepad>/dpad/right"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": """",
                    ""action"": ""D-Pad Right"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": false
                }
            ]
        },
        {
            ""name"": ""UI"",
            ""id"": ""be33a4d8-df6e-447c-ae37-b59abd6c119e"",
            ""actions"": [
                {
                    ""name"": ""Navigate"",
                    ""type"": ""Value"",
                    ""id"": ""777e10b4-69db-4b39-96c2-973cf52828ea"",
                    ""expectedControlType"": ""Vector2"",
                    ""processors"": """",
                    ""interactions"": """",
                    ""initialStateCheck"": true
                },
                {
                    ""name"": ""Submit"",
                    ""type"": ""Button"",
                    ""id"": ""61d6fc84-6289-4cf2-9bce-452558bbb5a9"",
                    ""expectedControlType"": """",
                    ""processors"": """",
                    ""interactions"": """",
                    ""initialStateCheck"": false
                },
                {
                    ""name"": ""Cancel"",
                    ""type"": ""Button"",
                    ""id"": ""735e9137-4b39-46b5-b6a8-b58eacb0cfc1"",
                    ""expectedControlType"": """",
                    ""processors"": """",
                    ""interactions"": """",
                    ""initialStateCheck"": false
                },
                {
                    ""name"": ""ContextMenu"",
                    ""type"": ""Button"",
                    ""id"": ""e7a54d5a-dcf4-44bd-bf55-009680fc8638"",
                    ""expectedControlType"": """",
                    ""processors"": """",
                    ""interactions"": """",
                    ""initialStateCheck"": false
                },
                {
                    ""name"": ""TabLeft"",
                    ""type"": ""Button"",
                    ""id"": ""71a70533-5c96-4726-9f5c-84e19da3d26c"",
                    ""expectedControlType"": """",
                    ""processors"": """",
                    ""interactions"": """",
                    ""initialStateCheck"": false
                },
                {
                    ""name"": ""TabRight"",
                    ""type"": ""Button"",
                    ""id"": ""7275cb8f-5b21-462f-9b45-bc5923b99911"",
                    ""expectedControlType"": """",
                    ""processors"": """",
                    ""interactions"": """",
                    ""initialStateCheck"": false
                }
            ],
            ""bindings"": [
                {
                    ""name"": """",
                    ""id"": ""efb1b5e9-a508-4cc7-b92f-d922ff9cecd8"",
                    ""path"": ""<Gamepad>/dpad"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": """",
                    ""action"": ""Navigate"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": false
                },
                {
                    ""name"": ""WASD"",
                    ""id"": ""f47a6f8a-5059-44db-8f36-0055e41cd3c2"",
                    ""path"": ""2DVector"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": """",
                    ""action"": ""Navigate"",
                    ""isComposite"": true,
                    ""isPartOfComposite"": false
                },
                {
                    ""name"": ""up"",
                    ""id"": ""2825bef7-ac1f-4e26-850d-4a56fcbbdc7f"",
                    ""path"": ""<Keyboard>/w"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": """",
                    ""action"": ""Navigate"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": true
                },
                {
                    ""name"": ""down"",
                    ""id"": ""1d482ae1-61b0-4349-903b-23b39b1d73bf"",
                    ""path"": ""<Keyboard>/s"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": """",
                    ""action"": ""Navigate"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": true
                },
                {
                    ""name"": ""left"",
                    ""id"": ""e7b3cd85-c745-41c8-8973-02c0e0f1704d"",
                    ""path"": ""<Keyboard>/a"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": """",
                    ""action"": ""Navigate"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": true
                },
                {
                    ""name"": ""right"",
                    ""id"": ""cad61297-5182-4435-8723-8d4fe0dc07a2"",
                    ""path"": ""<Keyboard>/d"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": """",
                    ""action"": ""Navigate"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": true
                },
                {
                    ""name"": ""Arrows"",
                    ""id"": ""521443f5-ddb4-4dab-9be6-4347f1e00c5d"",
                    ""path"": ""2DVector"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": """",
                    ""action"": ""Navigate"",
                    ""isComposite"": true,
                    ""isPartOfComposite"": false
                },
                {
                    ""name"": ""up"",
                    ""id"": ""99bf5a9d-9960-4f6c-bc6e-7991f4c1ae05"",
                    ""path"": ""<Keyboard>/upArrow"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": """",
                    ""action"": ""Navigate"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": true
                },
                {
                    ""name"": ""down"",
                    ""id"": ""7fdb03ed-788d-451a-94a5-23719cf25b29"",
                    ""path"": ""<Keyboard>/downArrow"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": """",
                    ""action"": ""Navigate"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": true
                },
                {
                    ""name"": ""left"",
                    ""id"": ""440fcb5a-2ea6-410f-b9b8-942cec4abc4e"",
                    ""path"": ""<Keyboard>/leftArrow"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": """",
                    ""action"": ""Navigate"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": true
                },
                {
                    ""name"": ""right"",
                    ""id"": ""41966502-675f-4fcf-9c71-ea9670c4d1de"",
                    ""path"": ""<Keyboard>/rightArrow"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": """",
                    ""action"": ""Navigate"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": true
                },
                {
                    ""name"": """",
                    ""id"": ""7058a4e5-7aa6-4dc5-938a-58665f87df77"",
                    ""path"": ""<Gamepad>/buttonSouth"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": """",
                    ""action"": ""Submit"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": false
                },
                {
                    ""name"": """",
                    ""id"": ""4bafa090-faf3-4d40-9a68-e483edfab337"",
                    ""path"": ""<Keyboard>/enter"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": """",
                    ""action"": ""Submit"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": false
                },
                {
                    ""name"": """",
                    ""id"": ""f97625bd-5a18-48c5-be55-3619754084ce"",
                    ""path"": ""<Gamepad>/buttonEast"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": """",
                    ""action"": ""Cancel"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": false
                },
                {
                    ""name"": """",
                    ""id"": ""4a44cb41-d44a-4136-958d-7a7f9c11d38a"",
                    ""path"": ""<Keyboard>/escape"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": """",
                    ""action"": ""Cancel"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": false
                },
                {
                    ""name"": """",
                    ""id"": ""77327856-fdb3-4a86-8547-61c24fff53bc"",
                    ""path"": ""<Gamepad>/buttonWest"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": """",
                    ""action"": ""ContextMenu"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": false
                },
                {
                    ""name"": """",
                    ""id"": ""2a1432d8-76e8-4edf-a9c8-a7323c682617"",
                    ""path"": ""<Mouse>/rightButton"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": """",
                    ""action"": ""ContextMenu"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": false
                },
                {
                    ""name"": """",
                    ""id"": ""c1bffed5-a31b-49c6-95a3-6d9915c9f860"",
                    ""path"": ""<Gamepad>/leftShoulder"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": """",
                    ""action"": ""TabLeft"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": false
                },
                {
                    ""name"": """",
                    ""id"": ""1da49102-9f31-4c5a-851c-a7a9d072d46e"",
                    ""path"": ""<Keyboard>/q"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": """",
                    ""action"": ""TabLeft"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": false
                },
                {
                    ""name"": """",
                    ""id"": ""c7739eb3-463f-423c-ad60-3eb9ec3f6798"",
                    ""path"": ""<Gamepad>/rightShoulder"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": """",
                    ""action"": ""TabRight"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": false
                },
                {
                    ""name"": """",
                    ""id"": ""5897b472-1b4e-4dc5-afb7-009eda7cee82"",
                    ""path"": ""<Keyboard>/e"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": """",
                    ""action"": ""TabRight"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": false
                }
            ]
        }
    ],
    ""controlSchemes"": []
}");
        // Player Movement
        m_PlayerMovement = asset.FindActionMap("Player Movement", throwIfNotFound: true);
        m_PlayerMovement_Movement = m_PlayerMovement.FindAction("Movement", throwIfNotFound: true);
        m_PlayerMovement_Camera = m_PlayerMovement.FindAction("Camera", throwIfNotFound: true);
        m_PlayerMovement_LockOnTargetLeft = m_PlayerMovement.FindAction("Lock On Target Left", throwIfNotFound: true);
        m_PlayerMovement_LockOnTargetRight = m_PlayerMovement.FindAction("Lock On Target Right", throwIfNotFound: true);
        // Player Actions
        m_PlayerActions = asset.FindActionMap("Player Actions", throwIfNotFound: true);
        m_PlayerActions_Sprint = m_PlayerActions.FindAction("Sprint", throwIfNotFound: true);
        m_PlayerActions_Dodge = m_PlayerActions.FindAction("Dodge", throwIfNotFound: true);
        m_PlayerActions_Attack = m_PlayerActions.FindAction("Attack", throwIfNotFound: true);
        m_PlayerActions_Interact = m_PlayerActions.FindAction("Interact", throwIfNotFound: true);
        m_PlayerActions_Jump = m_PlayerActions.FindAction("Jump", throwIfNotFound: true);
        m_PlayerActions_Options = m_PlayerActions.FindAction("Options", throwIfNotFound: true);
        m_PlayerActions_LockOn = m_PlayerActions.FindAction("Lock On", throwIfNotFound: true);
        m_PlayerActions_TwoHanding = m_PlayerActions.FindAction("Two Handing", throwIfNotFound: true);
        m_PlayerActions_Crouch = m_PlayerActions.FindAction("Crouch", throwIfNotFound: true);
        // Player Quick Slots
        m_PlayerQuickSlots = asset.FindActionMap("Player Quick Slots", throwIfNotFound: true);
        m_PlayerQuickSlots_DPadUp = m_PlayerQuickSlots.FindAction("D-Pad Up", throwIfNotFound: true);
        m_PlayerQuickSlots_DPadDown = m_PlayerQuickSlots.FindAction("D-Pad Down", throwIfNotFound: true);
        m_PlayerQuickSlots_DPadLeft = m_PlayerQuickSlots.FindAction("D-Pad Left", throwIfNotFound: true);
        m_PlayerQuickSlots_DPadRight = m_PlayerQuickSlots.FindAction("D-Pad Right", throwIfNotFound: true);
        // UI
        m_UI = asset.FindActionMap("UI", throwIfNotFound: true);
        m_UI_Navigate = m_UI.FindAction("Navigate", throwIfNotFound: true);
        m_UI_Submit = m_UI.FindAction("Submit", throwIfNotFound: true);
        m_UI_Cancel = m_UI.FindAction("Cancel", throwIfNotFound: true);
        m_UI_ContextMenu = m_UI.FindAction("ContextMenu", throwIfNotFound: true);
        m_UI_TabLeft = m_UI.FindAction("TabLeft", throwIfNotFound: true);
        m_UI_TabRight = m_UI.FindAction("TabRight", throwIfNotFound: true);
    }

    ~@PlayerControls()
    {
        UnityEngine.Debug.Assert(!m_PlayerMovement.enabled, "This will cause a leak and performance issues, PlayerControls.PlayerMovement.Disable() has not been called.");
        UnityEngine.Debug.Assert(!m_PlayerActions.enabled, "This will cause a leak and performance issues, PlayerControls.PlayerActions.Disable() has not been called.");
        UnityEngine.Debug.Assert(!m_PlayerQuickSlots.enabled, "This will cause a leak and performance issues, PlayerControls.PlayerQuickSlots.Disable() has not been called.");
        UnityEngine.Debug.Assert(!m_UI.enabled, "This will cause a leak and performance issues, PlayerControls.UI.Disable() has not been called.");
    }

    public void Dispose()
    {
        UnityEngine.Object.Destroy(asset);
    }

    public InputBinding? bindingMask
    {
        get => asset.bindingMask;
        set => asset.bindingMask = value;
    }

    public ReadOnlyArray<InputDevice>? devices
    {
        get => asset.devices;
        set => asset.devices = value;
    }

    public ReadOnlyArray<InputControlScheme> controlSchemes => asset.controlSchemes;

    public bool Contains(InputAction action)
    {
        return asset.Contains(action);
    }

    public IEnumerator<InputAction> GetEnumerator()
    {
        return asset.GetEnumerator();
    }

    IEnumerator IEnumerable.GetEnumerator()
    {
        return GetEnumerator();
    }

    public void Enable()
    {
        asset.Enable();
    }

    public void Disable()
    {
        asset.Disable();
    }

    public IEnumerable<InputBinding> bindings => asset.bindings;

    public InputAction FindAction(string actionNameOrId, bool throwIfNotFound = false)
    {
        return asset.FindAction(actionNameOrId, throwIfNotFound);
    }

    public int FindBinding(InputBinding bindingMask, out InputAction action)
    {
        return asset.FindBinding(bindingMask, out action);
    }

    // Player Movement
    private readonly InputActionMap m_PlayerMovement;
    private List<IPlayerMovementActions> m_PlayerMovementActionsCallbackInterfaces = new List<IPlayerMovementActions>();
    private readonly InputAction m_PlayerMovement_Movement;
    private readonly InputAction m_PlayerMovement_Camera;
    private readonly InputAction m_PlayerMovement_LockOnTargetLeft;
    private readonly InputAction m_PlayerMovement_LockOnTargetRight;
    public struct PlayerMovementActions
    {
        private @PlayerControls m_Wrapper;
        public PlayerMovementActions(@PlayerControls wrapper) { m_Wrapper = wrapper; }
        public InputAction @Movement => m_Wrapper.m_PlayerMovement_Movement;
        public InputAction @Camera => m_Wrapper.m_PlayerMovement_Camera;
        public InputAction @LockOnTargetLeft => m_Wrapper.m_PlayerMovement_LockOnTargetLeft;
        public InputAction @LockOnTargetRight => m_Wrapper.m_PlayerMovement_LockOnTargetRight;
        public InputActionMap Get() { return m_Wrapper.m_PlayerMovement; }
        public void Enable() { Get().Enable(); }
        public void Disable() { Get().Disable(); }
        public bool enabled => Get().enabled;
        public static implicit operator InputActionMap(PlayerMovementActions set) { return set.Get(); }
        public void AddCallbacks(IPlayerMovementActions instance)
        {
            if (instance == null || m_Wrapper.m_PlayerMovementActionsCallbackInterfaces.Contains(instance)) return;
            m_Wrapper.m_PlayerMovementActionsCallbackInterfaces.Add(instance);
            @Movement.started += instance.OnMovement;
            @Movement.performed += instance.OnMovement;
            @Movement.canceled += instance.OnMovement;
            @Camera.started += instance.OnCamera;
            @Camera.performed += instance.OnCamera;
            @Camera.canceled += instance.OnCamera;
            @LockOnTargetLeft.started += instance.OnLockOnTargetLeft;
            @LockOnTargetLeft.performed += instance.OnLockOnTargetLeft;
            @LockOnTargetLeft.canceled += instance.OnLockOnTargetLeft;
            @LockOnTargetRight.started += instance.OnLockOnTargetRight;
            @LockOnTargetRight.performed += instance.OnLockOnTargetRight;
            @LockOnTargetRight.canceled += instance.OnLockOnTargetRight;
        }

        private void UnregisterCallbacks(IPlayerMovementActions instance)
        {
            @Movement.started -= instance.OnMovement;
            @Movement.performed -= instance.OnMovement;
            @Movement.canceled -= instance.OnMovement;
            @Camera.started -= instance.OnCamera;
            @Camera.performed -= instance.OnCamera;
            @Camera.canceled -= instance.OnCamera;
            @LockOnTargetLeft.started -= instance.OnLockOnTargetLeft;
            @LockOnTargetLeft.performed -= instance.OnLockOnTargetLeft;
            @LockOnTargetLeft.canceled -= instance.OnLockOnTargetLeft;
            @LockOnTargetRight.started -= instance.OnLockOnTargetRight;
            @LockOnTargetRight.performed -= instance.OnLockOnTargetRight;
            @LockOnTargetRight.canceled -= instance.OnLockOnTargetRight;
        }

        public void RemoveCallbacks(IPlayerMovementActions instance)
        {
            if (m_Wrapper.m_PlayerMovementActionsCallbackInterfaces.Remove(instance))
                UnregisterCallbacks(instance);
        }

        public void SetCallbacks(IPlayerMovementActions instance)
        {
            foreach (var item in m_Wrapper.m_PlayerMovementActionsCallbackInterfaces)
                UnregisterCallbacks(item);
            m_Wrapper.m_PlayerMovementActionsCallbackInterfaces.Clear();
            AddCallbacks(instance);
        }
    }
    public PlayerMovementActions @PlayerMovement => new PlayerMovementActions(this);

    // Player Actions
    private readonly InputActionMap m_PlayerActions;
    private List<IPlayerActionsActions> m_PlayerActionsActionsCallbackInterfaces = new List<IPlayerActionsActions>();
    private readonly InputAction m_PlayerActions_Sprint;
    private readonly InputAction m_PlayerActions_Dodge;
    private readonly InputAction m_PlayerActions_Attack;
    private readonly InputAction m_PlayerActions_Interact;
    private readonly InputAction m_PlayerActions_Jump;
    private readonly InputAction m_PlayerActions_Options;
    private readonly InputAction m_PlayerActions_LockOn;
    private readonly InputAction m_PlayerActions_TwoHanding;
    private readonly InputAction m_PlayerActions_Crouch;
    public struct PlayerActionsActions
    {
        private @PlayerControls m_Wrapper;
        public PlayerActionsActions(@PlayerControls wrapper) { m_Wrapper = wrapper; }
        public InputAction @Sprint => m_Wrapper.m_PlayerActions_Sprint;
        public InputAction @Dodge => m_Wrapper.m_PlayerActions_Dodge;
        public InputAction @Attack => m_Wrapper.m_PlayerActions_Attack;
        public InputAction @Interact => m_Wrapper.m_PlayerActions_Interact;
        public InputAction @Jump => m_Wrapper.m_PlayerActions_Jump;
        public InputAction @Options => m_Wrapper.m_PlayerActions_Options;
        public InputAction @LockOn => m_Wrapper.m_PlayerActions_LockOn;
        public InputAction @TwoHanding => m_Wrapper.m_PlayerActions_TwoHanding;
        public InputAction @Crouch => m_Wrapper.m_PlayerActions_Crouch;
        public InputActionMap Get() { return m_Wrapper.m_PlayerActions; }
        public void Enable() { Get().Enable(); }
        public void Disable() { Get().Disable(); }
        public bool enabled => Get().enabled;
        public static implicit operator InputActionMap(PlayerActionsActions set) { return set.Get(); }
        public void AddCallbacks(IPlayerActionsActions instance)
        {
            if (instance == null || m_Wrapper.m_PlayerActionsActionsCallbackInterfaces.Contains(instance)) return;
            m_Wrapper.m_PlayerActionsActionsCallbackInterfaces.Add(instance);
            @Sprint.started += instance.OnSprint;
            @Sprint.performed += instance.OnSprint;
            @Sprint.canceled += instance.OnSprint;
            @Dodge.started += instance.OnDodge;
            @Dodge.performed += instance.OnDodge;
            @Dodge.canceled += instance.OnDodge;
            @Attack.started += instance.OnAttack;
            @Attack.performed += instance.OnAttack;
            @Attack.canceled += instance.OnAttack;
            @Interact.started += instance.OnInteract;
            @Interact.performed += instance.OnInteract;
            @Interact.canceled += instance.OnInteract;
            @Jump.started += instance.OnJump;
            @Jump.performed += instance.OnJump;
            @Jump.canceled += instance.OnJump;
            @Options.started += instance.OnOptions;
            @Options.performed += instance.OnOptions;
            @Options.canceled += instance.OnOptions;
            @LockOn.started += instance.OnLockOn;
            @LockOn.performed += instance.OnLockOn;
            @LockOn.canceled += instance.OnLockOn;
            @TwoHanding.started += instance.OnTwoHanding;
            @TwoHanding.performed += instance.OnTwoHanding;
            @TwoHanding.canceled += instance.OnTwoHanding;
            @Crouch.started += instance.OnCrouch;
            @Crouch.performed += instance.OnCrouch;
            @Crouch.canceled += instance.OnCrouch;
        }

        private void UnregisterCallbacks(IPlayerActionsActions instance)
        {
            @Sprint.started -= instance.OnSprint;
            @Sprint.performed -= instance.OnSprint;
            @Sprint.canceled -= instance.OnSprint;
            @Dodge.started -= instance.OnDodge;
            @Dodge.performed -= instance.OnDodge;
            @Dodge.canceled -= instance.OnDodge;
            @Attack.started -= instance.OnAttack;
            @Attack.performed -= instance.OnAttack;
            @Attack.canceled -= instance.OnAttack;
            @Interact.started -= instance.OnInteract;
            @Interact.performed -= instance.OnInteract;
            @Interact.canceled -= instance.OnInteract;
            @Jump.started -= instance.OnJump;
            @Jump.performed -= instance.OnJump;
            @Jump.canceled -= instance.OnJump;
            @Options.started -= instance.OnOptions;
            @Options.performed -= instance.OnOptions;
            @Options.canceled -= instance.OnOptions;
            @LockOn.started -= instance.OnLockOn;
            @LockOn.performed -= instance.OnLockOn;
            @LockOn.canceled -= instance.OnLockOn;
            @TwoHanding.started -= instance.OnTwoHanding;
            @TwoHanding.performed -= instance.OnTwoHanding;
            @TwoHanding.canceled -= instance.OnTwoHanding;
            @Crouch.started -= instance.OnCrouch;
            @Crouch.performed -= instance.OnCrouch;
            @Crouch.canceled -= instance.OnCrouch;
        }

        public void RemoveCallbacks(IPlayerActionsActions instance)
        {
            if (m_Wrapper.m_PlayerActionsActionsCallbackInterfaces.Remove(instance))
                UnregisterCallbacks(instance);
        }

        public void SetCallbacks(IPlayerActionsActions instance)
        {
            foreach (var item in m_Wrapper.m_PlayerActionsActionsCallbackInterfaces)
                UnregisterCallbacks(item);
            m_Wrapper.m_PlayerActionsActionsCallbackInterfaces.Clear();
            AddCallbacks(instance);
        }
    }
    public PlayerActionsActions @PlayerActions => new PlayerActionsActions(this);

    // Player Quick Slots
    private readonly InputActionMap m_PlayerQuickSlots;
    private List<IPlayerQuickSlotsActions> m_PlayerQuickSlotsActionsCallbackInterfaces = new List<IPlayerQuickSlotsActions>();
    private readonly InputAction m_PlayerQuickSlots_DPadUp;
    private readonly InputAction m_PlayerQuickSlots_DPadDown;
    private readonly InputAction m_PlayerQuickSlots_DPadLeft;
    private readonly InputAction m_PlayerQuickSlots_DPadRight;
    public struct PlayerQuickSlotsActions
    {
        private @PlayerControls m_Wrapper;
        public PlayerQuickSlotsActions(@PlayerControls wrapper) { m_Wrapper = wrapper; }
        public InputAction @DPadUp => m_Wrapper.m_PlayerQuickSlots_DPadUp;
        public InputAction @DPadDown => m_Wrapper.m_PlayerQuickSlots_DPadDown;
        public InputAction @DPadLeft => m_Wrapper.m_PlayerQuickSlots_DPadLeft;
        public InputAction @DPadRight => m_Wrapper.m_PlayerQuickSlots_DPadRight;
        public InputActionMap Get() { return m_Wrapper.m_PlayerQuickSlots; }
        public void Enable() { Get().Enable(); }
        public void Disable() { Get().Disable(); }
        public bool enabled => Get().enabled;
        public static implicit operator InputActionMap(PlayerQuickSlotsActions set) { return set.Get(); }
        public void AddCallbacks(IPlayerQuickSlotsActions instance)
        {
            if (instance == null || m_Wrapper.m_PlayerQuickSlotsActionsCallbackInterfaces.Contains(instance)) return;
            m_Wrapper.m_PlayerQuickSlotsActionsCallbackInterfaces.Add(instance);
            @DPadUp.started += instance.OnDPadUp;
            @DPadUp.performed += instance.OnDPadUp;
            @DPadUp.canceled += instance.OnDPadUp;
            @DPadDown.started += instance.OnDPadDown;
            @DPadDown.performed += instance.OnDPadDown;
            @DPadDown.canceled += instance.OnDPadDown;
            @DPadLeft.started += instance.OnDPadLeft;
            @DPadLeft.performed += instance.OnDPadLeft;
            @DPadLeft.canceled += instance.OnDPadLeft;
            @DPadRight.started += instance.OnDPadRight;
            @DPadRight.performed += instance.OnDPadRight;
            @DPadRight.canceled += instance.OnDPadRight;
        }

        private void UnregisterCallbacks(IPlayerQuickSlotsActions instance)
        {
            @DPadUp.started -= instance.OnDPadUp;
            @DPadUp.performed -= instance.OnDPadUp;
            @DPadUp.canceled -= instance.OnDPadUp;
            @DPadDown.started -= instance.OnDPadDown;
            @DPadDown.performed -= instance.OnDPadDown;
            @DPadDown.canceled -= instance.OnDPadDown;
            @DPadLeft.started -= instance.OnDPadLeft;
            @DPadLeft.performed -= instance.OnDPadLeft;
            @DPadLeft.canceled -= instance.OnDPadLeft;
            @DPadRight.started -= instance.OnDPadRight;
            @DPadRight.performed -= instance.OnDPadRight;
            @DPadRight.canceled -= instance.OnDPadRight;
        }

        public void RemoveCallbacks(IPlayerQuickSlotsActions instance)
        {
            if (m_Wrapper.m_PlayerQuickSlotsActionsCallbackInterfaces.Remove(instance))
                UnregisterCallbacks(instance);
        }

        public void SetCallbacks(IPlayerQuickSlotsActions instance)
        {
            foreach (var item in m_Wrapper.m_PlayerQuickSlotsActionsCallbackInterfaces)
                UnregisterCallbacks(item);
            m_Wrapper.m_PlayerQuickSlotsActionsCallbackInterfaces.Clear();
            AddCallbacks(instance);
        }
    }
    public PlayerQuickSlotsActions @PlayerQuickSlots => new PlayerQuickSlotsActions(this);

    // UI
    private readonly InputActionMap m_UI;
    private List<IUIActions> m_UIActionsCallbackInterfaces = new List<IUIActions>();
    private readonly InputAction m_UI_Navigate;
    private readonly InputAction m_UI_Submit;
    private readonly InputAction m_UI_Cancel;
    private readonly InputAction m_UI_ContextMenu;
    private readonly InputAction m_UI_TabLeft;
    private readonly InputAction m_UI_TabRight;
    public struct UIActions
    {
        private @PlayerControls m_Wrapper;
        public UIActions(@PlayerControls wrapper) { m_Wrapper = wrapper; }
        public InputAction @Navigate => m_Wrapper.m_UI_Navigate;
        public InputAction @Submit => m_Wrapper.m_UI_Submit;
        public InputAction @Cancel => m_Wrapper.m_UI_Cancel;
        public InputAction @ContextMenu => m_Wrapper.m_UI_ContextMenu;
        public InputAction @TabLeft => m_Wrapper.m_UI_TabLeft;
        public InputAction @TabRight => m_Wrapper.m_UI_TabRight;
        public InputActionMap Get() { return m_Wrapper.m_UI; }
        public void Enable() { Get().Enable(); }
        public void Disable() { Get().Disable(); }
        public bool enabled => Get().enabled;
        public static implicit operator InputActionMap(UIActions set) { return set.Get(); }
        public void AddCallbacks(IUIActions instance)
        {
            if (instance == null || m_Wrapper.m_UIActionsCallbackInterfaces.Contains(instance)) return;
            m_Wrapper.m_UIActionsCallbackInterfaces.Add(instance);
            @Navigate.started += instance.OnNavigate;
            @Navigate.performed += instance.OnNavigate;
            @Navigate.canceled += instance.OnNavigate;
            @Submit.started += instance.OnSubmit;
            @Submit.performed += instance.OnSubmit;
            @Submit.canceled += instance.OnSubmit;
            @Cancel.started += instance.OnCancel;
            @Cancel.performed += instance.OnCancel;
            @Cancel.canceled += instance.OnCancel;
            @ContextMenu.started += instance.OnContextMenu;
            @ContextMenu.performed += instance.OnContextMenu;
            @ContextMenu.canceled += instance.OnContextMenu;
            @TabLeft.started += instance.OnTabLeft;
            @TabLeft.performed += instance.OnTabLeft;
            @TabLeft.canceled += instance.OnTabLeft;
            @TabRight.started += instance.OnTabRight;
            @TabRight.performed += instance.OnTabRight;
            @TabRight.canceled += instance.OnTabRight;
        }

        private void UnregisterCallbacks(IUIActions instance)
        {
            @Navigate.started -= instance.OnNavigate;
            @Navigate.performed -= instance.OnNavigate;
            @Navigate.canceled -= instance.OnNavigate;
            @Submit.started -= instance.OnSubmit;
            @Submit.performed -= instance.OnSubmit;
            @Submit.canceled -= instance.OnSubmit;
            @Cancel.started -= instance.OnCancel;
            @Cancel.performed -= instance.OnCancel;
            @Cancel.canceled -= instance.OnCancel;
            @ContextMenu.started -= instance.OnContextMenu;
            @ContextMenu.performed -= instance.OnContextMenu;
            @ContextMenu.canceled -= instance.OnContextMenu;
            @TabLeft.started -= instance.OnTabLeft;
            @TabLeft.performed -= instance.OnTabLeft;
            @TabLeft.canceled -= instance.OnTabLeft;
            @TabRight.started -= instance.OnTabRight;
            @TabRight.performed -= instance.OnTabRight;
            @TabRight.canceled -= instance.OnTabRight;
        }

        public void RemoveCallbacks(IUIActions instance)
        {
            if (m_Wrapper.m_UIActionsCallbackInterfaces.Remove(instance))
                UnregisterCallbacks(instance);
        }

        public void SetCallbacks(IUIActions instance)
        {
            foreach (var item in m_Wrapper.m_UIActionsCallbackInterfaces)
                UnregisterCallbacks(item);
            m_Wrapper.m_UIActionsCallbackInterfaces.Clear();
            AddCallbacks(instance);
        }
    }
    public UIActions @UI => new UIActions(this);
    public interface IPlayerMovementActions
    {
        void OnMovement(InputAction.CallbackContext context);
        void OnCamera(InputAction.CallbackContext context);
        void OnLockOnTargetLeft(InputAction.CallbackContext context);
        void OnLockOnTargetRight(InputAction.CallbackContext context);
    }
    public interface IPlayerActionsActions
    {
        void OnSprint(InputAction.CallbackContext context);
        void OnDodge(InputAction.CallbackContext context);
        void OnAttack(InputAction.CallbackContext context);
        void OnInteract(InputAction.CallbackContext context);
        void OnJump(InputAction.CallbackContext context);
        void OnOptions(InputAction.CallbackContext context);
        void OnLockOn(InputAction.CallbackContext context);
        void OnTwoHanding(InputAction.CallbackContext context);
        void OnCrouch(InputAction.CallbackContext context);
    }
    public interface IPlayerQuickSlotsActions
    {
        void OnDPadUp(InputAction.CallbackContext context);
        void OnDPadDown(InputAction.CallbackContext context);
        void OnDPadLeft(InputAction.CallbackContext context);
        void OnDPadRight(InputAction.CallbackContext context);
    }
    public interface IUIActions
    {
        void OnNavigate(InputAction.CallbackContext context);
        void OnSubmit(InputAction.CallbackContext context);
        void OnCancel(InputAction.CallbackContext context);
        void OnContextMenu(InputAction.CallbackContext context);
        void OnTabLeft(InputAction.CallbackContext context);
        void OnTabRight(InputAction.CallbackContext context);
    }
}


--- END FILE: Player Controls\PlayerControls.cs ---

--- START FILE: Player Controls\PlayerLocomotion.cs ---

using UnityEngine;

public class PlayerLocomotion : MonoBehaviour
{
    [Header("Camera Reference")]
    [SerializeField] private CameraController cameraController;

    private Transform playerTransform;
    private PlayerManager playerManager;
    private PlayerAnimator playerAnimator;
    private PlayerStats playerStats;

    public new Rigidbody rigidbody;

    [Header("Movement Stats")]
    [SerializeField] private float movementSpeed = 5f;
    [SerializeField] private float walkingSpeed = 2f;
    [SerializeField] private float sprintSpeed = 7f;
    [SerializeField] private float crouchSpeed = 1.5f;
    [SerializeField] private float rotationSpeed = 15f;
    [SerializeField] private float actionRotationSpeed = 7f;

    [Header("Jumping Stats")]
    [SerializeField] private float jumpForce = 7f;
    [SerializeField] private float airControlFactor = 0.2f;
    [SerializeField] private float maxAirSpeed = 4f; // Maximum horizontal speed while airborne

    [Header("Falling Stats")]
    [SerializeField] private float customGravity = 25f;
    [SerializeField] private float maxFallSpeed = 50f;

    [Header("Stamina Costs")]
    [SerializeField] private float dodgeStaminaCost = 10f;
    [SerializeField] private float jumpStaminaCost = 8f;
    [SerializeField] private float sprintTickStaminaCost = 8f;

    //[SerializeField] private float lockOnMovementForwardMultiplier = 0.125f;
    //[SerializeField] private float lockOnDodgeForwardMultiplier = 0.9f;

    [Header("Lock-On Movement Multipliers")]
    [SerializeField] private float lockOnStrafeSpeedMultiplier = 0.8f;
    [SerializeField] private float lockOnBackwardSpeedMultiplier = 0.6f;

    [Header("Ground & Air Detection Stats")]
    [SerializeField] private float groundDetectionRayStartPoint = 0.5f;
    //[SerializeField] private float minimumDistanceNeededToBeginFall = 1f;
    [SerializeField] private float groundDirectionRayDistance = 0.2f;
    [SerializeField] private LayerMask ignoreForGroundCheck;
    public float inAirTimer;

    // Input values
    private float horizontalInput;
    private float verticalInput;
    private float moveAmount;

    private Vector3 currentNormalVector = Vector3.up;
    private Vector3 rigidbodyVelocityRef = Vector3.zero;
    [SerializeField] private float movementSmoothTime = 0.08f;

    private bool applyJumpForceNextFixedUpdate = false;
    private bool _isJumpInitiatedThisFrame = false;

    private void Awake()
    {
        playerTransform = transform;
        rigidbody = GetComponent<Rigidbody>();
        playerManager = GetComponent<PlayerManager>();
        playerStats = GetComponent<PlayerStats>();
        playerAnimator = GetComponentInChildren<PlayerAnimator>();

        if (cameraController == null) Debug.LogError("CameraController not assigned on PlayerLocomotion!", this);
        
        if (playerAnimator == null) Debug.LogError("AnimatorHandler not found on children!", this);
        else playerAnimator.Initialize();

        if (playerManager == null) Debug.LogError("PlayerManager not found on this GameObject!", this);
        else playerAnimator.IsGrounded = true;

        if (playerStats == null) Debug.LogError("PlayerStats not found on this GameObject!", this);

        rigidbody.useGravity = false; // We use custom gravity
    }

    private void Update()
    {
        if (playerManager == null || cameraController == null) return;
        moveAmount = Mathf.Clamp01(Mathf.Abs(horizontalInput) + Mathf.Abs(verticalInput));

        if (playerAnimator != null)
        {
            playerAnimator.UpdateAnimatorValues(
                verticalInput,
                horizontalInput,
                playerManager.isSprinting,
                playerAnimator.IsCrouching,
                cameraController.IsLockedOn
            );
        }

        if (playerAnimator.IsInAir)
        {
            inAirTimer += Time.deltaTime;
        }

        if (playerManager.isSprinting && playerAnimator.IsGrounded)
        {
            if (playerStats.currentStamina > 0)
            {
                float staminaToConsumeThisFrame = sprintTickStaminaCost * Time.deltaTime;
                // ConsumeStamina will handle setting it to 0 if it overdrafts
                playerStats.ConsumeStamina(staminaToConsumeThisFrame);

                // If after consumption, stamina is 0, stop sprinting.
                if (playerStats.currentStamina <= 0)
                {
                    playerManager.isSprinting = false;
                }
            }
            else
            {
                playerManager.isSprinting = false;
            }
        }
    }

    private void FixedUpdate()
    {
        float deltaTime = Time.fixedDeltaTime;
        if (playerManager == null || cameraController == null) return;

        bool previousGroundedState = playerAnimator.IsGrounded;
        playerAnimator.IsGrounded = CheckGrounded();

        if (_isJumpInitiatedThisFrame)
        {
            playerAnimator.IsInAir = true;
        }

        HandleFallingAndLanding(deltaTime, previousGroundedState);

        if (applyJumpForceNextFixedUpdate)
        {
            ApplyActualJumpForce();
            applyJumpForceNextFixedUpdate = false;
        }

        if (playerAnimator.CanRotate)
        {
            HandleRotation(deltaTime);
        }

        if (playerAnimator.IsInMidAction && !playerAnimator.IsInAir) // If in a grounded action (not jumping/falling)
        {
            // If the action uses root motion, OnAnimatorMove handles it.
            // If not, and we want to prevent sliding:
            if (playerAnimator.anim != null && !playerAnimator.anim.applyRootMotion)
            {
                ApplyZeroHorizontalMovement();
            }
            return; // Let root motion or animation events control
        }

        if (playerAnimator.IsInAir)
        {
            HandleAirborneMovement(deltaTime);
            HandleAirborneRotation(deltaTime);
        }
        else // Grounded
        {
            HandleGroundedMovement(deltaTime);
        }

        _isJumpInitiatedThisFrame = false;
    }

    private void OnEnable()
    {
        InputHandler.PlayerMovementPerformed += HandleMovementInput;
    }

    private void OnDisable()
    {
        InputHandler.PlayerMovementPerformed -= HandleMovementInput;
    }

    private void HandleMovementInput(Vector2 movementInput)
    {
        horizontalInput = movementInput.x;
        verticalInput = movementInput.y;
    }

    private void HandleGroundedMovement(float deltaTime)
    {
        Vector3 targetMoveDirection;

        // Determine base move direction from input and camera/player orientation
        if (cameraController.IsLockedOn && !playerManager.isSprinting) // Lock-on movement (not sprinting)
        {
            // Player's local forward/right based on current facing (towards target)
            targetMoveDirection = playerTransform.forward * verticalInput + playerTransform.right * horizontalInput;
        }
        else // Free movement or sprinting
        {
            Vector3 cameraForward = cameraController.transform.forward;
            Vector3 cameraRight = cameraController.transform.right;
            cameraForward.y = 0;
            cameraRight.y = 0;
            cameraForward.Normalize();
            cameraRight.Normalize();
            targetMoveDirection = cameraForward * verticalInput + cameraRight * horizontalInput;
        }

        targetMoveDirection.Normalize(); // Ensure consistent speed for diagonal movement

        // Determine current speed based on state
        float currentSpeed;
        if (playerAnimator.IsCrouching)
        {
            currentSpeed = crouchSpeed;
        }
        else if (playerManager.isSprinting)
        {
            currentSpeed = sprintSpeed;
        }
        else // Walking or normal running based on input magnitude
        {
            // Used moveAmount (0-1) to blend between walk and run speed.
            // PlayerAnimatorHandler will determine if it's walk (0.5) or run (1.0) for animation.
            currentSpeed = (moveAmount > 0.5f) ? movementSpeed : walkingSpeed;
            if (moveAmount <= 0.01f) currentSpeed = 0; // No input, no speed
        }

        // Apply speed multipliers for lock-on if applicable
        if (cameraController.IsLockedOn && !playerAnimator.IsCrouching && !playerManager.isSprinting)
        {
            if (verticalInput < -0.1f) // Moving backward
            {
                currentSpeed *= lockOnBackwardSpeedMultiplier;
            }
            else if (Mathf.Abs(horizontalInput) > 0.1f && verticalInput >= -0.1f) // Strafing (and not primarily moving backward)
            {
                currentSpeed *= lockOnStrafeSpeedMultiplier;
            }
        }

        Vector3 finalVelocity = targetMoveDirection * currentSpeed;

        // Project onto ground normal
        finalVelocity = Vector3.ProjectOnPlane(finalVelocity, currentNormalVector);
        finalVelocity.y = rigidbody.velocity.y; // Preserve existing Y velocity for jump/fall continuity
        //finalVelocity.y = -1f;

        //rigidbody.velocity = Vector3.SmoothDamp(rigidbody.velocity, finalVelocity, ref rigidbodyVelocityRef, movementSmoothTime);
        rigidbody.velocity = finalVelocity;
    }

    private void HandleRotation(float deltaTime)
    {
        float currentRotationSpeedToUse = rotationSpeed;

        if (playerAnimator.IsInMidAction)
        {
            // If we're in an action, use the slower attack rotation speed.
            currentRotationSpeedToUse = actionRotationSpeed;
        }

        if (playerAnimator.IsCrouching && cameraController.IsLockedOn)
        {
            // Minimal rotation when crouched and locked on, primarily face target
            if (cameraController.CurrentLockOnTarget != null)
            {
                Vector3 directionToTarget = cameraController.CurrentLockOnTarget.transform.position - playerTransform.position;
                directionToTarget.y = 0;
                if (directionToTarget.sqrMagnitude > 0.01f)
                {
                    Quaternion targetRotation = Quaternion.LookRotation(directionToTarget.normalized);
                    //playerTransform.rotation = Quaternion.Slerp(playerTransform.rotation, targetRotation, rotationSpeed * deltaTime * 0.5f); // Slower rotation
                    playerTransform.rotation = Quaternion.Slerp(playerTransform.rotation, targetRotation, currentRotationSpeedToUse * deltaTime * 0.5f);
                }
            }
            return;
        }

        Vector3 targetDir;
        if (cameraController.IsLockedOn && !playerManager.isSprinting) // Prioritize facing lock-on target
        {
            if (cameraController.CurrentLockOnTarget != null)
            {
                targetDir = cameraController.CurrentLockOnTarget.transform.position - playerTransform.position;
            }
            else targetDir = playerTransform.forward; // Fallback
        }
        else // Free look rotation based on movement input relative to camera
        {
            Vector3 camForward = cameraController.transform.forward;
            Vector3 camRight = cameraController.transform.right;
            camForward.y = 0;
            camRight.y = 0;
            camForward.Normalize();
            camRight.Normalize();

            targetDir = camForward * verticalInput + camRight * horizontalInput;
        }
        targetDir.y = 0;

        bool canRotateBasedOnInput = moveAmount > 0.01f || playerManager.charAnimManager.IsInMidAction;

        if (targetDir.sqrMagnitude < 0.01f && !cameraController.IsLockedOn)
        {
            return; // Don't rotate if no input, not locked on, and not in an action
        }
        if (targetDir.sqrMagnitude < 0.01f && cameraController.IsLockedOn) // If locked on but no move input, still face target
        {
            if (cameraController.CurrentLockOnTarget != null)
                targetDir = cameraController.CurrentLockOnTarget.transform.position - playerTransform.position;
            else targetDir = playerTransform.forward;
            targetDir.y = 0;
        }

        // Ensure targetDir is not zero before normalizing, important if we allow rotation during attacks with no movement input
        if (targetDir.sqrMagnitude > 0.001f)
        {
            targetDir.Normalize();
            var tr = Quaternion.LookRotation(targetDir);
            playerTransform.rotation = Quaternion.Slerp(playerTransform.rotation, tr, currentRotationSpeedToUse * deltaTime);
        }
    }

    public void HandleDodgeTapped()
    {
        if (playerAnimator.IsInMidAction || !playerAnimator.IsGrounded) return;
        if (playerAnimator.IsCrouching) playerManager.ToggleCrouchState(); // Stand up to dodge
        PerformDodge();
    }

    private void PerformDodge()
    {
        playerStats.ConsumeStamina(dodgeStaminaCost);

        playerManager.charAnimManager.IsInMidAction = true; // Player is busy
        playerAnimator.IsDodging = true;

        Vector3 dodgeDir;

        if (moveAmount > 0.01f) // Directional Dodge / Roll
        {
            if (cameraController.IsLockedOn)
            {
                dodgeDir = playerTransform.forward * verticalInput + playerTransform.right * horizontalInput;
            }
            else
            {
                Vector3 camForward = cameraController.transform.forward;
                Vector3 camRight = cameraController.transform.right;
                camForward.y = 0; camRight.y = 0; camForward.Normalize(); camRight.Normalize();
                dodgeDir = camForward * verticalInput + camRight * horizontalInput;
            }
            dodgeDir.Normalize();

            var dodgeAngle = Vector3.SignedAngle(playerTransform.forward, dodgeDir, Vector3.up);
            playerAnimator.RollDirection = AngleToDirection8(dodgeAngle);

            if (dodgeDir.sqrMagnitude > 0.01f && !cameraController.IsLockedOn)
            {
                playerTransform.rotation = Quaternion.LookRotation(dodgeDir);
            }
        }
        else // Neutral Dodge / Backstep
        {
            playerAnimator.RollDirection = -1; // Backstep animation
            // No need to change rotation for backstep typically
        }
        playerAnimator.ApplyRootMotion(true);
        // Root motion will handle movement. OnDodgeAnimationEnd resets flags.
    }

    private int AngleToDirection8(float angle)
    {
        // Normalize the angle to 0-360 range first
        float normalizedAngle = (angle + 360) % 360;

        // Divide the circle into 8 sectors (45 degrees each)
        // Add 22.5 to shift the sectors so 0 is centered at North/Up
        int direction = (int)((normalizedAngle + 22.5f) / 45f) % 8;

        return direction;
    }

    public void OnDodgeAnimationEnd()
    {
        playerAnimator.IsInMidAction = false;
        playerAnimator.IsDodging = false;
    }

    public void HandleSprintHolding()
    {
        if (playerAnimator.IsCrouching || playerAnimator.IsInMidAction || !playerAnimator.IsGrounded)
        {
            playerManager.isSprinting = false; // Can't sprint if crouching or in action
            return;
        }
        playerManager.isSprinting = moveAmount > 0.5f;
    }

    public void HandleSprintReleased()
    {
        playerManager.isSprinting = false;
    }

    private bool CheckGrounded()
    {
        Vector3 rayStart = playerTransform.position + (Vector3.up * groundDetectionRayStartPoint);
        float rayLength = groundDetectionRayStartPoint + groundDirectionRayDistance; // Total length from player pivot + startPoint offset
        bool hitGround = Physics.Raycast(rayStart, Vector3.down, out RaycastHit hit, rayLength, ~ignoreForGroundCheck, QueryTriggerInteraction.Ignore);

        Debug.DrawRay(rayStart, Vector3.down * rayLength, hitGround ? Color.green : Color.red);

        if (hitGround)
        {
            currentNormalVector = hit.normal;
            return true;
        }
        else
        {
            currentNormalVector = Vector3.up;
            return false;
        }
    }

    private void HandleFallingAndLanding(float deltaTime, bool wasGroundedLastFrame)
    {
        // Becoming airborne (walked off ledge OR jump force has taken effect)
        if (!playerAnimator.IsGrounded && !playerAnimator.IsInAir)
        {
            playerAnimator.IsInAir = true;
            inAirTimer = 0;
            if (!IsCurrentlyInJumpAnimation()) // Only play falling if not in a specific jump anim
            {
                playerAnimator.PlayTargetAnimation("Jump_Idle", true);
            }
            Debug.Log("Became airborne (not from immediate jump press this frame).");
        }

        if (playerAnimator.IsInAir)
        {
            rigidbody.AddForce(Vector3.down * customGravity, ForceMode.Acceleration);
            if (rigidbody.velocity.y < -maxFallSpeed)
            {
                rigidbody.velocity = new Vector3(rigidbody.velocity.x, -maxFallSpeed, rigidbody.velocity.z);
            }
        }

        // The critical part is to distinguish a real landing from the initial grounded state when jump is pressed.
        // wasGroundedLastFrame is used to detect a transition from air to ground.
        if (playerAnimator.IsGrounded && wasGroundedLastFrame == false && playerAnimator.IsInAir) // JUST LANDED (was in air, now grounded)
        {
            playerAnimator.IsInAir = false;
            inAirTimer = 0;
            //animatorHandler.PlayTargetAnimation("Jump_End", true);
            //playerManager.charAnimManager.IsInMidAction = false;
            Debug.Log("Landed from air. Playing Jump_End animation.");
        }
    }

    private bool IsCurrentlyInJumpAnimation()
    {
        if (playerAnimator == null || playerAnimator.anim == null) return false;
        AnimatorStateInfo stateInfo = playerAnimator.anim.GetCurrentAnimatorStateInfo(0);
        return stateInfo.IsName("Jump_Start") || stateInfo.IsName("Jump_Lift");
    }

    public void FinishJumpAction() // Called by animation event from Jump_End animation
    {
        playerAnimator.IsInMidAction = false;
        Debug.Log("Jump/Land Action Finished.");
    }

    public void HandleJumpButtonPressed()
    {
        if (playerAnimator.IsInMidAction || !playerAnimator.IsGrounded)
        {
            return;
        }

        playerStats.ConsumeStamina(jumpStaminaCost);

        if (playerAnimator.IsCrouching)
        {
            playerManager.ToggleCrouchState();
            if (playerAnimator.IsCrouching) return;
        }

        playerAnimator.IsInAir = true;
        _isJumpInitiatedThisFrame = true;
        inAirTimer = 0;

        // An animation event on Jump_Start or Jump_Lift will call animatorHandler.AnimEvent_ApplyJumpForce()
        playerAnimator.PlayTargetAnimation("Jump_Start", true, rootMotion: false);
        Debug.Log("Jump Initiated, playing Jump_Start. Force will be applied via AnimEvent.");
    }

    public void TriggerApplyJumpForce() // Called by AnimatorHandler via Animation Event
    {
        applyJumpForceNextFixedUpdate = true;
    }

    private void ApplyActualJumpForce()
    {
        // Reset vertical velocity before applying new jump force to ensure consistent jump height
        rigidbody.velocity = new Vector3(rigidbody.velocity.x, 0, rigidbody.velocity.z);
        rigidbody.AddForce(Vector3.up * jumpForce, ForceMode.Impulse);

        // Add a bit of forward momentum based on current movement input
        Vector3 cameraForward = cameraController.transform.forward;
        Vector3 cameraRight = cameraController.transform.right;
        cameraForward.y = 0; cameraRight.y = 0;
        cameraForward.Normalize(); cameraRight.Normalize();
        Vector3 moveInputDirection = (cameraForward * verticalInput + cameraRight * horizontalInput).normalized;
        if (moveAmount > 0.1f) // Only if there's movement input
        {
            rigidbody.AddForce(moveInputDirection * moveAmount * (jumpForce * 0.2f), ForceMode.Impulse); // Smaller force forward
        }

        // Animator should transition from Jump_Start/Jump_Lift to Jump_Idle.
        //animatorHandler.PlayTargetAnimation("Jump_Idle", false);
        Debug.Log("Jump Force Applied. Should be in Jump_Idle animation.");
    }

    private void HandleAirborneMovement(float deltaTime)
    {
        if (moveAmount <= 0.01f) return; // No input, no air control

        Vector3 cameraForward = cameraController.transform.forward;
        Vector3 cameraRight = cameraController.transform.right;
        cameraForward.y = 0; cameraRight.y = 0;
        cameraForward.Normalize(); cameraRight.Normalize();

        Vector3 desiredMoveDirection = (cameraForward * verticalInput + cameraRight * horizontalInput).normalized;

        // Get current horizontal velocity
        Vector3 currentHorizontalVelocity = new Vector3(rigidbody.velocity.x, 0, rigidbody.velocity.z);

        // Calculate desired velocity based on input
        Vector3 targetVelocity = desiredMoveDirection * (movementSpeed * airControlFactor);

        // Calculate the difference between current and desired velocity
        Vector3 velocityDifference = targetVelocity - currentHorizontalVelocity;

        // Limit the acceleration to prevent sudden velocity changes (teleportation)
        float maxAcceleration = airControlFactor * movementSpeed * 2f; // Adjust multiplier as needed
        if (velocityDifference.magnitude > maxAcceleration * deltaTime)
        {
            velocityDifference = velocityDifference.normalized * maxAcceleration * deltaTime;
        }

        // Apply the limited velocity change
        Vector3 newVelocity = currentHorizontalVelocity + velocityDifference;

        // Clamp to maximum air speed
        if (newVelocity.magnitude > maxAirSpeed)
        {
            newVelocity = newVelocity.normalized * maxAirSpeed;
        }

        // Set the new velocity
        rigidbody.velocity = new Vector3(newVelocity.x, rigidbody.velocity.y, newVelocity.z);
    }

    private void HandleAirborneRotation(float deltaTime)
    {
        // Less rotation control in air, or only allow minor adjustments
        if (moveAmount > 0.1f) // Only rotate if there's input
        {
            Vector3 camForward = cameraController.transform.forward;
            Vector3 camRight = cameraController.transform.right;
            camForward.y = 0; camRight.y = 0;
            camForward.Normalize(); camRight.Normalize();
            Vector3 targetDir = camForward * verticalInput + camRight * horizontalInput;
            targetDir.y = 0;
            if (targetDir.sqrMagnitude > 0.01f)
            {
                targetDir.Normalize();
                Quaternion tr = Quaternion.LookRotation(targetDir);
                playerTransform.rotation = Quaternion.Slerp(playerTransform.rotation, tr, rotationSpeed * deltaTime * 0.5f); // Slower air rotation
            }
        }
    }

    private void ApplyZeroHorizontalMovement()
    {
        Vector3 targetVelocity = new Vector3(0, rigidbody.velocity.y, 0);
        rigidbody.velocity = Vector3.SmoothDamp(rigidbody.velocity, targetVelocity, ref rigidbodyVelocityRef, movementSmoothTime * 0.2f); // Very quick stop
    }
}


--- END FILE: Player Controls\PlayerLocomotion.cs ---

--- START FILE: ScriptableObjects\EnemyActionSO.cs ---

using UnityEngine;

public abstract class EnemyActionSO : ScriptableObject
{
    [Header("Base Action Info")]
    public string actionName = "Unnamed Action";
    public string animationName;
    public float recoveryTime = 1.0f;
    public float staminaCost = 0f;

    // TODO:
    // public AudioClip[] actionSounds;
    // public GameObject[] actionVFX;
}


--- END FILE: ScriptableObjects\EnemyActionSO.cs ---

--- START FILE: ScriptableObjects\EnemyAttackActionSO.cs ---

using UnityEngine;

[CreateAssetMenu(menuName = "SO/AI/Enemy Actions/Attack Action")]
public class EnemyAttackActionSO : EnemyActionSO
{
    [Header("Attack Specifics")]
    public float minAttackDistance = 0f;
    public float maxAttackDistance = 3f;
    public float minAttackAngle = -35f;
    public float maxAttackAngle = 35f;

    public int damage = 20;
    public DamageType damageType = DamageType.Standard;
    public float poiseDamage = 10f;

    public bool canBeParried = true;
    public bool isHeavyAttack = false;

    [Header("Scoring Properties")]
    public int baseScore = 10; // Default desirability
    [Tooltip("Multiplier if target is close (e.g., within 0.5 * maxAttackDistance)")]
    public float closeRangeScoreMultiplier = 1.0f;
    [Tooltip("Multiplier if target is at medium range")]
    public float midRangeScoreMultiplier = 1.0f;
    [Tooltip("Multiplier if target is at far range (e.g., beyond 0.75 * maxAttackDistance but still in range)")]
    public float farRangeScoreMultiplier = 1.0f;

    [Tooltip("Multiplier if target's health is low (e.g., below 30%)")]
    public float targetLowHealthScoreMultiplier = 1.0f;
    [Tooltip("Multiplier if this enemy's health is low")]
    public float selfLowHealthScoreMultiplier = 1.0f;

    [Tooltip("Cooldown specifically for this attack after it's used (0 means use general combat cooldown)")]
    public float specificAttackCooldown = 0f;

    public virtual int CalculateScore(EnemyManager self, CharacterManager target, float distanceToTarget, float angleToTarget)
    {
        if (target == null) return 0;

        int currentScore = baseScore;

        // Range-based scoring
        if (distanceToTarget <= minAttackDistance + (maxAttackDistance - minAttackDistance) * 0.33f) // Close
            currentScore = Mathf.RoundToInt(currentScore * closeRangeScoreMultiplier);
        else if (distanceToTarget <= minAttackDistance + (maxAttackDistance - minAttackDistance) * 0.66f) // Mid
            currentScore = Mathf.RoundToInt(currentScore * midRangeScoreMultiplier);
        else // Far
            currentScore = Mathf.RoundToInt(currentScore * farRangeScoreMultiplier);

        // Target health-based scoring
        CharacterStats targetStats = target.GetComponent<CharacterStats>();
        if (targetStats != null && targetStats.currentHealth / (float)targetStats.maxHealth < 0.3f) // Target health < 30%
        {
            currentScore = Mathf.RoundToInt(currentScore * targetLowHealthScoreMultiplier);
        }

        // Self health-based scoring
        if (self.Stats != null && self.Stats.currentHealth / (float)self.Stats.maxHealth < 0.3f) // Self health < 30%
        {
            currentScore = Mathf.RoundToInt(currentScore * selfLowHealthScoreMultiplier);
        }

        // TODO: More complex scoring logic
        // e.g., if player is casting, bonus to fast attacks
        // e.g., if player just whiffed an attack, bonus to counter-attacks
        // e.g., if this attack is on its specific cooldown, return 0 or very low score

        return Mathf.Max(0, currentScore);
    }

    public bool IsBasicConditionsMet(float distanceToTarget, float angleToTarget)
    {
        return distanceToTarget >= minAttackDistance && distanceToTarget <= maxAttackDistance &&
               angleToTarget >= minAttackAngle && angleToTarget <= maxAttackAngle;
    }
}

--- END FILE: ScriptableObjects\EnemyAttackActionSO.cs ---

--- START FILE: ScriptableObjects\EnemyBackstabActionSO.cs ---

using UnityEngine;

[CreateAssetMenu(menuName = "SO/AI/Enemy Actions/Backstab Action")]
public class EnemyBackstabActionSO : EnemyActionSO
{
    [Header("Backstab Specifics")]
    public int backstabDamage = 150;
}


--- END FILE: ScriptableObjects\EnemyBackstabActionSO.cs ---

--- START FILE: Testing\DamagePlayer.cs ---

using UnityEngine;

public class DamagePlayer : MonoBehaviour
{
    [SerializeField] private int damage = 25;

    private void OnTriggerEnter(Collider other)
    {
        PlayerStats playerStats = other.GetComponent<PlayerStats>();

        if (playerStats != null )
        {
            playerStats.TakeDamange(damage, transform);
        }
    }
}


--- END FILE: Testing\DamagePlayer.cs ---

--- START FILE: Testing\FollowTarget.cs ---

using UnityEngine;
using UnityEngine.AI;

public class FollowTarget : MonoBehaviour
{
    public Transform target;

    private NavMeshAgent navMeshAgent;

    private void Start()
    {
        navMeshAgent = GetComponent<NavMeshAgent>();
        navMeshAgent.SetDestination(target.position);
    }


}


--- END FILE: Testing\FollowTarget.cs ---

--- START FILE: UI\BuffIconUI.cs ---

using UnityEngine;
using UnityEngine.UI;
using TMPro;

public class BuffIconUI : MonoBehaviour
{
    [SerializeField] private Image buffIcon;
    [SerializeField] private TMP_Text buffNameText;
    [SerializeField] private TMP_Text durationText;

    public void SetBuff(ActiveBuffInfo buffInfo)
    {
        if (buffIcon != null) buffIcon.sprite = buffInfo.BuffIcon;
        if (buffNameText != null) buffNameText.text = buffInfo.BuffName;
        if (durationText != null)
        {
            // Show duration, rounding up to nearest second for display
            durationText.text = Mathf.CeilToInt(buffInfo.RemainingDuration).ToString();
        }
    }
}


--- END FILE: UI\BuffIconUI.cs ---

--- START FILE: UI\CurrencyUI.cs ---

using UnityEngine;
using TMPro;

public class CurrencyUI : MonoBehaviour
{
    [SerializeField] private TMP_Text currencyText;
    [SerializeField] private PlayerStats playerStats;

    private void Awake()
    {
        if (currencyText == null)
        {
            currencyText = GetComponent<TMP_Text>();
        }
        if (currencyText == null)
        {
            Debug.LogError("CurrencyUI: TextMeshPro component not assigned or found!", this);
            enabled = false;
        }
        if (playerStats == null)
        {
            Debug.LogError("Player Stats is not assigned for Currency UI", this);
        }
    }

    private void OnEnable()
    {
        PlayerStats.OnCurrencyChanged += UpdateCurrencyText;

        if (playerStats != null)
        {
            UpdateCurrencyText(playerStats.currentCurrency);
        }
    }

    private void OnDisable()
    {
        PlayerStats.OnCurrencyChanged -= UpdateCurrencyText;
    }

    private void UpdateCurrencyText(int newAmount)
    {
        currencyText.text = newAmount.ToString();
    }
}


--- END FILE: UI\CurrencyUI.cs ---

--- START FILE: UI\EnemyHealthBarUI.cs ---

using UnityEngine;
using UnityEngine.UI;

public class EnemyHealthBarUI : MonoBehaviour
{
    [SerializeField] private Slider healthSlider;
    private Transform cameraToFace;
    private EnemyStats enemyStats;

    public void Initialize(EnemyStats stats)
    {
        enemyStats = stats;
        if (healthSlider == null) healthSlider = GetComponentInChildren<Slider>();

        if (enemyStats != null)
        {
            // Subscribe to the health changed event
            enemyStats.OnHealthChanged += UpdateHealthBar;
            // Also subscribe to death event to properly hide/destroy itself
            enemyStats.OnDeathEvent += HandleDeath;
        }

        // Find the main camera
        if (Camera.main != null) cameraToFace = Camera.main.transform;

        // Start with the health bar hidden
        gameObject.SetActive(false);
    }

    private void LateUpdate()
    {
        // Make the health bar always face the camera
        if (cameraToFace != null)
        {
            transform.LookAt(transform.position + cameraToFace.rotation * Vector3.forward,
                             cameraToFace.rotation * Vector3.up);
        }
    }

    private void OnDestroy()
    {
        if (enemyStats != null)
        {
            enemyStats.OnHealthChanged -= UpdateHealthBar;
            enemyStats.OnDeathEvent -= HandleDeath;
        }
    }

    private void UpdateHealthBar(int currentHealth, int maxHealth)
    {
        if (healthSlider.maxValue != maxHealth)
        {
            healthSlider.maxValue = maxHealth;
        }
        healthSlider.value = currentHealth;

        // If health is not full, it means damage has been taken.
        if (currentHealth < maxHealth && !gameObject.activeInHierarchy)
        {
            gameObject.SetActive(true);
        }
    }

    private void HandleDeath()
    {
        gameObject.SetActive(false);
        Destroy(gameObject, 1f); // Destroy after a short delay to avoid errors
    }

    public void SetVisibility(bool isVisible)
    {
        // Only show if health is not full
        if (isVisible && enemyStats != null && enemyStats.currentHealth < enemyStats.maxHealth)
        {
            gameObject.SetActive(true);
        }
        else
        {
            gameObject.SetActive(false);
        }
    }
}

--- END FILE: UI\EnemyHealthBarUI.cs ---

--- START FILE: UI\EquipmentSlotUI.cs ---

using UnityEngine;
using UnityEngine.UI;
using TMPro;
using UnityEngine.EventSystems;

public enum EquipmentSlotCategory { RightHand, LeftHand, Armor, Head, Body, Hands, Legs, Talisman, Consumable }

public class EquipmentSlotUI : MonoBehaviour, IPointerEnterHandler, ISelectHandler
{
    [Header("Slot Info")]
    public EquipmentSlotCategory slotCategory;
    public int slotIndex; // 0-2 for RightHand, 0-3 for Talisman, etc.

    [Header("UI References")]
    [SerializeField] private Image icon;
    [SerializeField] private TMP_Text itemNameText;
    [SerializeField] private UIManager uiManager;
    [SerializeField] private ItemInfoPanelUI itemInfoPanel;

    private Item currentItem;

    public void UpdateSlot(Item item)
    {
        currentItem = item;
        if (currentItem != null && currentItem.itemIcon != null)
        {
            icon.sprite = currentItem.itemIcon;
            icon.enabled = true;
            if (itemNameText != null) itemNameText.text = currentItem.name;
        }
        else
        {
            icon.sprite = null;
            icon.enabled = false;
            if (itemNameText != null) itemNameText.text = "";
        }
    }

    public void OnSlotClicked()
    {
        uiManager.ShowInventoryForSelection(this);
    }

    public void OnPointerEnter(PointerEventData eventData)
    {
        if (itemInfoPanel != null)
        {
            itemInfoPanel.DisplayItemInfo(currentItem);
        }
    }

    // For controller navigation
    public void OnSelect(BaseEventData eventData)
    {
        if (itemInfoPanel != null)
        {
            itemInfoPanel.DisplayItemInfo(currentItem);
        }
    }
}


--- END FILE: UI\EquipmentSlotUI.cs ---

--- START FILE: UI\EquipmentWindowUI.cs ---

using System.Collections.Generic;
using UnityEngine;

public class EquipmentWindowUI : MonoBehaviour
{
    [Header("Core References")]
    [SerializeField] private PlayerInventory playerInventory;
    [SerializeField] private ItemInfoPanelUI itemInfoPanel;
    [SerializeField] private UIManager uiManager;

    [Header("Slot Containers")]
    [SerializeField] private List<EquipmentSlotUI> rightHandSlots = new ();
    // [SerializeField] private List<EquipmentSlotUI> leftHandSlots = new ();
    [SerializeField] private EquipmentSlotUI headArmorSlot;
    [SerializeField] private EquipmentSlotUI bodyArmorSlot;
    [SerializeField] private EquipmentSlotUI handArmorSlot;
    [SerializeField] private EquipmentSlotUI legArmorSlot;
    [SerializeField] private List<EquipmentSlotUI> talismanSlots = new ();
    [SerializeField] private List<EquipmentSlotUI> consumableSlots = new ();

    private void OnEnable()
    {
        // Subscribe to the event when the window becomes active
        PlayerInventory.OnEquipmentUpdated += RefreshAllSlots;

        // Immediately hide the info panel when this window is shown
        if (itemInfoPanel != null)
        {
            itemInfoPanel.ClearPanel();
        }

        // Immediately populate with current equipment state
        RefreshAllSlots();
    }

    private void OnDisable()
    {
        // Unsubscribe when the window is hidden to prevent unnecessary updates
        PlayerInventory.OnEquipmentUpdated -= RefreshAllSlots;
    }

    public void RefreshAllSlots()
    {
        if (playerInventory == null) return;

        // --- Right Hand Weapon Slots ---
        for (int i = 0; i < rightHandSlots.Count; i++)
        {
            if (i < playerInventory.rightHandWeaponSlots.Length)
            {
                rightHandSlots[i].UpdateSlot(playerInventory.rightHandWeaponSlots[i]);
            }
            else // UI has more slots than inventory logic supports, hide extra
            {
                rightHandSlots[i].UpdateSlot(null);
            }
        }

        // --- Armor Slots ---
        headArmorSlot?.UpdateSlot(playerInventory.headArmor);
        bodyArmorSlot?.UpdateSlot(playerInventory.bodyArmor);
        handArmorSlot?.UpdateSlot(playerInventory.handArmor);
        legArmorSlot?.UpdateSlot(playerInventory.legArmor);

        // --- Talisman Slots ---
        for (int i = 0; i < talismanSlots.Count; i++)
        {
            if (i < playerInventory.talismanSlots.Length)
            {
                talismanSlots[i].UpdateSlot(playerInventory.talismanSlots[i]);
            }
            else
            {
                talismanSlots[i].UpdateSlot(null);
            }
        }

        // --- Consumable Slots ---
        for (int i = 0; i < consumableSlots.Count; i++)
        {
            if (consumableSlots[i] != null) // Check the UI slot exists
            {
                if (i < playerInventory.consumableQuickSlots.Count)
                {
                    InventorySlot inventorySlot = playerInventory.consumableQuickSlots[i];
                    // Pass the item from the slot, which can be null if the slot is empty
                    consumableSlots[i].UpdateSlot(inventorySlot?.item);
                }
                else
                {
                    consumableSlots[i].UpdateSlot(null);
                }
            }
        }
    }
}


--- END FILE: UI\EquipmentWindowUI.cs ---

--- START FILE: UI\HandEquipmentSlotUI.cs ---

using UnityEngine;
using UnityEngine.UI;

public class HandEquipmentSlotUI : MonoBehaviour
{
    [SerializeField] private UIManager uiManager;
    [SerializeField] private Image icon;
    private Item item;

    //public EquipSlotType equipSlotType;


    public void AddItem(Item newItem)
    {
        item = newItem;
        icon.sprite = item.itemIcon;
        icon.enabled = true;
        gameObject.SetActive(true);
    }

    public void ClearItem()
    {
        item = null;
        icon.sprite = null;
        icon.enabled = false;
        gameObject.SetActive(false);
    }

    public void SelectSlot()
    {
        //uiManager.currentSelectedSlotType = equipSlotType;
    }
}


--- END FILE: UI\HandEquipmentSlotUI.cs ---

--- START FILE: UI\InteractableUI.cs ---

using TMPro;
using UnityEngine;
using UnityEngine.UI;

public class InteractableUI : MonoBehaviour
{
    public GameObject interactionPopUp;
    public GameObject itemPopUp;

    public TMP_Text interactableInfoText;
    public TMP_Text itemInfoText;
    public Image itemImage;

    public void EnableInteractionPopUpGameObject(bool isEnabled)
    {
        interactionPopUp.SetActive(isEnabled);
    }

    public void EnableItemPopUpGameObject(bool isEnabled)
    {
        itemPopUp.SetActive(isEnabled);
    }
}


--- END FILE: UI\InteractableUI.cs ---

--- START FILE: UI\InventorySlotUI.cs ---

using UnityEngine;
using UnityEngine.UI;
using UnityEngine.EventSystems;
using TMPro;

public class InventorySlotUI : MonoBehaviour, IPointerEnterHandler, ISelectHandler
{
    [SerializeField] private Image icon;
    [SerializeField] private TMP_Text quantityText;
    [SerializeField] private GameObject equippedIndicator; // A small dot/image

    private InventorySlot heldSlotData;
    private InventoryWindowUI parentWindow;

    public void Initialize(InventorySlot slotData, InventoryWindowUI parent)
    {
        heldSlotData = slotData;
        parentWindow = parent;

        icon.sprite = slotData.item.itemIcon;
        icon.enabled = true;

        // Show quantity text only if stackable (quantity > 1)
        if (quantityText != null)
        {
            if (slotData.item is ConsumableItem)
            {
                quantityText.text = slotData.quantity.ToString();
                quantityText.gameObject.SetActive(true);
            }
            else
            {
                quantityText.gameObject.SetActive(false);
            }
        }

        if (equippedIndicator != null) equippedIndicator.SetActive(false);
    }

    public Item GetItem() => heldSlotData?.item;
    public InventorySlot GetSlotData() => heldSlotData;

    public void SetEquipped(bool isEquipped)
    {
        if (equippedIndicator != null) equippedIndicator.SetActive(isEquipped);
    }

    // For mouse hover
    public void OnPointerEnter(PointerEventData eventData)
    {
        parentWindow?.OnSlotSelected(this);
    }

    // For controller navigation
    public void OnSelect(BaseEventData eventData)
    {
        parentWindow?.OnSlotSelected(this);
    }

    // Called by an EventTrigger component for Right-Click or a Button component for Submit
    public void OnInteract()
    {
        parentWindow?.OnSlotInteracted(this);
    }
}

--- END FILE: UI\InventorySlotUI.cs ---

--- START FILE: UI\InventoryWindowUI.cs ---

using System;
using System.Collections.Generic;
using System.Linq;
using Unity.VisualScripting.Antlr3.Runtime.Misc;
using UnityEngine;

public class InventoryWindowUI : MonoBehaviour
{
    [SerializeField] private PlayerInventory playerInventory;
    [SerializeField] private Transform itemGridParent;
    [SerializeField] private GameObject inventorySlotPrefab;
    [SerializeField] private GameObject unequipSlotPrefab;
    [SerializeField] private ItemInfoPanelUI itemInfoPanel;
    [SerializeField] private ItemInteractionFooterUI interactionFooter;
    // [SerializeField] private ItemContextMenuUI contextMenu;

    [Header("Tab Management")]
    [SerializeField] private GameObject tabsContainer; // The parent GameObject of your tab buttons
    [SerializeField] private List<TabButtonUI> tabButtons = new List<TabButtonUI>();

    // --- Selection Mode State ---
    private bool isInSelectionMode = false;
    private EquipmentSlotCategory selectionCategory;
    private int selectionSlotIndex;

    private int currentTabIndex = 0; // 0=Weapons, 1=Armor, 2=Talismans, 3=Consumables
    private EquipmentSlotCategory equipmentTypeFilter;

    private void Awake()
    {
        interactionFooter?.Initialize(this);
    }

    private void OnEnable()
    {
        PlayerInventory.OnInventoryUpdated += RefreshUI; // Refresh if inventory changes
        PlayerInventory.OnEquipmentUpdated += RefreshUI; // Also refresh on equip changes to update dots
        InputHandler.UITabLeftPressed += SwitchToPreviousTab;
        InputHandler.UITabRightPressed += SwitchToNextTab;

        // Immediately hide the info panel when this window is shown
        if (itemInfoPanel != null)
        {
            itemInfoPanel.ClearPanel();
        }
        interactionFooter?.Hide();

        RefreshUI(); // Initial population
    }

    private void OnDisable()
    {
        PlayerInventory.OnInventoryUpdated -= RefreshUI;
        PlayerInventory.OnEquipmentUpdated += RefreshUI;
        InputHandler.UITabLeftPressed -= SwitchToPreviousTab;
        InputHandler.UITabRightPressed -= SwitchToNextTab;
    }

    public void SwitchToNextTab() => SwitchTab(1);
    private void SwitchToPreviousTab() => SwitchTab(-1);

    private void SwitchTab(int direction)
    {
        currentTabIndex += direction;
        if (currentTabIndex > 3) currentTabIndex = 0;
        if (currentTabIndex < 0) currentTabIndex = 3;

        SetCurrentTab(currentTabIndex);
    }

    public void SetCurrentTab(int tabIndex)
    {
        if (tabIndex < 0 || tabIndex >= tabButtons.Count) return;

        currentTabIndex = tabIndex;
        RefreshUI();
    }

    private void UpdateTabButtonVisuals()
    {
        for (int i = 0; i < tabButtons.Count; i++)
        {
            if (tabButtons[i] != null)
            {
                tabButtons[i].SetActiveState(i == currentTabIndex);
            }
        }
    }

    public void OpenInSelectionMode(EquipmentSlotCategory category, int slotIndex)
    {
        isInSelectionMode = true;
        selectionCategory = category;
        selectionSlotIndex = slotIndex;

        // Disable tab switching
        if (tabsContainer != null) tabsContainer.SetActive(false);
        InputHandler.UITabLeftPressed -= SwitchToPreviousTab;
        InputHandler.UITabRightPressed -= SwitchToNextTab;

        // Force to the correct tab for the item type
        currentTabIndex = GetTabIndexForCategory(category);
        equipmentTypeFilter = category;

        // Refresh the UI to show only the filtered items
        RefreshUI();
    }

    public void ExitSelectionMode()
    {
        isInSelectionMode = false;

        // Re-enable tab switching
        if (tabsContainer != null) tabsContainer.SetActive(true);
        InputHandler.UITabLeftPressed += SwitchToPreviousTab;
        InputHandler.UITabRightPressed += SwitchToNextTab;
    }

    public void RefreshUI()
    {
        if (!gameObject.activeInHierarchy) return;

        UpdateTabButtonVisuals();

        // Clear existing slots
        foreach (Transform child in itemGridParent)
        {
            Destroy(child.gameObject);
        }

        if (isInSelectionMode)
        {
            Item itemInTargetSlot = playerInventory.GetItemInSlot(selectionCategory, selectionSlotIndex);
            if (itemInTargetSlot != null) // Only show unequip if the slot isn't already empty
            {
                // Instantiate the dedicated unequip prefab
                GameObject unequipGO = Instantiate(unequipSlotPrefab, itemGridParent);
                UnequipSlotUI unequipSlotUI = unequipGO.GetComponent<UnequipSlotUI>();
                if (unequipSlotUI != null)
                {
                    unequipSlotUI.Initialize(this);
                }
            }
        }

        // Populate based on current tab
        IEnumerable<InventorySlot> slotsToDisplay = currentTabIndex switch
        {
            0 => playerInventory.weaponsInventory,
            1 => playerInventory.armorInventory,
            2 => playerInventory.talismanInventory,
            3 => playerInventory.consumableInventory,
            _ => null
        };

        if (currentTabIndex == 1 && isInSelectionMode)
        {
            ArmorType typeToFilter = SlotCategoryToArmorType(selectionCategory);
            slotsToDisplay = playerInventory.armorInventory.Where(slot => (slot.item as ArmorItem)?.armorType == typeToFilter).ToList();
        }

        PopulateGrid(slotsToDisplay);
    }

    private Func<InventorySlot, bool> ItemIsOfArmorType(ArmorType armorType)
    {
        return slot => (slot.item as ArmorItem).armorType == armorType;
    }

    private ArmorType SlotCategoryToArmorType(EquipmentSlotCategory slotCategory)
    {
        return slotCategory switch
        {
            EquipmentSlotCategory.Head => ArmorType.Head,
            EquipmentSlotCategory.Body => ArmorType.Body,
            EquipmentSlotCategory.Legs => ArmorType.Legs,
            EquipmentSlotCategory.Hands => ArmorType.Hands,
            _ => (ArmorType)(-1)
        };
    }

    private void PopulateGrid(IEnumerable<InventorySlot> slots)
    {
        foreach (var slotData in slots)
        {
            GameObject slotGO = Instantiate(inventorySlotPrefab, itemGridParent);
            InventorySlotUI slotUI = slotGO.GetComponent<InventorySlotUI>();
            if (slotUI != null)
            {
                slotUI.Initialize(slotData, this); // Pass the whole InventorySlot
                slotUI.SetEquipped(playerInventory.IsItemEquipped(slotData.item));
            }
        }
    }

    public void OnSlotSelected(InventorySlotUI slot)
    {
        if (itemInfoPanel != null)
        {
            itemInfoPanel.DisplayItemInfo(slot.GetItem());
        }
    }

    public void OnUnequipSlotSelected()
    {
        if (itemInfoPanel != null)
        {
            itemInfoPanel.DisplayUnequipInfo();
        }
    }

    public void OnSlotInteracted(InventorySlotUI slot)
    {
        if (isInSelectionMode)
        {
            playerInventory.EquipItem(slot.GetItem(), selectionCategory, selectionSlotIndex);
            CloseWindowAndReturnToEquipment();
        }
        else
        {
            interactionFooter?.ShowOptionsForItem(slot.GetItem());
        }
    }

    public void OnUseItem(ConsumableItem item)
    {
        if (item != null)
        {
            // Find the corresponding inventory slot to pass to UseConsumable
            InventorySlot slotToUse = playerInventory.consumableInventory.FirstOrDefault(s => s.item == item);
            if (slotToUse != null)
            {
                playerInventory.UseConsumable(slotToUse);
            }
        }
    }

    public void OnDropItem(Item item)
    {
        if (item != null)
        {
            playerInventory.DropItem(item);
        }
    }

    public void OnUnequipSlotInteracted()
    {
        if (isInSelectionMode)
        {
            playerInventory.UnequipItemFromSlot(selectionCategory, selectionSlotIndex);
            CloseWindowAndReturnToEquipment();
        }
    }

    private void CloseWindowAndReturnToEquipment()
    {
        gameObject.SetActive(false);
        FindObjectOfType<UIManager>().OpenEquipmentWindow();
        ExitSelectionMode();
    }

    private int GetTabIndexForCategory(EquipmentSlotCategory category)
    {
        return category switch
        {
            EquipmentSlotCategory.RightHand => 0,  // Weapons
            EquipmentSlotCategory.Armor
                or EquipmentSlotCategory.Head
                or EquipmentSlotCategory.Body
                or EquipmentSlotCategory.Hands
                or EquipmentSlotCategory.Legs => 1,// Armor
            EquipmentSlotCategory.Talisman => 2,   // Talismans
            EquipmentSlotCategory.Consumable => 3, // Consumables
            // Add LeftHand case later
            _ => 0,
        };
    }
}


--- END FILE: UI\InventoryWindowUI.cs ---

--- START FILE: UI\ItemInfoPanelUI.cs ---

using UnityEngine;
using UnityEngine.UI;
using TMPro;

public class ItemInfoPanelUI : MonoBehaviour
{
    [SerializeField] private Image itemIcon;
    [SerializeField] private TMP_Text itemNameText;
    [SerializeField] private TMP_Text itemDescriptionText;
    [SerializeField] private TMP_Text itemStatsText;

    public void DisplayItemInfo(Item item)
    {
        if (item != null)
        {
            gameObject.SetActive(true);
            itemNameText.text = item.itemName;
            itemDescriptionText.text = item.itemDescription;
            itemStatsText.text = item.GetItemStatsText();
            if (itemIcon != null)
            {
                itemIcon.sprite = item.itemIcon;
                itemIcon.enabled = true;
            }
        }
        else
        {
            ClearPanel();
        }
    }

    public void DisplayUnequipInfo()
    {
        gameObject.SetActive(true);
        itemNameText.text = "Unequip";
        itemDescriptionText.text = "Remove the item from this slot.";
        itemStatsText.text = "";
        if (itemIcon != null)
        {
            itemIcon.sprite = null;
            itemIcon.enabled = false;
        }
    }

    public void ClearPanel()
    {
        itemNameText.text = "";
        itemDescriptionText.text = "";
        itemStatsText.text = "";
        if (itemIcon != null)
        {
            itemIcon.sprite = null;
            itemIcon.enabled = false;
        }
        gameObject.SetActive(false);
    }
}


--- END FILE: UI\ItemInfoPanelUI.cs ---

--- START FILE: UI\ItemInteractionFooterUI.cs ---

using UnityEngine;
using UnityEngine.UI;

public class ItemInteractionFooterUI : MonoBehaviour
{
    [SerializeField] private Button useButton;
    [SerializeField] private Button dropButton;

    private InventoryWindowUI inventoryWindow;
    private Item currentSelectedItem;

    public void Initialize(InventoryWindowUI parentWindow)
    {
        inventoryWindow = parentWindow;
        useButton.onClick.AddListener(OnUseClicked);
        dropButton.onClick.AddListener(OnDropClicked);
    }

    public void ShowOptionsForItem(Item item)
    {
        currentSelectedItem = item;
        if (item == null)
        {
            gameObject.SetActive(false);
            return;
        }

        gameObject.SetActive(true);

        // Show/hide USE button
        useButton.gameObject.SetActive(item is ConsumableItem);

        // Show/hide DROP button
        dropButton.gameObject.SetActive(item.isDroppable);

        // Set the first active button as the selected object for controller navigation
        if (useButton.gameObject.activeInHierarchy)
        {
            UnityEngine.EventSystems.EventSystem.current.SetSelectedGameObject(useButton.gameObject);
        }
        else if (dropButton.gameObject.activeInHierarchy)
        {
            UnityEngine.EventSystems.EventSystem.current.SetSelectedGameObject(dropButton.gameObject);
        }
    }

    public void Hide()
    {
        gameObject.SetActive(false);
        currentSelectedItem = null;
    }

    private void OnUseClicked()
    {
        inventoryWindow?.OnUseItem(currentSelectedItem as ConsumableItem);
        Hide();
    }

    private void OnDropClicked()
    {
        inventoryWindow?.OnDropItem(currentSelectedItem);
        Hide();
    }

    private void OnDestroy()
    {
        useButton.onClick.RemoveAllListeners();
        dropButton.onClick.RemoveAllListeners();
    }
}


--- END FILE: UI\ItemInteractionFooterUI.cs ---

--- START FILE: UI\LevelUpWindowUI.cs ---

using UnityEngine;
using UnityEngine.UI;
using TMPro;

public class LevelUpWindowUI : MonoBehaviour
{
    [Header("Core References")]
    [SerializeField] private PlayerStats playerStats;

    [Header("Header Info")]
    [SerializeField] private TMP_Text playerLevelText;
    [SerializeField] private TMP_Text currencyText;

    [Header("Stat Rows")]
    [SerializeField] private StatRowUI healthStatRow;
    [SerializeField] private StatRowUI staminaStatRow;
    [SerializeField] private StatRowUI attackStatRow;
    [SerializeField] private StatRowUI defenseStatRow;

    [Header("Footer Info")]
    [SerializeField] private TMP_Text levelUpCostText;
    [SerializeField] private Button confirmButton;

    private void Awake()
    {
        if (playerStats == null)  Debug.LogError("Player Stats missing on LEVEL UP window.");
        if (confirmButton != null)
        {
            confirmButton.onClick.AddListener(OnConfirmLevelUp);
        }
    }

    private void OnEnable()
    {
        PlayerStats.OnStatsRecalculated += RefreshUI;
        PlayerStats.OnCurrencyChanged += (newAmount) => RefreshUI();

        // Refresh the UI as soon as the window is opened
        RefreshUI();
    }

    private void OnDisable()
    {
        PlayerStats.OnStatsRecalculated -= RefreshUI;
        PlayerStats.OnCurrencyChanged -= (newAmount) => RefreshUI();
    }

    private void RefreshUI()
    {
        if (playerStats == null) return;

        // Update Header
        playerLevelText.text = playerStats.characterLevel.ToString();
        currencyText.text = playerStats.currentCurrency.ToString();

        // Get stat increase preview
        var (nextHealth, nextStamina, nextAttack, nextDefense) = playerStats.GetStatPreviewForNextLevel();

        // Update Stat Rows
        healthStatRow.UpdateRow(playerStats.maxHealth, nextHealth);
        staminaStatRow.UpdateRow(playerStats.maxStamina, nextStamina);
        attackStatRow.UpdateRow(playerStats.baseAttackPower, nextAttack);
        defenseStatRow.UpdateRow(playerStats.baseDefense, nextDefense);

        // Update Footer
        int cost = playerStats.GetLevelUpCost();
        levelUpCostText.text = cost.ToString();

        // Enable or disable the confirm button based on whether the player can afford it
        if (confirmButton != null)
        {
            confirmButton.interactable = playerStats.currentCurrency >= cost;
        }
    }

    private void OnConfirmLevelUp()
    {
        if (playerStats != null)
        {
            playerStats.LevelUp();
            // The UI will automatically refresh because LevelUp triggers OnStatsRecalculated
        }
    }
}

--- END FILE: UI\LevelUpWindowUI.cs ---

--- START FILE: UI\QuickSlotsUI.cs ---

using System;
using TMPro;
using UnityEngine;
using UnityEngine.UI;

public class QuickSlotsUI : MonoBehaviour
{
    [SerializeField] private PlayerInventory playerInventory;
    [Header("Weapon Slot")]
    [SerializeField] private Image rightWeaponIcon;
    // [SerializeField] Image leftWeaponIcon; // For shield later

    [Header("Consumable Slots")]
    [SerializeField] private Image currentConsumableIcon;
    [SerializeField] private TMP_Text currentConsumableQuantity;
    [SerializeField] private Image nextConsumableIcon;

    private void Awake()
    {
        if (playerInventory == null) Debug.LogError("Inventory reference not set for Quick Slots UI");
        PlayerInventory.OnEquipmentUpdated += RefreshAllSlots;
        PlayerInventory.OnInventoryUpdated += RefreshAllSlots;
    }

    private void OnDestroy()
    {
        PlayerInventory.OnEquipmentUpdated -= RefreshAllSlots;
        PlayerInventory.OnInventoryUpdated += RefreshAllSlots;
    }

    public void RefreshAllSlots()
    {
        if (playerInventory == null) return;

        UpdateEquippedWeaponUI(playerInventory.EquippedRightWeapon);
        UpdateConsumableUI();
    }

    private void UpdateEquippedWeaponUI(WeaponItem equippedWeapon)
    {
        WeaponItem weaponToShow = equippedWeapon ?? playerInventory.unarmedWeaponData;

        if (weaponToShow != null && !weaponToShow.isUnarmed && weaponToShow.itemIcon != null)
        {
            rightWeaponIcon.sprite = weaponToShow.itemIcon;
            rightWeaponIcon.enabled = true;
        }
        else
        {
            rightWeaponIcon.sprite = null;
            rightWeaponIcon.enabled = false;
        }
    }

    private void UpdateConsumableUI()
    {
        InventorySlot currentSlot = playerInventory.CurrentConsumableSlot;
        InventorySlot nextSlot = playerInventory.NextConsumableSlot;

        // --- Update Current Consumable Slot (D-Pad Up) ---
        if (currentSlot != null && currentSlot.item != null)
        {
            currentConsumableIcon.sprite = currentSlot.item.itemIcon;
            currentConsumableIcon.enabled = true;

            if (currentConsumableQuantity != null)
            {
                currentConsumableQuantity.text = currentSlot.quantity.ToString();
                currentConsumableQuantity.enabled = true;
            }
        }
        else
        {
            // No consumable equipped
            currentConsumableIcon.sprite = null;
            currentConsumableIcon.enabled = false;
            if (currentConsumableQuantity != null) currentConsumableQuantity.enabled = false;
        }

        // --- Update Next Consumable Slot (D-Pad Down) ---
        // Hide the "next" icon if there's only one or zero items to cycle through
        if (nextSlot != null && nextSlot.item != null && playerInventory.consumableQuickSlots.Count > 1)
        {
            nextConsumableIcon.sprite = nextSlot.item.itemIcon;
            nextConsumableIcon.enabled = true;
        }
        else
        {
            nextConsumableIcon.sprite = null;
            nextConsumableIcon.enabled = false;
        }
    }
}


--- END FILE: UI\QuickSlotsUI.cs ---

--- START FILE: UI\StatRowUI.cs ---

using UnityEngine;
using TMPro;

public class StatRowUI : MonoBehaviour
{
    [SerializeField] private TMP_Text statNameText;
    [SerializeField] private TMP_Text currentValueText;
    [SerializeField] private TMP_Text nextValueText;
    [SerializeField] private GameObject rightArrowIcon;

    public void UpdateRow(float currentValue, float nextValue)
    {
        currentValueText.text = currentValue.ToString();

        if (nextValue > currentValue)
        {
            nextValueText.text = Mathf.RoundToInt(nextValue).ToString();
            rightArrowIcon.SetActive(true);
            nextValueText.gameObject.SetActive(true);
        }
        else
        {
            rightArrowIcon.SetActive(false);
            nextValueText.gameObject.SetActive(false);
        }
    }
}

--- END FILE: UI\StatRowUI.cs ---

--- START FILE: UI\StatUIBar.cs ---

using UnityEngine;
using UnityEngine.UI;

public class StatUIBar : MonoBehaviour
{
    private Slider slider;

    private void Awake()
    {
        slider = GetComponent<Slider>();
    }

    public void SetMaxSliderValue(float maxHealth)
    {
        slider.maxValue = maxHealth;
        slider.value = maxHealth;
    }

    public void SetCurrentStatValue(float currentStatValue)
    {
        slider.value = currentStatValue;
    }
}


--- END FILE: UI\StatUIBar.cs ---

--- START FILE: UI\StatusWindowUI.cs ---

using UnityEngine;
using TMPro;
using System.Collections.Generic;

public class StatusWindowUI : MonoBehaviour
{
    [Header("Core References")]
    [SerializeField] private PlayerStats playerStats;
    [SerializeField] private PlayerInventory playerInventory;

    [Header("Stat Text Fields")]
    [SerializeField] private TMP_Text healthText;
    [SerializeField] private TMP_Text staminaText;
    [SerializeField] private TMP_Text staminaRegenText;
    [SerializeField] private TMP_Text attackPowerText;
    [SerializeField] private TMP_Text defenseText;

    [Header("Buffs Display")]
    [SerializeField] private Transform buffsContainer;
    [SerializeField] private GameObject buffIconPrefab; // Prefab for displaying a single buff

    [Header("Display Refresh")]
    [SerializeField] private float refreshRate = 1.0f;
    private float refreshTimer = 0.0f;

    private void OnEnable()
    {
        // Find references if not assigned
        if (playerStats == null) playerStats = FindObjectOfType<PlayerStats>();
        if (playerInventory == null) playerInventory = FindObjectOfType<PlayerInventory>();

        RefreshAllStats();
    }

    private void Update()
    {
        refreshTimer += Time.deltaTime;
        if (refreshTimer >= refreshRate)
        {
            refreshTimer = 0.0f;
            RefreshAllStats();
        }
    }

    public void RefreshAllStats()
    {
        if (playerStats == null || playerInventory == null)
        {
            Debug.LogError("StatusWindowUI: Missing PlayerStats or PlayerInventory reference!");
            return;
        }

        // Update Main Stats
        healthText.text = $"{playerStats.currentHealth} / {playerStats.maxHealth}";
        staminaText.text = $"{(int)playerStats.currentStamina} / {(int)playerStats.maxStamina}";
        staminaRegenText.text = playerStats.FinalStaminaRegen.ToString("F1"); // One decimal place

        // Attack Power
        attackPowerText.text = playerStats.TotalAttackPower.ToString();

        defenseText.text = playerStats.TotalDefense.ToString();

        // Update Buffs
        UpdateBuffsDisplay();
    }

    private void UpdateBuffsDisplay()
    {
        // Clear old buff icons
        foreach (Transform child in buffsContainer)
        {
            Destroy(child.gameObject);
        }

        // Get active buffs and create UI elements for them
        List<ActiveBuffInfo> activeBuffs = playerStats.GetActiveBuffs();
        foreach (var buffInfo in activeBuffs)
        {
            GameObject buffGO = Instantiate(buffIconPrefab, buffsContainer);
            BuffIconUI buffUI = buffGO.GetComponent<BuffIconUI>();
            if (buffUI != null)
            {
                buffUI.SetBuff(buffInfo);
            }
        }
    }
}


--- END FILE: UI\StatusWindowUI.cs ---

--- START FILE: UI\TabButtonUI.cs ---

using UnityEngine;

public class TabButtonUI : MonoBehaviour
{
    [SerializeField] private GameObject activeSprite;
    [SerializeField] private GameObject inactiveSprite;

    private void Awake()
    {
        if (activeSprite == null) Debug.LogWarning($"Active Sprite for Inventory Tab [{gameObject.name}]");
        if (inactiveSprite == null) Debug.LogWarning($"Inactive Sprite for Inventory Tab [{gameObject.name}]");
    }

    public void SetActiveState(bool isActive)
    {
        activeSprite.SetActive(isActive);
        inactiveSprite.SetActive(!isActive);
    }
}

--- END FILE: UI\TabButtonUI.cs ---

--- START FILE: UI\UIManager.cs ---

using UnityEngine;

public class UIManager : MonoBehaviour
{
    [Header("Core References")]
    [SerializeField] private InputHandler inputHandler;
    [SerializeField] private PlayerInventory playerInventory;

    [Header("UI Windows")]
    [SerializeField] private GameObject hudWindow;
    [SerializeField] private GameObject mainMenuWindow; // Loadout, Inventory, Options buttons
    [SerializeField] private GameObject equipmentWindow;
    [SerializeField] private GameObject inventoryWindow;
    [SerializeField] private GameObject optionsWindow;
    [SerializeField] private GameObject itemInfoWindow;
    [SerializeField] private InventoryWindowUI inventoryWindowUI;
    [SerializeField] private GameObject statusWindow;
    [SerializeField] private GameObject levelUpWindow;

    public bool IsMenuOpen { get; private set; }

    private void Awake()
    {
        if (inputHandler == null) inputHandler = FindObjectOfType<InputHandler>();
        if (inventoryWindowUI == null) inventoryWindowUI = inventoryWindow.GetComponent<InventoryWindowUI>();
    }

    private void OnEnable()
    {
        InputHandler.OptionsButtonPressed += ToggleMainMenu;
        InputHandler.UICancelPressed += HandleCancel; // Listen for UI cancel to close menu
    }

    private void OnDisable()
    {
        InputHandler.OptionsButtonPressed -= ToggleMainMenu;
        InputHandler.UICancelPressed -= HandleCancel;
    }

    public void ToggleMainMenu()
    {
        IsMenuOpen = !IsMenuOpen;

        if (IsMenuOpen)
        {
            OpenMainMenu();
        }
        else
        {
            CloseAllMenus();
        }
    }

    private void OpenMainMenu()
    {
        hudWindow.SetActive(false);
        mainMenuWindow.SetActive(true);

        equipmentWindow.SetActive(false);
        inventoryWindow.SetActive(false);
        optionsWindow.SetActive(false);
        statusWindow.SetActive(false);
        levelUpWindow.SetActive(false);

        //Time.timeScale = 0f; // Pause game
        inputHandler.EnableUIInput();
        Cursor.lockState = CursorLockMode.None; // Re-lock cursor
        Cursor.visible = true;
        // TODO: Select the first button in mainMenuWindow for controller navigation
    }

    public void CloseAllMenus()
    {
        IsMenuOpen = false;
        hudWindow.SetActive(true);
        mainMenuWindow.SetActive(false);
        equipmentWindow.SetActive(false);
        inventoryWindow.SetActive(false);
        optionsWindow.SetActive(false);
        itemInfoWindow.SetActive(false);
        statusWindow.SetActive(false);
        levelUpWindow.SetActive(false);

        inventoryWindowUI?.ExitSelectionMode();

        //Time.timeScale = 1f; // Resume game
        inputHandler.EnableGameplayInput();
        Cursor.lockState = CursorLockMode.Locked; // Re-lock cursor
        Cursor.visible = false;
    }

    private void HandleCancel()
    {
        if (levelUpWindow != null && levelUpWindow.activeSelf)
        {
            CloseAllMenus();
            return;
        }

        if (IsMenuOpen)
        {
            // Add more complex logic here if you have deeper menus
            CloseAllMenus();
        }
    }

    public void ShowInventoryForSelection(EquipmentSlotUI clickedSlot)
    {
        if (inventoryWindowUI == null) return;

        // Hide other windows
        equipmentWindow.SetActive(false);

        // Tell the inventory window to open in selection mode
        inventoryWindowUI.OpenInSelectionMode(clickedSlot.slotCategory, clickedSlot.slotIndex);

        // Show the inventory window
        inventoryWindow.SetActive(true);
    }

    // --- Methods to be called by main menu buttons ---
    public void OpenEquipmentWindow()
    {
        mainMenuWindow.SetActive(false);
        equipmentWindow.SetActive(true);
    }

    public void OpenInventoryWindow()
    {
        mainMenuWindow.SetActive(false);
        inventoryWindow.SetActive(true);
    }

    public void OpenOptionsWindow()
    {
        mainMenuWindow.SetActive(false);
        optionsWindow.SetActive(true);
    }

    public void OpenStatusWindow()
    {
        mainMenuWindow.SetActive(false);
        statusWindow.SetActive(true);
    }

    public void OpenLevelUpWindow()
    {
        mainMenuWindow.SetActive(false);
        hudWindow.SetActive(false);
        equipmentWindow.SetActive(false);
        inventoryWindow.SetActive(false);
        optionsWindow.SetActive(false);
        statusWindow.SetActive(false);

        levelUpWindow.SetActive(true);

        IsMenuOpen = true;
        inputHandler.EnableUIInput();
        Cursor.lockState = CursorLockMode.None;
        Cursor.visible = true;
    }
}


--- END FILE: UI\UIManager.cs ---

--- START FILE: UI\UnequipSlotUI.cs ---

using UnityEngine;
using UnityEngine.EventSystems;

public class UnequipSlotUI : MonoBehaviour, IPointerEnterHandler, ISelectHandler
{
    private InventoryWindowUI parentWindow;

    public void Initialize(InventoryWindowUI parent)
    {
        parentWindow = parent;
    }

    // Called by a Button component's OnClick() event
    public void OnUnequipClicked()
    {
        parentWindow?.OnUnequipSlotInteracted();
    }

    public void OnPointerEnter(PointerEventData eventData)
    {
        parentWindow?.OnUnequipSlotSelected();
    }

    public void OnSelect(BaseEventData eventData)
    {
        parentWindow?.OnUnequipSlotSelected();
    }
}


--- END FILE: UI\UnequipSlotUI.cs ---

--- START FILE: UI\WeaponInventorySlot.cs ---

using UnityEngine;
using UnityEngine.UI;

public class WeaponInventorySlot : MonoBehaviour
{
    [SerializeField] private UIManager uiManager;
    [SerializeField] private PlayerInventory playerInventory;
    [SerializeField] private WeaponSlotManager weaponSlotManager;
    [SerializeField] private EquipmentWindowUI equipmentWindowUI;
    [SerializeField] private Image weaponIcon;
    private WeaponItem weaponItem;

    public void AddItem(WeaponItem weaponToBeAssigned) {
        weaponItem = weaponToBeAssigned;

        weaponIcon.sprite = weaponItem.itemIcon;
        weaponIcon.enabled = true;

        gameObject.SetActive(true);
    }

    public void ClearInventorySlot() {
        weaponItem = null;
        
        weaponIcon.sprite = null;
        weaponIcon.enabled = false;

        gameObject.SetActive(false);
    }

    public void EquipItem()
    {
        //playerInventory.weaponsInventory.Add((WeaponItem)playerInventory.GetItemFromEquipSlot(uiManager.currentSelectedSlotType));
        //playerInventory.SetItemFromEquipSlot(uiManager.currentSelectedSlotType, weaponItem);
        //playerInventory.weaponsInventory.Remove(weaponItem);

        //weaponSlotManager.LoadWeaponOnSlot(playerInventory.RightHandWeapon, false);
        //weaponSlotManager.LoadWeaponOnSlot(playerInventory.LeftHandWeapon, true);

        //equipmentWindowUI.LoadWeaponOnEquipementScreen(playerInventory);
        //uiManager.currentSelectedSlotType = 0;
    }
}


--- END FILE: UI\WeaponInventorySlot.cs ---

